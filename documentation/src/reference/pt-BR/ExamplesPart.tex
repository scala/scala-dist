\def\exercise{
   \def\theresult{Exercício~\thesection.\arabic{result}}
   \refstepcounter{result}
   \trivlist\item[\hskip
   \labelsep{\bf \theresult}]}
\def\endexercise{\endtrivlist}
 
\newcommand{\rewriteby}[1]{\mbox{\tab\tab\rm(#1)}}

\chapter{\label{chap:example-one}Um primeiro exemplo}

Para come\c{c}ar, apresentamos um primeiro exemplo, a implementa\c{c}\~{a}o de Quicksort em Scala.

\begin{lstlisting}
def sort(xs: Array[Int]) {
  def swap(i: Int, j: Int) {
    val t = xs(i); xs(i) = xs(j); xs(j) = t
  }
  def sort1(l: Int, r: Int) {
    val pivot = xs((l + r) / 2)
    var i = l; var j = r
    while (i <= j) {
      while (xs(i) < pivot) i += 1
      while (xs(j) > pivot) j -= 1
      if (i <= j) { 
        swap(i, j)
        i += 1
        j -= 1
      }
    } 
    if (l < j) sort1(l, j)
    if (j < r) sort1(i, r)
  }
  sort1(0, xs.length - 1)
}
\end{lstlisting}

A implementa\c{c}\~{a}o se parece muito com a que voc\^{e} faria em Java
ou C. N\'{o}s usamos os mesmos operadores e estruturas de controle.
Existem tamb\'{e}m algumas pequenas diferen\c{c}as sint\'{a}ticas, particularmente:
\begin{itemize}
\item
As declara\c{c}\~{o}es come\c{c}am usando palavras reservadas. Particularmente, declara\c{c}\~{o}es de fun\c{c}\~{o}es s\~{a}o iniciadas
com a palavra \code{def}, declara\c{c}\~{o}es de vari\'{a}veis s\~{a}o iniciadas com a palavra \code{var} e
declara\c{c}\~{a}o de constantes (chamadas de valores) s\~{a}o iniciadas com a palavra \code{val}.
\item
O tipo de um par\^{a}metro em uma fun\c{c}\~{a}o \'{e} declarado ap\'{o}s o nome do par\^{a}metro seguido de dois pontos(:).
O tipo pode ser omitido quando o compilador for capaz de inferi-lo pelo contexto.
\item
A  declara\c{c}\~{a}o de vetores do tipo \code{T} \'{e} feita usando a express\~{a}o \code{Array[T]} ao inv\'{e}s de \code{T[]}. 
O i-\'{e}simo elemento de um vetor \code{a} \'{e} acessado usando \code{a(i)} ao inv\'{e}s de \code{a[i]}.
\item
Fun\c{c}\~{o}es podem ser aninhadas umas dentro das outras. Fun\c{c}\~{o}es aninhadas podem
acessar par\^{a}metros e vari\'{a}veis locais de suas fun\c{c}\~{o}es externas. Por
exemplo, o nome do vetor \code{xs} \'{e} vis\'{i}vel nas fun\c{c}\~{o}es \code{swap} e 
\code{sort1}, e portanto n\~{a}o precisam ser passadas como um par\^{a}metro para elas.
%----------
\end{itemize}

Pelo que vimos, Scala se parece com uma linguagem bem convencional 
com algumas peculiaridades sint\'{a}ticas. De fato \'{e} poss\'{i}vel escrever
programas em estilo imperativo ou orientado a objetos. Isto \'{e} 
importante, porque \'{e} uma das coisas que facilitam combinar componentes
Scala com componentes escritos em linguagens convencionais, tais como Java,
C\# ou Visual Basic.
Entretanto, tamb\'{e}m \'{e} poss\'{i}vel escrever programas num estilo completamente
diferente. Aqui est\'{a} o Quicksort novamente, desta vez escrito em 
estilo funcional.
\begin{lstlisting}
def sort(xs: Array[Int]): Array[Int] = {
  if (xs.length <= 1) xs
  else {
    val pivot = xs(xs.length / 2)
    Array.concat(
      sort(xs filter (pivot >)),
           xs filter (pivot ==),
      sort(xs filter (pivot <)))
  }
}
\end{lstlisting}
O programa funcional captura a ess\^{e}ncia do algoritmo quicksort de modo conciso:
\begin{itemize}
\item Se o vetor est\'{a} vazio ou consiste de um \'{u}nico elemento, j\'{a} est\'{a} ordenado,
      ent\~{a}o retorne imediatamente.
\item Se o vetor n\~{a}o est\'{a} vazio, escolha um elemento do meio do vetor como piv\^{o}.
\item Particione o vetor em dois subvetores contendo, respectivamente os elementos
 que s\~{a}o menores que o elemento piv\^{o}, maiores que, e um terceiro vetor que cont\'{e}m
 elementos iguais ao piv\^{o}.
\item Ordene os dois primeiros subvetores por uma chamada recursiva da fun\c{c}\~{a}o de 
ordena\c{c}\~{a}o.\footnote{Isso n\~{a}o \'{e} exatamente o que o algoritmo imperativo faz; este 
\'{u}ltimo particiona o vetor em dois subvetores contendo elementos menores que ou 
maiores ou iguais ao piv\^{o}.}
\item O resultado \'{e} obtido pela concatena\c{c}\~{a}o dos tr\^{e}s subvetores.
\end{itemize}

Tanto a implementa\c{c}\~{a}o imperativa quanto a funcional tem mesma complexidade
assint\'{o}tica -- $O(N;log(N))$ no caso m\'{e}dio e $O(N^2)$ no pior caso. Mas onde
a implementa\c{c}\~{a}o imperativa opera localmente, modificando o vetor original,
a implementa\c{c}\~{a}o funcional retorna um novo vetor ordenado e deixa o vetor
original inalterado. A implementa\c{c}\~{a}o funcional, portanto, requer mais
mem\'{o}ria transiente que a imperativa.

A implementa\c{c}\~{a}o funcional faz parecer que Scala \'{e} uma linguagem
especializada para opera\c{c}\~{o}es funcionais sobre vetores. De fato, n\~{a}o \'{e};
todas as opera\c{c}\~{o}es usadas no exemplo s\~{a}o simples m\'{e}todos de biblioteca
de uma classe {\em sequ\^{e}ncia} \code{Seq[T]} que \'{e} parte da biblioteca
padr\~{a}o Scala, e onde ela mesma \'{e} implementada em Scala. Como vetores s\~{a}o 
inst\^{a}ncias de \verb@Seq@, todos os m\'{e}todos de sequ\^{e}ncia est\~{a}o dispon\'{i}veis
para eles.

Em particular, h\'{a} o m\'{e}todo \code{filter} que recebe como argumento uma
{\em fun\c{c}\~{a}o predicado}. Esta fun\c{c}\~{a}o predicado deve mapear elementos do 
vetor para valores boleanos. O resultado de \code{filter} \'{e} um vetor
consistindo de todos os elementos do vetor original para o qual a fun\c{c}\~{a}o
predicado \'{e} verdadeira. O m\'{e}todo \code{filter} de um objeto tipo
\code{Array[T]} portanto tem a assinatura. 


\begin{lstlisting}
def filter(p: T => Boolean): Array[T]
\end{lstlisting}

Aqui, \code{T=>Boolean} \'{e} o tipo das fun\c{c}\~{o}es que recebem um elemento 
do tipo \code{T} e retornam um valor booleano do tipo \code{Boolean}. 
Fun\c{c}\~{o}es como \code{filter} 
que recebem uma outra fun\c{c}\~{a}o como argumento ou retornam uma fun\c{c}\~{a}o como
resultado s\~{a}o chamadas {\em fun\c{c}\~{o}es de alta ordem.}     

Scala n\~{a}o faz distin\c{c}\~{a}o entre nomes de identificadores e nomes de operadores.
um identificador pode ser ou uma sequ\^{e}ncia de letras ou digitos que come\c{c}am
com uma letra, ou podem ser uma sequ\^{e}ncia de caracteres especiais, tais como 
``\code{+}'', ``\code{*}'', ou ``\code{:}''.  Qualquer identificador pode
ser usado como operador infixo em Scala. A opera\c{c}\~{a}o bin\'{a}ria $E;op;E'$ \'{e} sempre
interpretado como a chamada de m\'{e}todo $E.op(E')$. Isso vale tamb\'{e}m para 
operadores bin\'{a}rios infixos que iniciam com uma letra. Consequentemente,
a express\~{a}o  ~\lstinline@xs filter (pivot >)@~ \'{e} equivalente à chamada de
m\'{e}todo ~\lstinline@xs.filter(pivot >)@.



No programa quicksort, \code{filter} \'{e} aplicado tr\^{e}s vezes a um argumento 
de fun\c{c}\~{a}o an\^{o}nima. O primeiro argumento, \code{pivot >}, representa uma 
fun\c{c}\~{a}o que recebe um argumento $x$ e retorna o valor ~\lstinline@pivot > $x$@.
Este \'{e} um exemplo de uma {\em fun\c{c}\~{a}o parcialmente aplicada}. Um outro modo, 
equivalente de se escrever esta fun\c{c}\~{a}o, que torna o argumento oculto explicito
\'{e} ~\lstinline@x => pivot > x@. A fun\c{c}\~{a}o \'{e} an\^{o}nima, ou seja, n\~{a}o \'{e} definida
com um nome. O tipo do par\^{a}metro  \code{x} \'{e} omitido porque um compilador Scala 
pode infer\'{i}-lo autom\'{a}ticamente a partir do contexto onde a fun\c{c}\~{a}o \'{e} usada.
Resumindo, \code{xs.filter(pivot >)} retorna uma lista consistindo de todos os 
elementos da lista \code{xs} que s\~{a}o menores que \code{pivot}.  
%----------

%----------
%% Looking again in detail at the first, imperative implementation of
%% Quicksort, we find that many of the language constructs used in the
%% second solution are also present, albeit in a disguised form.
Olhando novamente em detalhes para a primeira, implementa\c{c}\~{a}o imperativa
do Quicksort, percebemos que muitos dos construtores da linguagem 
usados na segunda solu\c{c}\~{a}o est\~{a}o presentes, embora de modo distinto.

Por exemplo, operadores bin\'{a}rios padr\~{a}o, tais como \code{+}, \code{-},
ou \code{<} n\~{a}o s\~{a}o tratados de modo especial. Assim como \code{append}, 
s\~{a}o m\'{e}todos de seus operandos esquerdos. Consequentemente, a express\~{a}o 
\code{i+1} \'{e} vista como a invoca\c{c}\~{a}o de \code{i.+(1)} do m\'{e}todo \code{+}      
do valor inteiro de \code{i}. De fato, um compilador \'{e} livre (se 
moderadamente esperto, ainda que  esperado) para reconhecer o caso 
especial da chamada de m\'{e}todo \code{+} sobre argumentos inteiros e 
para gerar c\'{o}digo inline eficiente para isso.  

Por efici\^{e}ncia e melhor detec\c{c}\~{a}o de erros o la\c{c}o \code{while} \'{e} um construtor 
primitivo em Scala. Mas em princ\'{i}pio, poderia do mesmo modo ser uma fun\c{c}\~{a}o 
predefinida. Aqui est\'{a} uma poss\'{i}vel implementa\c{c}\~{a}o para ele: 

\begin{lstlisting}
def While (p: => Boolean) (s: => Unit) {
  if (p) { s ; While(p)(s) }
}
\end{lstlisting}


A fun\c{c}\~{a}o \code{While} recebe como primeiro par\^{a}metro uma fun\c{c}\~{a}o teste,
que n\~{a}o recebe par\^{a}metros e produz um valor boleano. Como segundo par\^{a}metro 
recebe uma fun\c{c}\~{a}o comando que tamb\'{e}m n\~{a}o recebe par\^{a}metros e produz como 
resultado o tipo  \lstinline@Unit@. \code{While} invoca a fun\c{c}\~{a}o comando
enquanto a fun\c{c}\~{a}o teste produzir verdadeiro.

O tipo Scala \lstinline@Unit@ corresponde grosseiramente ao \lstinline@void@
no Java; \'{e} usado sempre que uma fun\c{c}\~{a}o n\~{a}o retornar um resultado interessante.
De fato, porque Scala \'{e} uma linguagem orientada a express\~{o}es, cada fun\c{c}\~{a}o 
retorna algum resultado. Se nenhuma express\~{a}o de retorno \'{e}  explicitamente
fornecida, o valor \lstinline@()@, que \'{e} pronunciado ``unit'', \'{e} assumido.
Este valor \'{e} do tipo \lstinline@Unit@. Fun\c{c}\~{o}es que retornam ``unit'' s\~{a}o 
tamb\'{e}m chamadas {\em procedimentos}. Aqui est\'{a} uma formula\c{c}\~{a}o mais 
``orientada a express\~{a}o'' da fun\c{c}\~{a}o \lstinline@swap@ na primeira implementa\c{c}\~{a}o
do quicksort, que explicita isto:

\begin{lstlisting}
def swap(i: Int, j: Int) {
  val t = xs(i); xs(i) = xs(j); xs(j) = t
  ()
}
\end{lstlisting}

O valor resultante desta fun\c{c}\~{a}o \'{e} simplesmente sua \'{u}ltima express\~{a}o---uma
palavra chave \lstinline@return@ n\~{a}o \'{e} necess\'{a}ria. Observe que fun\c{c}\~{o}es 
que retornam um valor expl\'{i}cito sempre precisam de um ``='' antes de
seus corpos ou express\~{o}es de defini\c{c}\~{a}o.

\chapter{Programando com Atores e Mensagens}
\label{chap:example-auction}
Aqui est\'{a} um exemplo que mostra uma \'{a}rea de aplica\c{c}\~{a}o para a qual Scala 
\'{e} particularmente indicada. Considere a tarefa de implementar um servi\c{c}o
de leil\~{a}o eletr\^{o}nico. Podemos usar um modelo de processo no estilo 
actor do Erlang para implementar os participantes do leil\~{a}o. Actors s\~{a}o 
objetos para os quais as mensagens s\~{a}o enviadas. Cada actor tem uma caixa de correio 
para suas mensagens de entrada que \'{e} representada para uma fila. Pode
trabalhar sequencialmente nas mensagens da sua caixa de correio, ou buscar 
por mensagens que casam com algum padr\~{a}o. 

\begin{lstlisting}[style=floating,label=fig:simple-auction-msgs,caption=Definição das Mensagens de um serviço de leilão]
import scala.actors.Actor

abstract class AuctionMessage
case class Offer(bid: Int, client: Actor)  extends AuctionMessage
case class Inquire(client: Actor)          extends AuctionMessage

abstract class AuctionReply
case class  Status(asked: Int, expire: Date) extends AuctionReply
case object BestOffer                        extends AuctionReply
case class  BeatenOffer(maxBid: Int)         extends AuctionReply
case class  AuctionConcluded(seller: Actor, client: Actor) 
                                             extends AuctionReply
case object AuctionFailed                    extends AuctionReply
case object AuctionOver                      extends AuctionReply
\end{lstlisting}
Para cada item negociado h\'{a} um actor leiloeiro que publica a 
informa\c{c}\~{a}o sobre o item negociado, que aceita ofertas de clientes
e que se comunica com o vendedor e com o vencedor do leil\~{a}o 
para fechar a transa\c{c}\~{a}o. Apresentamos uma vis\~{a}o superficial de uma
 implementa\c{c}\~{a}o aqui.

Como primeiro passo, definimos as mensagens que s\~{a}o trocadas durante um
leil\~{a}o. H\'{a} duas classes base abstratas \code{AuctionMessage} para mensagens 
de clientes do servi\c{c}o de leil\~{a}o, e \code{AuctionReply} para respostas 
do servi\c{c}o aos clientes. Para ambas as classes base h\'{a} um n\'{u}mero de casos 
definidos na Figura~\ref{fig:simple-auction-msgs}.

\begin{lstlisting}[style=floating,label=fig:simple-auction,caption=Implementação do Serviço de Leilão]
class Auction(seller: Actor, minBid: Int, closing: Date) extends Actor {
  val timeToShutdown = 36000000  // msec
  val bidIncrement = 10
  def act() {
    var maxBid = minBid - bidIncrement
    var maxBidder: Actor = null
    var running = true
    while (running) {
      receiveWithin ((closing.getTime() - new Date().getTime())) {
        case Offer(bid, client) =>
          if (bid >= maxBid + bidIncrement) { 
            if (maxBid >= minBid) maxBidder ! BeatenOffer(bid)
            maxBid = bid; maxBidder = client; client ! BestOffer
          } else {
            client ! BeatenOffer(maxBid)
          }
        case Inquire(client) =>
          client ! Status(maxBid, closing)
        case TIMEOUT =>
          if (maxBid >= minBid) {
            val reply = AuctionConcluded(seller, maxBidder)
            maxBidder ! reply; seller ! reply
          } else {
            seller ! AuctionFailed
          }
          receiveWithin(timeToShutdown) {
            case Offer(_, client) => client ! AuctionOver
            case TIMEOUT => running = false
          }
      }
    }
  } 
}
\end{lstlisting}

Para cada classe base, h\'{a} um n\'{u}mero de {\em classes case} que definem
o formato de mensagens particulares dentro da classe. Estas mensagens
podem em \'{u}ltimo caso ser mapeadas a pequenos documentos XML. Esperamos
que hajam ferramentas autom\'{a}ticas que convertam entre documentos XML e 
estruturas de dados internas, tais como as definidas acima.

A Figura~\ref{fig:simple-auction} apresenta uma implementa\c{c}\~{a}o Scala para a classe
\code{Auction} para actors do leil\~{a}o que coordenam os lances sobre um item. Objetos
para esta classe s\~{a}o criados pela indica\c{c}\~{a}o
\begin{itemize}
\item Um actor vendedor que precisa ser notificado quando o leil\~{a}o terminou,
\item o lance m\'{i}nimo,
\item a data de quando o leil\~{a}o foi fechado.
\end{itemize}  
O comportamento do actor \'{e} definido por seu m\'{e}todo \code{act}. Este m\'{e}todo seleciona
repetidamente (usando \code{receiveWithin}) uma mensagem e reage a ela, at\'{e} que o 
leil\~{a}o seja fechado, o que \'{e} sinalizado por uma mensagem \code{TIMEOUT}. Antes de 
finalmente parar, permanece ativo para um outro per\'{i}odo determinado pela constante 
\code{timeToShutdown} e replica para ofertas posteriores que o leil\~{a}o est\'{a} fechado.    

Aqui est\~{a}o algumas explica\c{c}\~{o}es extras sobre os construtores usados neste programa:
\begin{itemize}
\item
O m\'{e}todo \code{receiveWithin} da classe \code{Actor} recebe como par\^{a}metro um prazo dado
em milisegundos e uma fun\c{c}\~{a}o que processa mensagens na caixa de correio. A fun\c{c}\~{a}o \'{e} dada
por uma sequ\^{e}ncia de cases que especificam um padr\~{a}o e uma a\c{c}\~{a}o para mensagens que 
casam com o padr\~{a}o. O m\'{e}todo \code{receiveWithin} seleciona a primeira mensagem da 
caixa de correio que casa com um destes padr\~{o}es e aplica a a\c{c}\~{a}o correspondente a ele. 


\item
O \'{u}ltimo case de \code{receiveWithin} \'{e} guardado por um padr\~{a}o \code{TIMEOUT}.  
Se nenhuma outra mensagem foi recebida nesse meio tempo, este padr\~{a}o \'{e} disparado
ap\'{o}s o prazo que foi passado como argumento para o m\'{e}todo envolvente \code{receiveWithin}.
\code{TIMEOUT} \'{e} uma mensagem especial, que \'{e} disparada pela pr\'{o}pria implementa\c{c}\~{a}o do 
\code{Actor}.    

\item
Mensagens de resposta s\~{a}o enviadas usando sintaxe da forma \code{destino ! AlgumaMensagem}.
\code{!} \'{e} usado aqui como um operador bin\'{a}rio com um actor e uma mensagem como argumentos.
Isto \'{e} equivalente em Scala ao chamado de m\'{e}todo \code{destino.!(AlgumaMensagem)}, ou seja, 
a invoca\c{c}\~{a}o do m\'{e}todo \code{!} do actor destino com a mensagem dada como par\^{a}metro.
\end{itemize}    

A discuss\~{a}o precedente deu uma id\'{e}ia de programa\c{c}\~{a}o distribu\'{i}da em Scala. Isso
d\'{a} a sensa\c{c}\~{a}o que Scala tem um rico conjunto de construtores que suportam
processos actor, envio e recebimento de mensagens, programa\c{c}\~{a}o com timeouts etc.
De fato, o oposto \'{e} verdadeiro. Todos os construtores discutidos acima s\~{a}o 
oferecidos como m\'{e}todos na classe biblioteca \code{Actor}. Aquela classe \'{e}
ele mesma implementada em Scala, baseado no modelo thread subjacente à linguagem 
hospedeira (Java ou .NET). A implementa\c{c}\~{a}o de todas as caracter\'{i}sticas da 
classe \code{Actor} usada aqui \'{e} dada na Se\c{c}\~{a}o~\ref{sec:actors}.     

As vantagens da abordagem baseada em biblioteca s\~{a}o a relativa simplicidade
da linguagem n\'{u}cleo e a flexibilidade para os criadores de biblioteca. Como 
a linguagem n\'{u}cleo n\~{a}o precisa especificar detalhes da comunica\c{c}\~{a}o dos 
processos de alto n\'{i}vel, pode ser mantida mais simples e geral. Como
um modelo particular de mensagens numa caixa de correio \'{e} um m\'{o}dulo biblioteca, 
pode ser modificado livremente se um diferente modelo for necess\'{a}rio em algumas 
aplica\c{c}\~{o}es. A abordagem requer, entretanto, que a linguagem n\'{u}cleo seja expressiva
o suficiente para prover as abstra\c{c}\~{o}es lingu\'{i}sticas necess\'{a}rias de um modo 
conveniente. Scala foi criada com isto em mente; um de seus maiores objetivos de 
design foi deix\'{a}-la flex\'{i}vel o suficiente para atuar como uma conveniente linguagem
hospedeira para dom\'{i}nios de linguagens espec\'{i}ficos implementados por m\'{o}dulos de 
biblioteca. Por exemplo, a constru\c{c}\~{a}o de comunica\c{c}\~{a}o actor apresentada acima
pode ser vista como um desses dom\'{i}nios espec\'{i}ficos de linguagem, que conceitualmente
estendem o n\'{u}cleo Scala.  

\chapter{\label{chap:simple-funs}Express\~{o}es e Fun\c{c}\~{o}es Simples}

Os exemplos anteriores deram uma ideia do que pode ser feito com Scala. Agora,
introduzimos as suas constru\c{c}\~{o}es de linguagem uma a uma de uma maneira mais sistem\'{a}tica.
Vamos come\c{c}ar com os menores elementos: express\~{o}es e fun\c{c}\~{o}es.


\section{Express\~{o}es e Fun\c{c}\~{o}es Simples}


Scala vem com um interpretador que pode ser visto como uma calculadora sofisticada.
O usu\'{a}rio interage com a calculadora digitando express\~{o}es. A calculadora retorna o
resultado do c\'{a}lculo e o seu tipo de dado. Por exemplo: 

\begin{lstlisting}
scala> 87 + 145
unnamed0: Int = 232

scala> 5 + 2 * 3
unnamed1: Int = 11

scala> "hello" + " world!"
unnamed2: java.lang.String = hello world!
\end{lstlisting}

Tamb\'{e}m \'{e} poss\'{i}vel dar nome a uma sub-express\~{a}o e usar o nome, ao inv\'{e}s da express\~{a}o, 
nas express\~{o}es seguintes:
\begin{lstlisting}
scala> def scale = 5
scale: Int

scala> 7 * scale
unnamed3: Int = 35
\end{lstlisting}
\begin{lstlisting}
scala> def pi = 3.141592653589793
pi: Double

scala> def radius = 10
radius: Int

scala> 2 * pi * radius
unnamed4: Double = 62.83185307179586
\end{lstlisting}


Defini\c{c}\~{o}es come\c{c}am com a palavra reservada \code{def}. Elas introduzem um nome
que representa a express\~{a}o que vem depois do s\'{i}mbolo \code{=}. O intepretrador
responde com o nome introduzido e o seu tipo de dado.

Executando uma defini\c{c}\~{a}o tal como \code{def x = e} n\~{a}o avaliar\'{a} a express\~{a}o \code{e}. 
Ao inv\'{e}s \code{e} \'{e} avaliado sempre que \code{x} for usado. Alternativamente, Scala 
oferece um valor defini\c{c}\~{a}o \code{val x = e}, o qual avalia o lado direito de \code{e}
como parte da avalia\c{c}\~{a}o da defini\c{c}\~{a}o. Se \code{x} \'{e} ent\~{a}o usado subsequentemente, \'{e} 
imediatamente substitu\'{i}do pelo valor pr\'{e}-computado de \code{e}, logo a express\~{a}o n\~{a}o 
precisa ser avaliada novamente.

Como as express\~{o}es s\~{a}o avaliadas? Uma express\~{a}o consistindo de operadores e 
operandos \'{e} avaliada pela repetida aplica\c{c}\~{a}o dos seguintes passos de simplifica\c{c}\~{a}o:
\begin{itemize}
\item escolha a opera\c{c}\~{a}o mais a esquerda.
\item avalie seu operando
\item aplique o operador aos valores do operando.
\end{itemize}
Um nome definido por \code{def} \'{e} avaliado substituindo o nome pela defini\c{c}\~{a}o do lado
direito (n\~{a}o avaliada). Um nome definido por \code{val} \'{e} avaliado pela substitui\c{c}\~{a}o do 
nome pelo valor da defini\c{c}\~{a}o do lado direito. O processo de avalia\c{c}\~{a}o p\'{a}ra assim que 
encontrarmos um valor. Um valor \'{e} algum dado, tal como uma cadeia de caracteres, um n\'{u}mero, 
um vetor, ou uma lista.

\example
Aqui est\'{a} uma avalia\c{c}\~{a}o de uma express\~{a}o aritm\'{e}tica.

\begin{lstlisting}
$\,\,\,$   (2 * pi) * radius
$\rightarrow$  (2 * 3.141592653589793) * radius
$\rightarrow$  6.283185307179586 * radius
$\rightarrow$  6.283185307179586 * 10
$\rightarrow$  62.83185307179586
\end{lstlisting}
O processo de simplificar gradualmente express\~{o}es para valores \'{e} 
chamado {\em redu\c{c}\~{a}o}.

\section{Par\^{a}metros}

Usando \code{def}, pode-se tamb\'{e}m definir fun\c{c}\~{o}es com par\^{a}metros. Por exemplo:
\begin{lstlisting}
scala> def square(x: Double) = x * x
square: (Double)Double

scala> square(2)
unnamed0: Double = 4.0

scala> square(5 + 3)
unnamed1: Double = 64.0

scala> square(square(4))
unnamed2: Double = 256.0

scala> def sumOfSquares(x: Double, y: Double) = square(x) + square(y)
sumOfSquares: (Double,Double)Double

scala> sumOfSquares(3, 2 + 2)
unnamed3: Double = 25.0
\end{lstlisting}

Par\^{a}metros de fun\c{c}\~{o}es seguem o nome da fun\c{c}\~{a}o e sempre s\~{a}o envolvidos por
par\^{e}nteses. Cada par\^{a}metro vem com um tipo que segue o nome do par\^{a}metro
e dois pontos. At\'{e} aqui, s\'{o} precisamos de tipos num\'{e}ricos, tal como o tipo
\code{scala.Double} dos n\'{u}meros de precis\~{a}o dupla. Scala define {\em tipos
aliases} para alguns tipos b\'{a}sicos, logo podemos escrever tipos num\'{e}ricos 
como em Java. Por exemplo, \code{double} \'{e} um tipo alias de \code{scala.Double}
e \code{int} \'{e} um tipo alias para \code{scala.Int}.       

Fun\c{c}\~{o}es com par\^{a}metros s\~{a}o avaliadas analogamente a operadores em express\~{o}es.
Primeiro, os argumentos da fun\c{c}\~{a}o s\~{a}o avaliados (da esquerda para direita). 
Ent\~{a}o, a aplica\c{c}\~{a}o da fun\c{c}\~{a}o \'{e} substitu\'{i}do pelo lado direito da fun\c{c}\~{a}o, e
ao mesmo tempo todos os par\^{a}metros formais s\~{a}o substitu\'{i}dos pelos seus 
argumentos atuais. 

\example\ 
 
\begin{lstlisting}
$\,\,\,$   sumOfSquares(3, 2+2)
$\rightarrow$  sumOfSquares(3, 4)
$\rightarrow$  square(3) + square(4)
$\rightarrow$  3 * 3 + square(4)
$\rightarrow$  9 + square(4)
$\rightarrow$  9 + 4 * 4
$\rightarrow$  9 + 16
$\rightarrow$  25
\end{lstlisting}

O exemplo mostra que o interpretador reduz argumentos de fun\c{c}\~{o}es a valores 
antes de reescrever a aplica\c{c}\~{a}o da fun\c{c}\~{a}o. Pode-se ao inv\'{e}s escolher aplicar
a fun\c{c}\~{a}o a argumentos n\~{a}o reduzidos. Isto levar\'{a} a seguinte sequ\^{e}ncia de 
redu\c{c}\~{a}o: 
%----------

\begin{lstlisting}
$\,\,\,$   sumOfSquares(3, 2+2)
$\rightarrow$  square(3) + square(2+2)
$\rightarrow$  3 * 3 + square(2+2)
$\rightarrow$  9 + square(2+2)
$\rightarrow$  9 + (2+2) * (2+2)
$\rightarrow$  9 + 4 * (2+2)
$\rightarrow$  9 + 4 * 4
$\rightarrow$  9 + 16
$\rightarrow$  25
\end{lstlisting}

A segunda ordem de avalia\c{c}\~{a}o \'{e} conhecida como \emph{chamada por nome},
e a primeira por \emph{chamada por valor}. Para express\~{o}es que se utilizam
apenas de fun\c{c}\~{o}es e que portanto podem ser reduzidas com o modelo de 
substitui\c{c}\~{a}o, ambos os esquemas levam ao mesmo valor final.

Chamada por valor tem a vantagem de evitar avalia\c{c}\~{o}es repetidas de argumentos.
Chamada por nome tem a vantagem de evitar avalia\c{c}\~{o}es de argumentos quando o 
par\^{a}metro n\~{a}o \'{e} usado pela fun\c{c}\~{a}o. Chamada por valor \'{e} geralmente mais 
eficiente que chamada por nome, mas uma avalia\c{c}\~{a}o de chamada por valor
pode entrar em la\c{c}o infinito, enquanto uma avalia\c{c}\~{a}o de chamada por nome 
termina. Considere: 

\begin{lstlisting}
scala> def loop: Int = loop
loop: Int

scala> def first(x: Int, y: Int) = x
first: (Int,Int)Int
\end{lstlisting}

Ent\~{a}o \code{first(1, loop)} \'{e} reduzido com uma chamada por nome a \code{1},
enquanto o mesmo termo, atrav\'{e}s de uma chamada por valor reduz a si mesmo 
repetidamente, logo a avalia\c{c}\~{a}o n\~{a}o termina.  

\begin{lstlisting}
$\,\,\,$   first(1, loop)
$\rightarrow$  first(1, loop)
$\rightarrow$  first(1, loop)
$\rightarrow$  ...
\end{lstlisting}

Scala usa chamada por valor por default, mas muda para avalia\c{c}\~{a}o de chamada por nome 
se o tipo do par\^{a}metro for precedido por \code{=>}. 
\example\ 
 
\begin{lstlisting}
scala> def constOne(x: Int, y: => Int) = 1
constOne: (Int,=> Int)Int

scala> constOne(1, loop)
unnamed0: Int = 1

scala> constOne(loop, 2)               // leva a laco infinito
^C                                     // para a execucao com Ctrl-C
\end{lstlisting}

\section{Express\~{o}es Condicionais}
O \code{if-else} do Scala leva a uma escolha entre duas alternativas. Sua
sintaxe \'{e} a mesma do \code{if-else} do Java. Mas onde o \code{if-else} do 
Java pode ser usado somente como uma alternativa entre comandos, Scala 
permite a mesma sintaxe para escolher entre duas express\~{o}es. Isso porque o
\code{if-else} do Scala serve tamb\'{e}m como um substituto para a express\~{a}o 
condicional do Java \code{... ? ... : ...}.      

\example\
\begin{lstlisting}
scala> def abs(x: Double) = if (x >= 0) x else -x
abs: (Double)Double
\end{lstlisting}
Express\~{o}es boleanas em Scala s\~{a}o similares as em Java; s\~{a}o formadas
a partir de constantes.  
\code{true} e
\code{false}, operadores de compara\c{c}\~{a}o, nega\c{c}\~{a}o boleana \code{!} e os 
operadores boleanos  $\,$\code{&&}$\,$ and $\,$\code{||}. 

\section{\label{sec:sqrt}Exemplo: Raiz Quadrada pelo M\'{e}todo de Newton}
Agora ilustraremos elementos da linguagem intruduzidos at\'{e} aqui na
constru\c{c}\~{a}o de um programa mais interessante. A tarefa \'{e} escrever um fun\c{c}\~{a}o  
 \begin{lstlisting}
 def sqrt(x: Double): Double = ...
 \end{lstlisting}
que computa a raiz quadrada de \code{x}. 

Um modo comum de se computar raizes quadradas \'{e} pelo m\'{e}todo das aproxima\c{c}\~{o}es
sucessivas de Newton. Inicia-se com um palpite inicial \code{y} (digamos:
\code{y = 1}). Ent\~{a}o melhora-se repetidamente o atual palpite \code{y} 
tomando-se a m\'{e}dia de \code{y} e \code{x/y}. Como um exemplo, as pr\'{o}ximas
tr\^{e}s colunas indicam o palpite \code{y}, o quociente \code{x/y}, e suas
m\'{e}dias para as primeiras aproxima\c{c}\~{o}es para 
$\sqrt 2$.       

\begin{lstlisting}
1            2/1 = 2               1.5
1.5          2/1.5 = 1.3333        1.4167
1.4167       2/1.4167 = 1.4118     1.4142
1.4142       ...                   ...

$y$            $x/y$                   $(y + x/y)/2$
\end{lstlisting}

Este algoritmo pode ser implementado em Scala por um conjunto de pequenas fun\c{c}\~{o}es,
onde cada uma representa um dos elementos do algoritmo.

Primeiro definimos uma fun\c{c}\~{a}o para iterar do palpite para o resultado:

\begin{lstlisting}
def sqrtIter(guess: Double, x: Double): Double =
  if (isGoodEnough(guess, x)) guess
  else sqrtIter(improve(guess, x), x)
\end{lstlisting}

Observe que \code{sqrtIter} chama a si mesmo recursivamente. La\c{c}os em 
programas imperativos podem sempre ser modelados por recurs\~{a}o em 
programas funcionais. 

Observe tamb\'{e}m que a defini\c{c}\~{a}o de \code{sqrtIter} cont\'{e}m um tipo retorno,
que segue o se\c{c}\~{a}o de par\^{a}metros. Tais tipos de retorno s\~{a}o mandat\'{o}rios para 
fun\c{c}\~{o}es recursivas. Para uma fun\c{c}\~{a}o n\~{a}o recursiva, o tipo de retorno \'{e} opcional;
se estiver faltando o verificador de tipos o computar\'{a} a partir do tipo do lado
direito da fun\c{c}\~{a}o. Entretanto, mesmo para fun\c{c}\~{o}es n\~{a}o recursivas \'{e} sempre boa id\'{e}ia 
incluir um tipo de retorno para melhor documenta\c{c}\~{a}o.  

Como segundo passo, definimos as duas fun\c{c}\~{o}es chamadas por:
\code{sqrtIter}: uma fun\c{c}\~{a}o para melhorar (\code{improve}) o palpite e um
teste de termina\c{c}\~{a}o \code{isGoodEnough}. Aqui est\~{a}o suas defini\c{c}\~{o}es.
\begin{lstlisting}
def improve(guess: Double, x: Double) =
  (guess + x / guess) / 2    

def isGoodEnough(guess: Double, x: Double) =
  abs(square(guess) - x) < 0.001
\end{lstlisting}

Finalmente, a pr\'{o}pria fun\c{c}\~{a}o \code{sqrt} \'{e} definida como uma aplica\c{c}\~{a}o de
\code{sqrtIter}.
  
\begin{lstlisting}
def sqrt(x: Double) = sqrtIter(1.0, x)
\end{lstlisting}

\begin{exercise} O teste \code{isGoodEnough} n\~{a}o \'{e} muito preciso para pequenos 
n\'{u}meros e podem levar a n\~{a}o termina\c{c}\~{a}o para n\'{u}meros muito grandes (por que?).
Crie uma vers\~{a}o diferente para \code{isGoodEnough} que n\~{a}o tenham esses problemas.
\end{exercise}

\begin{exercise} Simule a execu\c{c}\~{a}o da express\~{a}o \code{sqrt(4)}.
\end{exercise}

\section{Aninhamento de Fun\c{c}\~{o}es}

A programa\c{c}\~{a}o funcional encoraja a constru\c{c}\~{a}o de muitas pequenas fun\c{c}\~{o}es
auxiliares. Nos \'{u}ltimos exemplos, a implementa\c{c}\~{a}o de \code{sqrt} faz uso da
fun\c{c}\~{o}es auxiliares \code{sqrtIter}, \code{improve} e \code{isGoodEnough}.
Os nomes destas fun\c{c}\~{o}es s\~{a}o relevantes somente para a implementa\c{c}\~{a}o de 
\code{sqrt}. Normalmente n\~{a}o queremos que os usu\'{a}rios de \code{sqrt} acessem
estas fun\c{c}\~{o}es diretamente.  

N\'{o}s podemos refor\c{c}ar isto (e evitar polui\c{c}\~{a}o de nomes) incluindo
fun\c{c}\~{o}es auxiliares dentro das pr\'{o}prias fun\c{c}\~{o}es: 
\begin{lstlisting}
def sqrt(x: Double) = {
  def sqrtIter(guess: Double, x: Double): Double =
    if (isGoodEnough(guess, x)) guess
    else sqrtIter(improve(guess, x), x)
  def improve(guess: Double, x: Double) =
    (guess + x / guess) / 2
  def isGoodEnough(guess: Double, x: Double) =
    abs(square(guess) - x) < 0.001
  sqrtIter(1.0, x)
}
\end{lstlisting}

Neste programa, as chaves \code{\{ ... \}} envolvem um {\em bloco}. 
Blocos em Scala s\~{a}o eles mesmos express\~{o}es. Cada bloco termina com um
express\~{a}o resultado o qual define seu valor. A express\~{a}o  resultado pode 
ser precedida por defini\c{c}\~{o}es auxiliares, as quais s\~{a}o vis\'{i}veis somente no
pr\'{o}prio bloco. 

Cada defini\c{c}\~{a}o no bloco pode ser seguida para um ponto e v\'{i}rgula, o qual 
separa esta defini\c{c}\~{a}o das defini\c{c}\~{o}es subsequentes ou a express\~{a}o  resultado.
Entretanto, um ponto e v\'{i}rgula \'{e} inserido implicitamente ao final de cada linha,
a n\~{a}o ser que uma das condi\c{c}\~{o}es a seguir seja verdadeira.

\begin{enumerate}
\item 
Ou a linha em quest\~{a}o termina com uma palavra tal que um ponto ou um 
operador infixo n\~{a}o s\~{a}o legais ao final da express\~{a}o.
\item 
Ou a pr\'{o}xima linha inicia com uma palavra que n\~{a}o pode iniciar uma express\~{a}o.
\item
Ou estamos dentro de par\^{e}nteses \prog{$($...$)$} ou chaves \prog{}, porque 
estes n\~{a}o podem conter multiplos comandos de qualquer modo.
\end{enumerate}

Entretanto, os seguintes s\~{a}o legais:

\begin{lstlisting}
def f(x: Int) = x + 1;
f(1) + f(2)

def g1(x: Int) = x + 1
g(1) + g(2)

def g2(x: Int) = {x + 1};  /* `;' mandatorio */ g2(1) + g2(2)

def h1(x) = 
  x + 
  y
h1(1) * h1(2)

def h2(x: Int) = (
  x     // parenteses mandatorio, senao um ponto e virgula
  + y   // sera inserido apos o `x'.
)
h2(1) / h2(2)
\end{lstlisting}

Scala usa as regras usuais de escopo de bloco estruturado. Um nome definido em
algum outro bloco \'{e} tamb\'{e}m vis\'{i}vel em algum bloco interno, desde que n\~{a}o tenha
sido redefinido l\'{a}. Esta regra nos permite simplificar nosso exemplo \code{sqrt}.
N\~{a}o precisamos passar \code{x} como par\^{a}metro adicional de fun\c{c}\~{o}es aninhadas, dado
que est\'{a} sempre vis\'{i}vel nelas como um par\^{a}metro da fun\c{c}\~{a}o externa \code{sqrt}.
Aqui est\'{a} o c\'{o}digo simplificado:
   
\begin{lstlisting}
def sqrt(x: Double) = {
  def sqrtIter(guess: Double): Double =
    if (isGoodEnough(guess)) guess
    else sqrtIter(improve(guess))
  def improve(guess: Double) =
    (guess + x / guess) / 2
  def isGoodEnough(guess: Double) =
    abs(square(guess) - x) < 0.001
  sqrtIter(1.0)
}
\end{lstlisting}

\section{Recurs\~{a}o de Cauda}

Considere a seguinte fun\c{c}\~{a}o para calcular o maior divisor comum entre
dois n\'{u}meros dados.

\begin{lstlisting}
def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)
\end{lstlisting}

Usando nosso modelo de substitui\c{c}\~{a}o da fun\c{c}\~{a}o de avalia\c{c}\~{a}o,
\code{gcd(14, 21)} evaluates as follows:

\begin{lstlisting}
$\,\,$      gcd(14, 21)  
$\rightarrow\!$     if (21 == 0) 14 else gcd(21, 14 % 21)
$\rightarrow\!$     if (false) 14 else gcd(21, 14 % 21)
$\rightarrow\!$     gcd(21, 14 % 21)
$\rightarrow\!$     gcd(21, 14)
$\rightarrow\!$     if (14 == 0) 21 else gcd(14, 21 % 14)
$\rightarrow$ $\rightarrow$  gcd(14, 21 % 14)
$\rightarrow\!$     gcd(14, 7)
$\rightarrow\!$     if (7 == 0) 14 else gcd(7, 14 % 7)
$\rightarrow$ $\rightarrow$  gcd(7, 14 % 7)
$\rightarrow\!$     gcd(7, 0)
$\rightarrow\!$     if (0 == 0) 7 else gcd(0, 7 % 0)
$\rightarrow$ $\rightarrow$  7
\end{lstlisting}


Contraste isto com a avalia\c{c}\~{a}o de uma outra fun\c{c}\~{a}o recursiva,
\code{factorial}:

\begin{lstlisting}
def factorial(n: Int): Int = if (n == 0) 1 else n * factorial(n - 1)
\end{lstlisting}

A aplica\c{c}\~{a}o de \code{factorial(5)} \'{e} reescrita como segue: 

\begin{lstlisting}
$\,\,\,$       factorial(5)
$\rightarrow$      if (5 == 0) 1 else 5 * factorial(5 - 1)
$\rightarrow$      5 * factorial(5 - 1)
$\rightarrow$      5 * factorial(4)
$\rightarrow\ldots\rightarrow$  5 * (4 * factorial(3))
$\rightarrow\ldots\rightarrow$  5 * (4 * (3 * factorial(2)))
$\rightarrow\ldots\rightarrow$  5 * (4 * (3 * (2 * factorial(1))))
$\rightarrow\ldots\rightarrow$  5 * (4 * (3 * (2 * (1 * factorial(0))))
$\rightarrow\ldots\rightarrow$  5 * (4 * (3 * (2 * (1 * 1))))
$\rightarrow\ldots\rightarrow$  120
\end{lstlisting}

H\'{a} uma importante diferen\c{c}a entre as duas senten\c{c}as reescritas:
Os termos na sequ\^{e}ncia reescrita de \code{gcd} tem repetidamente a
mesma forma. Conforme a avalia\c{c}\~{a}o prossegue, seu tamanho \'{e} limitado por
uma constante. Diferentemente, na avalia\c{c}\~{a}o do fatorial obtemos cadeias
cada vez mais longas de operandos que s\~{a}o ent\~{a}o multiplicados na \'{u}ltima
parte da sequ\^{e}ncia de avalia\c{c}\~{a}o. 

Ainda que as atuais implementa\c{c}\~{o}es de Scala n\~{a}o trabalhem reescrevendo
termos, elas contudo devem ter o mesmo comportamento de espa\c{c}o que nas
sequ\^{e}ncias reescritas. Na implementa\c{c}\~{a}o de \code{gcd}, nota-se que  a 
chamada recursiva para \code{gcd} \'{e} a \'{u}ltima a\c{c}\~{a}o realizada na avalia\c{c}\~{a}o 
do seu corpo. Pode-se tamb\'{e}m dizer que \code{gcd} \'{e} uma recurs\~{a}o de cauda
(tail-recursive). A \'{u}ltima chamada numa fun\c{c}\~{a}o recursiva de cauda pode ser
implementada por um salto ao in\'{i}cio da fun\c{c}\~{a}o. Os argumentos dessa chamada 
pode sobrescrever os par\^{a}metros da atual instancia\c{c}\~{a}o de \code{gcd}, portanto 
nenhum espa\c{c}o na pilha \'{e} necess\'{a}rio. Consequentemente, fun\c{c}\~{o}es recursivas de 
cauda s\~{a}o processos iterativos, que podem ser executados em espa\c{c}o constante.     

Em contraste, a chamada recursiva em \code{factorial} \'{e} seguida por uma 
multiplica\c{c}\~{a}o. consequentemente, um novo espa\c{c}o na pilha \'{e} alocado para a 
inst\^{a}ncia recursiva de fatorial, e \'{e} desalocada ap\'{o}s o t\'{e}rmino daquela 
inst\^{a}ncia. A formula\c{c}\~{a}o dada para a fun\c{c}\~{a}o fatorial n\~{a}o \'{e} recursiva de cauda;
 precisa de espa\c{c}o proporcional aos seus par\^{a}metros de entrada para sua
execu\c{c}\~{a}o. 

Genericamente, se a \'{u}ltima a\c{c}\~{a}o da fun\c{c}\~{a}o \'{e} uma chamada a outra fun\c{c}\~{a}o
(possivelmente a mesma), apenas um \'{u}nico espa\c{c}o na pilha \'{e} requerido para 
ambas fun\c{c}\~{o}es. Tais chamadas s\~{a}o denominadas ``tail call''. Em 
princ\'{i}pio, tail calls sempre podem reutilizar o espa\c{c}o da pilha da fun\c{c}\~{a}o 
de chamada. Entretanto, alguns ambientes de execu\c{c}\~{a}o (tais como Java VM) 
carecem das primitivas para fazer um espa\c{c}o de pilha reutiliz\'{a}vel para 
tail calls eficientes. A produ\c{c}\~{a}o de uma implementa\c{c}\~{a}o Scala de qualidade \'{e},
portanto, requerida somente para reutilizar o espa\c{c}o de pilha de uma fun\c{c}\~{a}o 
recursiva de cauda cuja \'{u}ltima a\c{c}\~{a}o \'{e} chamar a si mesma. Outras chamadas de 
cauda podem ser otimizadas tamb\'{e}m, mas n\~{a}o deve-se confiar nisso ao longo das
implementa\c{c}\~{o}es. 

\begin{exercise} Escreva uma implementa\c{c}\~{a}o recursiva de cauda de 
\code{factorial}.
\end{exercise}

\chapter{\label{chap:first-class-funs}Fun\c{c}\~{o}es de Primeira Classe}
Uma fun\c{c}\~{a}o em Scala \'{e} um valor de primeira classe. Como qualquer outro valor, 
pode ser passado como um par\^{a}metro ou retornado como um resultado. Fun\c{c}\~{o}es que 
recebem outras fun\c{c}\~{o}es como par\^{a}metros ou as retornam como resultados s\~{a}o 
denominadas fun\c{c}\~{o}es de {\em alta ordem}. Este cap\'{i}tulo introduz fun\c{c}\~{o}es de alta ordem 
e mostra como elas fornecem um mecanismo flex\'{i}vel para a composi\c{c}\~{a}o de programas.

Como um exemplo de motiva\c{c}\~{a}o, considere as tr\^{e}s tarefas relacionadas a seguir:
\begin{enumerate}
\item

Escreva uma fun\c{c}\~{a}o que some todos os inteiros entre dois dados n\'{u}meros, \code{a} e \code{b}:  
\begin{lstlisting}
def sumInts(a: Int, b: Int): Int =
  if (a > b) 0 else a + sumInts(a + 1, b)
\end{lstlisting}

\item 

Escreva uma fun\c{c}\~{a}o para somar os quadrados de todos os inteiros entre dois dados n\'{u}meros, 
 \code{a} e \code{b}:

\begin{lstlisting}
def square(x: Int): Int = x * x
def sumSquares(a: Int, b: Int): Int =
  if (a > b) 0 else square(a) + sumSquares(a + 1, b)
\end{lstlisting}
\item
Escreva uma fun\c{c}\~{a}o para somar as pot\^{e}ncias $2^n$ de todos os $n$ inteiros entre
dois dados n\'{u}meros \code{a} e \code{b}:  

\begin{lstlisting}
def powerOfTwo(x: Int): Int = if (x == 0) 1 else 2 * powerOfTwo(x - 1)
def sumPowersOfTwo(a: Int, b: Int): Int =
  if (a > b) 0 else powerOfTwo(a) + sumPowersOfTwo(a + 1, b)
\end{lstlisting}
\end{enumerate}

Estas fun\c{c}\~{o}es s\~{a}o todas inst\^{a}ncias de \(\sum^b_a f(n)\) para diferentes valores de $x$.
Podemos obter o padr\~{a}o comum definindo uma fun\c{c}\~{a}o \code{sum}: 
\begin{lstlisting}
def sum(f: Int => Int, a: Int, b: Int): Int =
  if (a > b) 0 else f(a) + sum(f, a + 1, b)
\end{lstlisting}

O tipo \code{Int => Int} \'{e} o tipo de fun\c{c}\~{o}es que recebem argumentos do tipo
\code{Int} e retornam resultados do tipo \code{Int}. Ent\~{a}o \code{sum} \'{e} uma 
fun\c{c}\~{a}o que recebe uma outra fun\c{c}\~{a}o como par\^{a}metro. Em outras palavras, \code{sum}
\'{e} uma fun\c{c}\~{a}o de {\em alta ordem}.     

Usando \code{sum}, podemos formular as tr\^{e}s fun\c{c}\~{o}es de soma como segue: 
\begin{lstlisting}
def sumInts(a: Int, b: Int): Int = sum(id, a, b)
def sumSquares(a: Int, b: Int): Int = sum(square, a, b)
def sumPowersOfTwo(a: Int, b: Int): Int = sum(powerOfTwo, a, b)
\end{lstlisting}
onde 
\begin{lstlisting}
def id(x: Int): Int = x
def square(x: Int): Int = x * x
def powerOfTwo(x: Int): Int = if (x == 0) 1 else 2 * powerOfTwo(x - 1)
\end{lstlisting}

\section{Fun\c{c}\~{o}es An\^{o}nimas}
Parametriza\c{c}\~{a}o por fun\c{c}\~{o}es tende a criar v\'{a}rias pequenas fun\c{c}\~{o}es. No exemplo 
anterior, definimos \code{id}, \code{square} e \code{power} como fun\c{c}\~{o}es 
separadas, de tal modo que pudessem ser passadas como argumentos para \code{sum}.    


Ao inv\'{e}s de usarmos defini\c{c}\~{o}es de fun\c{c}\~{o}es nomeadas para estas pequenas fun\c{c}\~{o}es 
argumentos, podemos formul\'{a}-las de um modo abreviado como {\em fun\c{c}\~{o}es an\^{o}nimas}.
Uma fun\c{c}\~{a}o an\^{o}nima \'{e} uma express\~{a}o que \'{e} avaliada para uma fun\c{c}\~{a}o; a fun\c{c}\~{a}o \'{e} 
definida sem receber um nome. Como exemplo considere a fun\c{c}\~{a}o an\^{o}nima quadrado:
\begin{lstlisting}
  (x: Int) => x * x
\end{lstlisting}

A parte anterior a flecha `\code{=>}' s\~{a}o os par\^{a}metros da fun\c{c}\~{a}o, ao passo que a parte
seguinte a `\code{=>}' \'{e} o seu corpo.
Por exemplo, aqui est\'{a} uma fun\c{c}\~{a}o an\^{o}nima que multiplica seus dois argumentos.
\begin{lstlisting}
  (x: Int, y: Int) => x * y
\end{lstlisting}

Usando fun\c{c}\~{o}es an\^{o}nimas, podemos reformular as duas fun\c{c}\~{o}es soma sem
fun\c{c}\~{o}es auxiliares nomeadas:
\begin{lstlisting}
def sumInts(a: Int, b: Int): Int = sum((x: Int) => x, a, b)
def sumSquares(a: Int, b: Int): Int = sum((x: Int) => x * x, a, b)
\end{lstlisting}

Frequentemente, o compilador Scala pode deduzir o tipo do par\^{a}metro a partir
do contexto da fun\c{c}\~{a}o an\^{o}nima nos casos em que foram omitidos.
Por exemplo, no caso de \code{sumInts} ou \code{sumSquares}, sabe-se a partir do 
tipo de \code{sum} que o primeiro par\^{a}metro deve ser uma fun\c{c}\~{a}o de tipo \code{Int => Int}.
Consequentemente, o tipo do par\^{a}metro \code{Int} \'{e} redundante e pode ser omitido. Se
houver um \'{u}nico par\^{a}metro sem um tipo, tamb\'{e}m podemos omitir os par\^{a}metros a sua volta. 
   
\begin{lstlisting}
def sumInts(a: Int, b: Int): Int = sum(x => x, a, b)
def sumSquares(a: Int, b: Int): Int = sum(x => x * x, a, b)
\end{lstlisting}

Em geral, o termo em Scala 
 \code{(x}$_1$\code{: T}$_1$\code{, ..., x}$_n$\code{: T}$_n$\code{) => E} 
define uma fun\c{c}\~{a}o que mapeia seus par\^{a}metros \code{x}$_1$\code{, ..., x}$_n$
ao resultado da express\~{a}o \code{E} (onde \code{E} pode referir-se a   
\code{x}$_1$\code{, ..., x}$_n$). Fun\c{c}\~{o}es an\^{o}nimas n\~{a}o s\~{a}o elementos essenciais
da linguagem Scala, dado que sempre podem ser expressos em termos de fun\c{c}\~{o}es
nomeadas. De fato, a fun\c{c}\~{a}o an\^{o}nima 

\begin{lstlisting}
(x$_1$: T$_1$, ..., x$_n$: T$_n$) => E
\end{lstlisting}
\'{e} equivalente ao bloco
\begin{lstlisting}
{ def f (x$_1$: T$_1$, ..., x$_n$: T$_n$) = E ; f _ }
\end{lstlisting}
onde \code{f} \'{e} um novo nome que n\~{a}o \'{e} utilizado em qualquer outro lugar do programa.
Tamb\'{e}m dizemos que fun\c{c}\~{o}es an\^{o}nimas s\~{a}o ``syntactic sugar''. 

\section{Currying}

A \'{u}ltima formula\c{c}\~{a}o das fun\c{c}\~{o}es de soma j\'{a} s\~{a}o bem compactas. Mas 
podemos fazer ainda melhor. Observe que \code{a} e \code{b} aparecem como 
par\^{a}metros e argumentos de cada fun\c{c}\~{a}o, mas n\~{a}o parecem tomar parte de 
combina\c{c}\~{o}es interessantes. H\'{a} algum modo de nos livrarmos delas?

Vamos tentar reescrever \code{sum} de tal modo que n\~{a}o receba os limites
\code{a} e \code{b} como par\^{a}metros:     

\begin{lstlisting}
def sum(f: Int => Int): (Int, Int) => Int = {
  def sumF(a: Int, b: Int): Int =
    if (a > b) 0 else f(a) + sumF(a + 1, b)
  sumF
}
\end{lstlisting}

Nessa formula\c{c}\~{a}o, \code{sum} \'{e} uma fun\c{c}\~{a}o que retorna uma outra fun\c{c}\~{a}o, especificamente
a fun\c{c}\~{a}o especializada soma \code{sumF}. Esta \'{u}ltima fun\c{c}\~{a}o realiza todo o trabalho; 
recebe os limites \code{a} e \code{b} como par\^{a}metros, aplica a fun\c{c}\~{a}o \code{f}, par\^{a}metro
de \code{sum}, a todos os inteiros entre eles, e soma os resultados.
      
Usando esta nova formula\c{c}\~{a}o de \code{sum}, podemos agora definir:
\begin{lstlisting}
def sumInts  =  sum(x => x)
def sumSquares  =  sum(x => x * x)
def sumPowersOfTwo  =  sum(powerOfTwo)
\end{lstlisting}
Ou, equivalentemente, com defini\c{c}\~{o}es de valores:
\begin{lstlisting}
val sumInts  =  sum(x => x)
val sumSquares  =  sum(x => x * x)
val sumPowersOfTwo  =  sum(powerOfTwo)
\end{lstlisting}

\code{sumInts}, \code{sumSquares}, e \code{sumPowersOfTwo} podem ser
aplicados como qualquer outra fun\c{c}\~{a}o. Por exemplo,
\begin{lstlisting}
scala> sumSquares(1, 10) + sumPowersOfTwo(10, 20)
unnamed0: Int = 2096513
\end{lstlisting}

Como fun\c{c}\~{o}es que retornam fun\c{c}\~{o}es s\~{a}o aplicadas? Como exemplo, na express\~{a}o 
\begin{lstlisting}
sum(x => x * x)(1, 10) ,
\end{lstlisting}
a fun\c{c}\~{a}o \code{sum} \'{e} aplicada a fun\c{c}\~{a}o quadrada \code{(x => x * x)}. 
O fun\c{c}\~{a}o resultante \'{e} ent\~{a}o aplicada ao segunda lista de argumentos, \code{(1, 10)}.   

Essa nota\c{c}\~{a}o \'{e} poss\'{i}vel porque aplica\c{c}\~{o}es de fun\c{c}\~{o}es s\~{a}o associativas à esquerda.
Ou seja, se $\mbox{args}_1$ e $\mbox{args}_2$ s\~{a}o listas de argumentos, ent\~{a}o 
\bda{lcl}
f(\mbox{args}_1)(\mbox{args}_2) & \ \ \mbox{\'{e} equivalente a}\ \ & (f(\mbox{args}_1))(\mbox{args}_2)
\eda
Em nosso exemplo, \code{sum(x => x * x)(1, 10)} \'{e} equivalente a seguinte express\~{a}o:
\code{(sum(x => x * x))(1, 10)}.

O estilo ``fun\c{c}\~{o}es que retornam fun\c{c}\~{o}es'' \'{e} t\~{a}o \'{u}til que Scala tem sintaxe
especial para ele. Por exemplo, a pr\'{o}xima defini\c{c}\~{a}o de \code{sum} \'{e} equivalente
a anterior, por\'{e}m mais curta: 
\begin{lstlisting}
def sum(f: Int => Int)(a: Int, b: Int): Int =
  if (a > b) 0 else f(a) + sum(f)(a + 1, b)
\end{lstlisting}

Genericamente, uma defini\c{c}\~{a}o de fun\c{c}\~{a}o currificada
\begin{lstlisting}
def f (args$_1$) ... (args$_n$) = E
\end{lstlisting}

onde $n > 1$ expande para 
\begin{lstlisting}
def f (args$_1$) ... (args$_{n-1}$) = { def g (args$_n$) = E ; g }
\end{lstlisting}
onde \code{g} \'{e} um novo identificador. Ou, menor, usando uma fun\c{c}\~{a}o an\^{o}nima: 
\begin{lstlisting}
def f (args$_1$) ... (args$_{n-1}$) = ( args$_n$ ) => E .
\end{lstlisting}
Realizando este passo $n$ vezes d\'{a} aquela 
\begin{lstlisting}
def f (args$_1$) ... (args$_n$) = E
\end{lstlisting}
\'{e} equivalente a 
\begin{lstlisting}
def f = (args$_1$) => ... => (args$_n$) => E .
\end{lstlisting}
Ou, equivalentemente, usando uma defini\c{c}\~{a}o valor:
\begin{lstlisting}
val f = (args$_1$) => ... => (args$_n$) => E .
\end{lstlisting}
Este estilo de defini\c{c}\~{a}o de fun\c{c}\~{a}o e aplica\c{c}\~{a}o \'{e} chamado {\em currificado}
depois que seu divulgador, Haskell B.\ Curry, um l\'{o}gico do s\'{e}culo $20$, mesmo 
que a id\'{e}ia nos leve de volta a Moses Sch\"onfinkel e Gottlob Frege.

O tipo de uma fun\c{c}\~{a}o que retorna fun\c{c}\~{a}o \'{e} expresso de modo an\'{a}logo a sua lista
de par\^{a}metros. Tomando a \'{u}ltima formula\c{c}\~{a}o de \code{sum} como exemplo, o tipo 
para \code{sum} \'{e} \code{(Int => Int) => (Int, Int) => Int}.
Isso \'{e} poss\'{i}vel porque tipos de fun\c{c}\~{o}es s\~{a}o associativos à direita. Ou seja, 
\begin{lstlisting}
T$_1$ => T$_2$ => T$_3$       $\mbox{is equivalent to}$     T$_1$ => (T$_2$ => T$_3$)
\end{lstlisting}
\begin{exercise}
1. A fun\c{c}\~{a}o \code{sum} usa uma recursiva linear. Voc\^{e} poderia alter\'{a}-la
para uma fun\c{c}\~{a}o recursiva de cauda, preenchendo as lacunas marcadas com '??' abaixo?  
\begin{lstlisting}
def sum(f: Int => Int)(a: Int, b: Int): Int = {
  def iter(a: Int, result: Int): Int = {
    if (??) ??
    else iter(??, ??)
  }
  iter(??, ??)
}
\end{lstlisting}
\end{exercise}

\begin{exercise}
Escreva uma fun\c{c}\~{a}o \code{produto} que computa o produto de valores de
fun\c{c}\~{o}es em pontos sobre um dado intervalo.  
\end{exercise}

\begin{exercise}
Escreva \code{fatorial} em termos de \code{produto}.  
\end{exercise}

\begin{exercise}
Escreva uma fun\c{c}\~{a}o ainda mais gen\'{e}rica que generaliza ambos \code{sum} e \code{produto}.  
\end{exercise}

\section{Exemplo: Encontrando Pontos Fixos de Fun\c{c}\~{o}es}

Um n\'{u}mero \code{x} \'{e} chamado um {\em ponto fixo} de uma fun\c{c}\~{a}o \code{f} se  
\begin{lstlisting}
f(x) = x .
\end{lstlisting}

Para algumas fun\c{c}\~{o}es \code{f} podemos encontrar os pontos fixos iniciando
com um palpite inicial e ent\~{a}o aplicando \code{f} repetidamente, at\'{e} que o valor 
n\~{a}o mude mais (ou a mudan\c{c}a seja toler\'{a}vel). Isso \'{e} poss\'{i}vel na sequ\^{e}ncia  
\begin{lstlisting}
x, f(x), f(f(x)), f(f(f(x))), ...
\end{lstlisting}
converge para pontos fixos de $f$. Essa id\'{e}ia \'{e} captada na ``fun\c{c}\~{a}o achadora 
de pontos fixos'' a seguir:
\begin{lstlisting}
val tolerance = 0.0001
def isCloseEnough(x: Double, y: Double) = abs((x - y) / x) < tolerance
def fixedPoint(f: Double => Double)(firstGuess: Double) = {
  def iterate(guess: Double): Double = {
    val next = f(guess)
    if (isCloseEnough(guess, next)) next
    else iterate(next)
  }
  iterate(firstGuess)
}
\end{lstlisting}

Agora aplicaremos esta id\'{e}ia na reformula\c{c}\~{a}o da fun\c{c}\~{a}o raiz quadrada.
Vamos come\c{c}ar pela especifica\c{c}\~{a}o de \code{sqrt}:  
\begin{lstlisting}
sqrt(x)  =  $\mbox{the {\sl y} such that}$  y * y = x
         =  $\mbox{the {\sl y} such that}$  y = x / y
\end{lstlisting}

Consequentemente, \code{sqrt(x)} \'{e} um ponto fixo da fun\c{c}\~{a}o \code{y => x / y}.
Isso sugere que \code{sqrt(x)} pode ser computado por uma itera\c{c}\~{a}o de ponto fixo: 
\begin{lstlisting}
def sqrt(x: double) = fixedPoint(y => x / y)(1.0)
\end{lstlisting}
Mas se tentarmos isso, percebemos que aquela computa\c{c}\~{a}o n\~{a}o converge. 
Vamos agregar à fun\c{c}\~{a}o de ponto fixo um comando print que mostra o 
valor corrente de \code{guess}: 
\begin{lstlisting}
def fixedPoint(f: Double => Double)(firstGuess: Double) = {
  def iterate(guess: Double): Double = {
    val next = f(guess)
    println(next)
    if (isCloseEnough(guess, next)) next
    else iterate(next)
  }
  iterate(firstGuess)
}
\end{lstlisting}
%% Then, \code{sqrt(2)} yields:
Ent\~{a}o, \code{sqrt(2)} d\'{a}: 
\begin{lstlisting}
  2.0
  1.0
  2.0
  1.0
  2.0
  ...
\end{lstlisting}

Um modo de controlar tais oscila\c{c}\~{o}es \'{e} prevenir guess de mudar muito.
Isso pode ser obtido pela m\'{e}dia (fun\c{c}\~{a}o {\em averaging}) de sucessivos valores da sequ\^{e}ncia 
original:
\begin{lstlisting}
scala> def sqrt(x: Double) = fixedPoint(y => (y + x/y) / 2)(1.0)
sqrt: (Double)Double

scala> sqrt(2.0)
  1.5
  1.4166666666666665
  1.4142156862745097
  1.4142135623746899
  1.4142135623746899
\end{lstlisting}
%% In fact, expanding the \code{fixedPoint} function yields exactly our 
%% previous definition of fixed point from Section~\ref{sec:sqrt}.
De fato, expandindo a fun\c{c}\~{a}o \code{fixedPoint} d\'{a} exatamente nossa pr\'{e}via
defini\c{c}\~{a}o de ponto fixo da Se\c{c}\~{a}o~\ref{sec:sqrt}.

Os exemplos anteriores mostraram que o poder de expressividade de uma linguagem 
\'{e} consideravelmente aumentado se fun\c{c}\~{o}es puderem ser passadas como argumentos.
O pr\'{o}ximo exemplo mostra que fun\c{c}\~{o}es que retornam fun\c{c}\~{o}es tamb\'{e}m podem ser
muito \'{u}teis.

Considere novamente itera\c{c}\~{o}es de ponto fixo. Come\c{c}amos observando que 
$\sqrt(x)$ \'{e} um ponto fixo da fun\c{c}\~{a}o \code{y => x / y}. Ent\~{a}o fazemos
a itera\c{c}\~{a}o convergir tirando a m\'{e}dia de sucessivos valores. Essa t\'{e}cnica
de {\em amortecimento da m\'{e}dia} \'{e} t\~{a}o gen\'{e}rica que pode ser denotada
em outra fun\c{c}\~{a}o.
\begin{lstlisting}
def averageDamp(f: Double => Double)(x: Double) = (x + f(x)) / 2
\end{lstlisting}

Usando \code{averageDamp}, podemos reformular a fun\c{c}\~{a}o da raiz quadrada
como segue. 
\begin{lstlisting}
def sqrt(x: Double) = fixedPoint(averageDamp(y => x/y))(1.0)
\end{lstlisting}

Isto expressa os elementos do algoritmo t\~{a}o claramente quanto poss\'{i}vel.
\begin{exercise} 
Escreva uma fun\c{c}\~{a}o para a raiz c\'{u}bica usando \code{fixedPoint} e \code{averageDamp}.  
\end{exercise}

\section{Sumário}

Vimos no cap\'{i}tulo anterior que fun\c{c}\~{o}es s\~{a}o abstra\c{c}\~{o}es essenciais porque 
nos permitem introduzir m\'{e}todos gen\'{e}ricos de computa\c{c}\~{a}o como expl\'{i}citos,
elementos nomeados em nossa linguagem de programa\c{c}\~{a}o. O presente cap\'{i}tulo
mostrou que tais abstra\c{c}\~{o}es podem ser combinados por fun\c{c}\~{o}es de alta ordem
para criar mais abstra\c{c}\~{o}es. Como programadores, devemos procurar por oportunidades 
de reuso e abstra\c{c}\~{a}o. O mais alto n\'{i}vel poss\'{i}vel de abstra\c{c}\~{a}o nem sempre \'{e} 
o melhor, mas \'{e} importante saber t\'{e}cnicas de abstra\c{c}\~{a}o, de modo que possamos
us\'{a}-las quando apropriado. 

\section{Elementos da Linguagem Vistos At\'{e} Aqui}

 Os cap\'{i}tulos ~\ref{chap:simple-funs} e \ref{chap:first-class-funs} trataram
elementos da linguagem Scala para expressar tipos e express\~{o}es relacionados a
tipos primitivos e fun\c{c}\~{o}es. A sintaxe livre de contexto desses elementos da
linguagem s\~{a}o dados abaixo em formato Backus-Naur estendido, onde `\code{|}'
denotam alternativas, \code{[...]} denotam op\c{c}\~{a}o  (0 ou 1 ocorr\^{e}ncia), e  
\lstinline@{...}@ denotam (0 ou mais ocorr\^{e}ncias). 
\subsection*{Caracteres}
Programas em Scala s\~{a}o sequ\^{e}ncia de caracteres (Unicode). Distinguimos os
seguintes conjuntos de caracteres.
 \begin{itemize}
 \item
espa\c{c}o em branco, tal como `\code{ }', tabula\c{c}\~{a}o, ou caracter de mudan\c{c}a de linha (newline), 
 \item
letras `\code{a}' a `\code{z}', `\code{A}' a `\code{Z}',    
 \item
digitos `\code{0}' a `\code{9}',   
 \item
caracteres delimitadores
 \begin{lstlisting}
 .    ,    ;    (    )    {    }    [    ]    \    $\mbox{\tt "}$    '
 \end{lstlisting}
 \item
caracteres operadores, tal como `\code{#}', `\code{+}' e `\code{:}'.
Essencialmente, h\'{a} caracteres imprim\'{i}veis que n\~{a}o est\~{a}o em nenhum dos 
conjuntos de caracteres acima.   
 \end{itemize}

\subsection*{Lexemas:}

\begin{lstlisting}
ident    =  letter {letter | digit}
         |  operator { operator }
         |  ident '_' ident
literal  =  $\mbox{``como em Java''}$
\end{lstlisting}

Literais s\~{a}o como em Java. Eles definem n\'{u}meros, caracteres, cadeias de caracteres, ou 
valores boleanos. Exemplos de literais tais como \code{0}, \code{1.0e10}, \code{'x'},
\code{"ele disse \"oi!\""}, ou \code{true}.

Identificadores podem ter duas formas. Eles ou iniciam por uma letra, que \'{e} 
seguida por uma sequ\^{e}ncia (possivelmente vazia) de letras ou s\'{i}mbolos, ou podem 
iniciar com um caracter operador, seguido por uma sequ\^{e}ncia (possivelmente vazia) de
caracteres operadores. Ambas as formas podem conter caracteres ``underscore'' `\code{_}'.
Al\'{e}m disso, um caracter underscore pode ser seguido por quaisquer identificadores.
Consequentemente, todos a seguir s\~{a}o identificadores legais:  
 \begin{lstlisting}
 x     Room10a     +     --     foldl_:     +_vector
 \end{lstlisting}

Segue desta regra que identificadores operadores subsequentes precisam ser
separados por espa\c{c}o em branco. Por exemplo, a entrada \code{x+-y} \'{e} entendida 
como a sequ\^{e}ncia de tr\^{e}s ``tokens'' \code{x}, \code{+-} e \code{y}. Se
desejamos expressar a soma de \code{x} com o valor negativo de \code{y}, 
precisamos acrescentar no m\'{i}nimo um espa\c{c}o, ou seja, \code{x+ -y}.      

O caracter \verb@$@ \'{e} reservado para identificadores gerados
pelo compilador; n\~{a}o devem ser usados em programas fontes. %$ 

Os seguintes s\~{a}o palavras reservadas, e n\~{a}o devem ser usadas como identificadores:
\begin{lstlisting}
abstract    case        catch       class       def    
do          else        extends     false       final    
finally     for         if          implicit    import      
match       new         null        object      override    
package     private     protected   requires    return      
sealed      super       this        throw       trait
try         true        type        val         var         
while       with        yield
_    :    =    =>    <-    <:    <%     >:    #    @
\end{lstlisting}

\subsection*{Types:}

\begin{lstlisting}
Type          =  SimpleType | FunctionType
FunctionType  =  SimpleType '=>' Type | '(' [Types] ')' '=>' Type
SimpleType    =  Byte | Short | Char | Int | Long | Float | Double |
                 Boolean | Unit | String
Types         =  Type {`,' Type}
\end{lstlisting}

Tipos podem ser:
 \begin{itemize}
 \item tipos num\'{e}ricos \code{Byte}, \code{Short}, \code{Char}, \code{Int}, \code{Long}, \code{Float} and \code{Double} (com em Java),
 \item o tipo \code{Boolean} com valores  \code{true} e \code{false},
 \item o tipo \code{Unit} com o \'{u}nico valor  \lstinline@()@,
 \item o tipo \code{String},
 \item tipos fun\c{c}\~{a}o, tal como  \code{(Int, Int) => Int} ou \code{String => Int => String}.
 \end{itemize}

\subsection*{Express\~{o}es:}
\begin{lstlisting}
Expr         = InfixExpr | FunctionExpr | if '(' Expr ')' Expr else Expr
InfixExpr    = PrefixExpr | InfixExpr Operator InfixExpr
Operator     = ident
PrefixExpr   = ['+' | '-' | '!' | '~' ] SimpleExpr
SimpleExpr   = ident | literal | SimpleExpr '.' ident | Block
FunctionExpr = (Bindings | Id) '=>' Expr
Bindings     = `(' Binding {`,' Binding} `)'
Binding      = ident [':' Type]
Block        = '{' {Def ';'} Expr '}'
\end{lstlisting}

Express\~{o}es podem ser:
 \begin{itemize}
 \item
identificadores tais como \code{x}, \code{isGoodEnough}, \code{*}, ou \code{+-},
 \item
literais, tais como \code{0}, \code{1.0}, ou \code{"abc"},
 \item
Sele\c{c}\~{o}es de campo e m\'{e}todo, tal como \code{System.out.println},
 \item
aplica\c{c}\~{o}es de fun\c{c}\~{a}o, tal como \code{sqrt(x)},
 \item
aplica\c{c}\~{o}es de operador, tais como \code{-x} ou \code{y + x},
 \item
condicionais, tal como \code{if (x < 0) -x else x},
 \item
blocos, tal como \lstinline@{ val x = abs(y) ; x * 2 }@,
 \item
fun\c{c}\~{o}es an\^{o}nimas, tais como \code{x => x + 1} ou \code{(x: Int, y: Int) => x + y}.
 \end{itemize}

\subsection*{Defini\c{c}\~{o}es:}
\begin{lstlisting}
Def          =  FunDef  |  ValDef
FunDef       =  'def' ident {'(' [Parameters] ')'} [':' Type] '=' Expr
ValDef       =  'val' ident [':' Type] '=' Expr
Parameters   =  Parameter {',' Parameter}
Parameter    =  ident ':' ['=>'] Type
\end{lstlisting}
Defini\c{c}\~{o}es podem ser:
\begin{itemize}
\item
defini\c{c}\~{o}es de fun\c{c}\~{a}o tal como \code{def square(x: Int): Int = x * x},
\item
defini\c{c}\~{o}es de valor tal como \code{val y = square(2)}.
\end{itemize}

\chapter{Classes e Objetos}
\label{chap:classes}

Scala n\~{a}o tem um tipo primitivo para n\'{u}meros racionais, mas \'{e} f\'{a}cil 
definir um, usando uma classe. Aqui est\'{a} uma poss\'{i}vel implementa\c{c}\~{a}o.

\begin{lstlisting}
class Rational(n: Int, d: Int) {
  private def gcd(x: Int, y: Int): Int = {
    if (x == 0) y
    else if (x < 0) gcd(-x, y)
    else if (y < 0) -gcd(x, -y)
    else gcd(y % x, x)
  }
  private val g = gcd(n, d)

  val numer: Int = n/g
  val denom: Int = d/g
  def +(that: Rational) =
    new Rational(numer * that.denom + that.numer * denom,
                 denom * that.denom)
  def -(that: Rational) =
    new Rational(numer * that.denom - that.numer * denom, 
                 denom * that.denom)
  def *(that: Rational) =
    new Rational(numer * that.numer, denom * that.denom)
  def /(that: Rational) =
    new Rational(numer * that.denom, denom * that.numer)
}
\end{lstlisting}

Isso define \code{Rational} como uma classe que recebe dois argumentos 
construtores \code{n} e \code{d}, contendo as partes num\'{e}ricas do numerador
e denominador. A classe prov\^{e} campos que retornam estas partes, bem como
m\'{e}todos para a aritm\'{e}tica sobre n\'{u}meros racionais. Cada m\'{e}todo aritm\'{e}tico 
recebe como par\^{a}metro o operando direito da opera\c{c}\~{a}o. O operando esquerdo
da opera\c{c}\~{a}o sempre \'{e} o n\'{u}mero racional do m\'{e}todo cujo \'{e} membro.   

\paragraph{Membros Privados}
A implementa\c{c}\~{a}o dos n\'{u}meros racionais define um m\'{e}todo privado \code{gcd} que 
computa o maior denominador comum de dois inteiros, bem como um campo
privado \code{g} que cont\'{e}m o \code{gcd} dos argumentos construtores. Esses
membros s\~{a}o inacess\'{i}veis de fora da classe \code{Rational}. S\~{a}o usados na 
implementa\c{c}\~{a}o da classe para eliminar fatores comuns nos argumentos construtores
para garantir que o numerador e o denominador estejam sempre em forma normalizada.    

\paragraph{Criando e Acessando Objetos}
Como um exemplo de como os n\'{u}meros racionais podem ser usados, aqui est\'{a} um programa 
que imprime a soma de todos os n\'{u}meros $1/i$ onde $i$ est\'{a} no intervalo de 1 a 10. 
\begin{lstlisting}
var i = 1
var x = new Rational(0, 1)
while (i <= 10) {
  x += new Rational(1, i)
  i += 1
}
println("" + x.numer + "/" + x.denom)
\end{lstlisting}

O \code{+} recebe como operando esquerdo uma cadeia de caracteres e como 
operando direito um valor de tipo arbitr\'{a}rio. Retorna o resultado de 
converter seu operando direito em uma cadeia de caracteres e concaten\'{a}-la 
a seu operando esquerdo.   

\paragraph{Heran\c{c}a e Sobrecarga}
Cada classe em Scala tem uma superclasse que ela estende.
\comment{A exce\c{c}\~{a}o \'{e} a classe \code{Object}, que n\~{a}o possui superclasse, e
que \'{e} indiretamente estendida para cada outra classe.}
Se uma classe n\~{a}o menciona sua superclasse em sua defini\c{c}\~{a}o, o tipo b\'{a}sico 
\code{scala.AnyRef} \'{e} implicitamente assumido (para implementa\c{c}\~{o}es Java, este
tipo \'{e} um apelido (alias) para \code{java.lang.Object}. Por exemplo, a classe 
\code{Rational} pode ser equivalentemente definida como      
\begin{lstlisting}
class Rational(n: Int, d: Int) extends AnyRef {
  ... // como antes
}
\end{lstlisting}

Uma classe herda todos os membros de sua superclasse. Pode tamb\'{e}m redefinir
(ou: {\em sobrescrever}) alguns membros herdados. Por exemplo, a classe 
\code{java.lang.Object} define um m\'{e}todo \code{toString} que retorna uma 
representa\c{c}\~{a}o do objeto como cadeia de caracteres (string): 
\begin{lstlisting}
class Object {
  ...
  def toString: String = ...
}
\end{lstlisting}

A implementa\c{c}\~{a}o de \code{toString} em \code{Object} forma uma string que 
consiste do nome da classe do objeto e um n\'{u}mero. Faz sentido redefinir este
m\'{e}todo para objetos que s\~{a}o n\'{u}meros racionais:  
\begin{lstlisting}
class Rational(n: Int, d: Int) extends AnyRef {
  ... // como antes
  override def toString = "" + numer + "/" + denom
}
\end{lstlisting}

Observe que, diferentemente de Java, defini\c{c}\~{o}es que redefinem precisam
ser precedidas por um modificador \code{override}.  

Se a classe $A$ estende a classe $B$, ent\~{a}o objetos do tipo $A$ podem ser
usados sempre que objetos do tipo $B$ s\~{a}o esperados. Nesse caso dizemos que o 
tipo $A$ est\'{a} em {\em conformidade} com o tipo $B$. Por exemplo, \code{Rational}
est\'{a} em conformidade com \code{AnyRef}, logo \'{e} legal atribuir um valor \code{Rational}
à vari\'{a}vel do tipo \code{AnyRef}:
 
\begin{lstlisting}
 var x: AnyRef = new Rational(1, 2)
\end{lstlisting}

\paragraph{M\'{e}todos sem Par\^{a}metros}

\begin{lstlisting}
val r = new Rational(1,2)
System.out.println(r.toString);      // imprime ``1/2''
\end{lstlisting}

Distintamente de Java, m\'{e}todos em Scala n\~{a}o necessariamente precisam 
receber uma lista de par\^{a}metros. Um exemplo \'{e} o m\'{e}todo abaixo \code{square}.
Este m\'{e}todo \'{e} invocado simplesmente mencionando seu nome. 
\begin{lstlisting}
class Rational(n: Int, d: Int) extends AnyRef {
  ... // como antes
  def square = new Rational(numer*numer, denom*denom)
}
val r = new Rational(3, 4)
println(r.square)           // imprime ``9/16''*
\end{lstlisting}

Ou seja, m\'{e}todos sem par\^{a}metros s\~{a}o acessados como campos valor, tais como 
\code{numer} s\~{a}o. A diferen\c{c}a entre valores e m\'{e}todos sem par\^{a}metros 
reside em suas defini\c{c}\~{o}es. O lado direito de um valor \'{e} avaliado quando o 
objeto \'{e} criado, e o valor n\~{a}o muda depois. Um lado direito de um m\'{e}todo sem
par\^{a}metros, por outro lado, \'{e} avaliado cada vez que o m\'{e}todo \'{e} chamado. O 
acesso uniforme dos campos de m\'{e}todos sem par\^{a}metros resulta em crescente
flexibilidade para o implementador de uma classe. Frequentemente, um campo
em uma vers\~{a}o da classe torna-se um valor computado na pr\'{o}xima vers\~{a}o. 
O acesso uniforme garante que clientes n\~{a}o tenham de ser reescritos 
por conta desta mudan\c{c}a.

\paragraph{Classes Abstratas}

Considere a tarefa de escrever uma classe para conjuntos de n\'{u}meros inteiros com 
duas opera\c{c}\~{o}es, \code{incl} e \code{contains}. \code{(s incl x)} deve retornar
um novo conjunto que cont\'{e}m o elemento \code{x} juntamente com todos os elementos 
do conjunto \code{s}. \code{(s contains x)} deve retornar \code{true} se o conjunto 
\code{s} contiver o elemento \code{x}, e deve retornar \code{false}, caso contr\'{a}rio.
A interface para tais conjuntos \'{e} dada por:
\begin{lstlisting}
abstract class IntSet {
  def incl(x: Int): IntSet
  def contains(x: Int): Boolean
}
\end{lstlisting}

\code{IntSet} \'{e} tido como uma {\em classe abstrata}. Isso tem duas consequ\^{e}ncias. 
Primeiro, classes abstratas podem ter membros {\em protelados (deferred)} que s\~{a}o 
declarados, mas que n\~{a}o tem uma implementa\c{c}\~{a}o. No nosso caso, ambos \code{incl} e 
\code{contains} s\~{a}o tais membros. Segundo, porque uma classe abstrata pode ter 
membros n\~{a}o implementados, nenhum objeto daquela classe pode ser criado usando \code{new}.
Em contraste, uma classe abstrata pode ser usada como uma classe base de alguma outra
classe, que implementa os membros que foram postergados. 

\paragraph{Traits}

Ao inv\'{e}s de \code{classe abstrata} frequentemente usa-se a palavra chave
\code{trait} em Scala. Traits s\~{a}o classes abstratas que desejamos adicionar
a alguma outra classe. Isso pode ser porque um trait adiciona alguns m\'{e}todos
ou campos para uma classe pai desconhecida. Por exemplo, um trait \code{Bordered} 
pode ser usado para adicionar uma borda a v\'{a}rios componentes gr\'{a}ficos. Um outro
cen\'{a}rio de uso ocorre quando o trait coleta assinaturas de alguma funcionalidade 
provida por diferentes classes, do mesmo modo que uma interface Java faria.

Como \code{IntSet} pertence a esta categoria, pode-se alternativamente 
defin\'{i}-la como um trait:
\begin{lstlisting}
trait IntSet {
  def incl(x: Int): IntSet
  def contains(x: Int): Boolean
}
\end{lstlisting}

\paragraph{Implementando Classes Abstratas}

Vamos dizer que planejamos implementar conjuntos como \'{a}rvores bin\'{a}rias. H\'{a} 
duas poss\'{i}veis formas de \'{a}rvores. Uma \'{a}rvore para o conjunto vazio, e uma 
\'{a}rvore consistindo de um inteiro e duas sub\'{a}rvores. Aqui est\~{a}o suas implementa\c{c}\~{o}es:
 
\begin{lstlisting}
class EmptySet extends IntSet {
  def contains(x: Int): Boolean = false
  def incl(x: Int): IntSet = new NonEmptySet(x, new EmptySet, new EmptySet)
}
\end{lstlisting}

\begin{lstlisting}
class NonEmptySet(elem: Int, left: IntSet, right: IntSet) extends IntSet {
  def contains(x: Int): Boolean =
    if (x < elem) left contains x
    else if (x > elem) right contains x
    else true
  def incl(x: Int): IntSet =
    if (x < elem) new NonEmptySet(elem, left incl x, right)
    else if (x > elem) new NonEmptySet(elem, left, right incl x)
    else this
}
\end{lstlisting}
Ambos \code{EmptySet} e \code{NonEmptySet} estendem a classe \code{IntSet}. Isso implica
que tipos \code{EmptySet} e \code{NonEmptySet} est\~{a}o em conformidade com o tipo \code{IntSet} -- 
um valor do tipo \code{EmptySet} ou \code{NonEmptySet} pode ser usado sempre que um valor 
 do tipo \code{IntSet} \'{e} requerido.

\begin{exercise}
Escreva os m\'{e}todos \code{uniao} e \code{intersecao} para formar a uni\~{a}o e interse\c{c}\~{a}o entre
dois conjuntos.
\end{exercise}
 \begin{exercise} Adicione um m\'{e}todo  
 \begin{lstlisting}
 def excl(x: Int)
 \end{lstlisting}

para retornar um dado conjunto sem o elemento \code{x}. Para isso, \'{e} interessante tamb\'{e}m 
implementar um m\'{e}todo teste
 \begin{lstlisting}
 def isEmpty: Boolean
 \end{lstlisting}
para conjuntos.
 \end{exercise}

\paragraph{Liga\c{c}\~{a}o Din\^{a}mica}
Linguagens orientadas a objetos (inclusive Scala) usam \emph{despacho din\^{a}mico} para 
invoca\c{c}\~{o}es de m\'{e}todos. Ou seja, o c\'{o}digo invocado por uma chamada de m\'{e}todo depende
do tipo em tempo de execu\c{c}\~{a}o do objeto que cont\'{e}m o m\'{e}todo. Por exemplo, considere
a express\~{a}o \code{s contains 7} onde \code{s} \'{e} um valor do tipo declarado \code{s: IntSet}. 
Qual c\'{o}digo para \code{contains} \'{e} executado depende do tipo do valor de \code{s} em 
tempo de execu\c{c}\~{a}o. Se for um valor \code{EmptySet}, \'{e} a implementa\c{c}\~{a}o de \code{contains} na 
classe \code{EmptySet} que \'{e} executada, e analogamente para valores \code{NonEmptySet}.
Este comportamento \'{e} consequ\^{e}ncia direta do nosso modelo de substitui\c{c}\~{a}o da avalia\c{c}\~{a}o.
Por exemplo, 
\begin{lstlisting}
    (new EmptySet).contains(7) 

->  $\rewriteby{substituindo {\sl contains} pelo seu corpo na classe {\sl EmptySet}}$

    false
\end{lstlisting}
Ou,
\begin{lstlisting}
    new NonEmptySet(7, new EmptySet, new EmptySet).contains(1)

->  $\rewriteby{substituindo {\sl contains} pelo seu corpo na classe {\sl NonEmptySet}}$

    if (1 < 7) new EmptySet contains 1
    else if (1 > 7) new EmptySet contains 1
    else true

->  $\rewriteby{reescrevendo o condicional}$

    new EmptySet contains 1

->  $\rewriteby{substituindo {\sl contains} pelo seu corpo na classe {\sl EmptySet}}$

    false .
\end{lstlisting}

Envio din\^{a}mico de m\'{e}todos \'{e} an\'{a}logo a chamadas para fun\c{c}\~{o}es de alta ordem. 
Em ambos os casos, a identidade do c\'{o}digo  a ser executado \'{e} conhecida somente
em tempo de execu\c{c}\~{a}o. Essa similaridade n\~{a}o \'{e} apenas superficial. Na verdade, 
Scala representa cada valor de fun\c{c}\~{a}o como um objeto (veja Se\c{c}\~{a}o~\ref{sec:functions}).

\paragraph{Objetos}

Na implementa\c{c}\~{a}o pr\'{e}via de conjuntos de inteiros, conjuntos vazios eram expressos
com \code{new EmptySet}; ent\~{a}o um novo objeto era criado a cada vez que um valor
conjunto vazio era requerido. Podemos evitar cria\c{c}\~{o}es desnecess\'{a}rias de objetos 
definindo um valor \code{empty} uma vez e ent\~{a}o, usando este valor ao inv\'{e}s de cada 
ocorr\^{e}ncia de \code{new EmptySet}. Por exemplo:
 \begin{lstlisting}
 val EmptySetVal = new EmptySet
 \end{lstlisting}

Um problema com esse tratamento \'{e} que uma defini\c{c}\~{a}o de valor tal como a anterior
n\~{a}o \'{e} uma defini\c{c}\~{a}o top-level legal em Scala; tem de ser parte de uma outra classe 
ou objeto. Ainda, a defini\c{c}\~{a}o de classe \code{EmptySet} agora parece um pouco exagerada -- 
por que definir uma classe de objetos, se somente estamos interessados em um \'{u}nico objeto 
dessa classe? Um tratamento mais direto \'{e} usar uma {\em defini\c{c}\~{a}o de objeto}. Aqui est\'{a} 
uma alternativa mais adequada para a defini\c{c}\~{a}o de conjunto vazio:
\begin{lstlisting}
object EmptySet extends IntSet {
  def contains(x: Int): Boolean = false
  def incl(x: Int): IntSet = new NonEmptySet(x, EmptySet, EmptySet)
}
\end{lstlisting}

A sintaxe de uma defini\c{c}\~{a}o de objeto segue a sintaxe da defini\c{c}\~{a}o de uma 
classe; tem uma cl\'{a}usula opcional extends, bem como um corpo opcional. 
Assim como em classes, a cl\'{a}usula extends define membros herdados do objeto 
considerando que o corpo define novos membros ou sobrecarga. Entretanto, uma 
defini\c{c}\~{a}o de objeto denota um \'{u}nico objeto somente se n\~{a}o for poss\'{i}vel criar
outros objetos com a mesma estrutura usando \code{new}. Ent\~{a}o, defini\c{c}\~{o}es de
objeto tamb\'{e}m carecem de par\^{a}metros construtores, que podem estar presentes
nas defini\c{c}\~{o}es das classes.

Defini\c{c}\~{o}es de objetos podem aparecer em qualquer lugar em um programa Scala;
incluindo o top-level. Como n\~{a}o h\'{a} ordem fixa de execu\c{c}\~{a}o de entidades
top-level em Scala, pode-se questionar quando exatamente o objeto definido 
pela defini\c{c}\~{a}o de objeto \'{e} criado e inicializado. A resposta \'{e} que o objeto 
\'{e} criado assim que seus membros s\~{a}o acessados. Esta estrat\'{e}gia \'{e} chamada 
{\em avalia\c{c}\~{a}o pregui\c{c}osa}.

\paragraph{Classes Padr\~{a}o}
%% \todo{include picture}


Scala \'{e} uma linguagem orientada a objetos pura. Isso significa que cada valor 
em Scala pode ser visto como um objeto. De fato, mesmo tipos primitivos tais como 
\code{int} ou \code{boolean} n\~{a}o s\~{a}o tratados de modo especial. S\~{a}o definidos
como apelidos de tipos de classes Scala no m\'{o}dulo \code{Predef}.  
\begin{lstlisting}
type boolean = scala.Boolean
type int = scala.Int
type long = scala.Long
...
\end{lstlisting}

Por efici\^{e}ncia, o compilador geralmente representa valor de tipo
\code{scala.Int} por inteiros de 32 bits, valores de tipo \code{scala.Boolean}
por boleanos Java etc. Mas converte essas representa\c{c}\~{o}es especializadas para 
objetos quando requeridos, por exemplo, quando um valor primitivo \code{Int} \'{e} 
passada a uma fun\c{c}\~{a}o com um par\^{a}metro de tipo \code{AnyRef}. Consequentemente, a
representa\c{c}\~{a}o de valores primitivos \'{e} apenas uma otimiza\c{c}\~{a}o, n\~{a}o muda o significado
de um programa.

Aqui est\'{a} a especifica\c{c}\~{a}o da classe \code{Boolean}.
\begin{lstlisting}
package scala
abstract class Boolean {
  def && (x: => Boolean): Boolean
  def || (x: => Boolean): Boolean
  def !                 : Boolean

  def == (x: Boolean)   : Boolean
  def != (x: Boolean)   : Boolean
  def <  (x: Boolean)   : Boolean
  def >  (x: Boolean)   : Boolean
  def <= (x: Boolean)   : Boolean
  def >= (x: Boolean)   : Boolean
}
\end{lstlisting}

Boleanos podem ser definidos usando somente classes e objetos, sem
refer\^{e}ncia ao tipos b\'{a}sicos para boleanos ou n\'{u}meros. Uma poss\'{i}vel 
implementa\c{c}\~{a}o da claro \code{Boolean} \'{e} dada abaixo. Esta n\~{a}o \'{e} 
a implementa\c{c}\~{a}o atual na biblioteca padr\~{a}o Scala. Por raz\~{o}es de 
efici\^{e}ncia a implementa\c{c}\~{a}o padr\~{a}o usa boleanos primitivos.
\begin{lstlisting}
package scala
abstract class Boolean {
  def ifThenElse(thenpart: => Boolean, elsepart: => Boolean)

  def && (x: => Boolean): Boolean  =  ifThenElse(x, false)
  def || (x: => Boolean): Boolean  =  ifThenElse(true, x)
  def !                 : Boolean  =  ifThenElse(false, true)

  def == (x: Boolean)   : Boolean  =  ifThenElse(x, x.!)
  def != (x: Boolean)   : Boolean  =  ifThenElse(x.!, x)
  def <  (x: Boolean)   : Boolean  =  ifThenElse(false, x)
  def >  (x: Boolean)   : Boolean  =  ifThenElse(x.!, false)
  def <= (x: Boolean)   : Boolean  =  ifThenElse(x, true)
  def >= (x: Boolean)   : Boolean  =  ifThenElse(true, x.!)
}
case object True extends Boolean {
  def ifThenElse(t: => Boolean, e: => Boolean) = t
}
case object False extends Boolean {
  def ifThenElse(t: => Boolean, e: => Boolean) = e
}
\end{lstlisting}

Aqui est\'{a} uma especifica\c{c}\~{a}o parcial da classe \code{Int}.
\begin{lstlisting}
package scala
abstract class Int extends AnyVal {
  def toLong: Long
  def toFloat: Float
  def toDouble: Double

  def + (that: Double): Double
  def + (that: Float): Float
  def + (that: Long): Long
  def + (that: Int): Int         // analogo para -, *, /, %

  def << (cnt: Int): Int         // analogo para  >>, >>>

  def & (that: Long): Long
  def & (that: Int): Int         // analogo para |, ^

  def == (that: Double): Boolean
  def == (that: Float): Boolean
  def == (that: Long): Boolean   // analogo para !=, <, >, <=, >=
}
\end{lstlisting}

A classe \code{Int} pode em princ\'{i}pio tamb\'{e}m ser implementada usando
apenas objetos e classes, sem refer\^{e}ncia a um tipo constru\'{i}do para 
inteiros. Para ver como, vamos considerar um problema um pouco mais 
simples, especificamente como implementar um tipo \code{Nat} de 
n\'{u}meros naturais, ou seja, inteiros n\~{a}o negativo. Aqui est\'{a} uma defini\c{c}\~{a}o 
para uma classe abstrata \code{Nat}:
\begin{lstlisting}
abstract class Nat {
  def isZero: Boolean
  def predecessor: Nat
  def successor: Nat
  def + (that: Nat): Nat
  def - (that: Nat): Nat
}
\end{lstlisting}

Para implementar as opera\c{c}\~{o}es da classe \code{Nat}, n\'{o}s definimos um
sub-objeto \code{Zero} e uma subclasse \code{Succ} (para sucessor). Cada 
n\'{u}mero \code{N} \'{e} representado como \code{N} aplica\c{c}\~{o}es do construtor \code{Succ}
at\'{e} zero: 
 \[
 \underbrace{\mbox{\sl new Succ( ... new Succ}}_{\mbox{$N$ times}}\mbox{\sl (Zero) ... )}
 \]
A implementa\c{c}\~{a}o do objeto \code{Zero} \'{e} direta:
\begin{lstlisting}
object Zero extends Nat {
  def isZero: Boolean = true
  def predecessor: Nat = error("negative number")
  def successor: Nat = new Succ(Zero)
  def + (that: Nat): Nat = that
  def - (that: Nat): Nat = if (that.isZero) Zero
                           else error("negative number")
}
\end{lstlisting}

A implementa\c{c}\~{a}o das fun\c{c}\~{o}es  predecessor e subtra\c{c}\~{a}o sobre \code{Zero} leva a 
um \code{Erro}, que aborta o programa com uma mensagem de erro.

Aqui est\'{a} uma implementa\c{c}\~{a}o da classe sucessor: 

\begin{lstlisting}
class Succ(x: Nat) extends Nat  {
  def isZero: Boolean = false
  def predecessor: Nat = x
  def successor: Nat = new Succ(this)
  def + (that: Nat): Nat = x + that.successor
  def - (that: Nat): Nat = if (that.isZero) this 
                           else x - that.predecessor
}
\end{lstlisting}

Observe a implementa\c{c}\~{a}o do m\'{e}todo \code{successor}. Para criar o 
sucessor de um n\'{u}mero, precisamos passar o pr\'{o}prio objeto como um 
argumento para o construtor \code{Succ}. O pr\'{o}prio objeto \'{e} referenciado
por uma palavra reservada \code{this}.   

As implementa\c{c}\~{o}es de \code{+} e \code{-}, cada uma cont\'{e}m uma chamada 
recursiva com o argumento do costrutor como destinat\'{a}rio. A recurs\~{a}o 
terminar\'{a} assim que o destinat\'{a}rio for o objeto \code{Zero} (o que \'{e} 
garantido de acontecer eventualmente dado o modo com que os n\'{u}meros s\~{a}o formados).

\begin{exercise}
Escreva uma implementa\c{c}\~{a}o \code{Integer} dos n\'{u}meros inteiros. A implementa\c{c}\~{a}o deve
suportar todas as opera\c{c}\~{o}es da classe \code{Nat} e mais dois m\'{e}todos.

\begin{lstlisting}
def isPositive: Boolean
def negate: Integer
\end{lstlisting}

O primeiro m\'{e}todo deve retornar \code{true} se o n\'{u}mero for positivo. O segundo 
m\'{e}todo deve negativar o n\'{u}mero. N\~{a}o utilize qualquer classe num\'{e}rica padr\~{a}o Scala
em sua implementa\c{c}\~{a}o. (Dica: H\'{a} duas formas para implementar \code{Integer}. Uma
pode ou fazer uso da implementa\c{c}\~{a}o existente de \code{Nat}, representando um inteiro 
como um n\'{u}mero natural e um sinal. Ou pode-se generalizar a implementa\c{c}\~{a}o dada de 
\code{Nat} para \code{Integer}, usando as tr\^{e}s subclasses \code{Zero} para 0, 
\code{Succ} para n\'{u}meros positivos e \code{Pred} para n\'{u}meros negativos. 
\end{exercise}

\subsection*{Elementos da Linguagem Introduzidos Neste Cap\'{i}tulo}
 \textbf{Types:}
 \begin{lstlisting}
 Type         = ...  |  ident
 \end{lstlisting}

Tipos podem agora ser identificadores arbitr\'{a}rios que representam classes.

\textbf{Express\~{o}es:}
 \begin{lstlisting}
 Expr         = ...  |  Expr '.' ident  |  'new' Expr  |  'this'
 \end{lstlisting}

Uma express\~{a}o pode agora ser uma cria\c{c}\~{a}o de objeto, ou uma sele\c{c}\~{a}o
\code{E.m} de um membro \code{m} a partir de uma express\~{a}o valorada objeto \code{E},
ou pode ser a palavra reservada \code{this}.

 \textbf{Defini\c{c}\~{o}es e Declara\c{c}\~{o}es}
\begin{lstlisting}
Def          = FunDef  |  ValDef  |  ClassDef  |  TraitDef  |  ObjectDef
ClassDef     = ['abstract'] 'class' ident ['(' [Parameters] ')'] 
               ['extends' Expr] [`{' {TemplateDef} `}']
TraitDef     = 'trait' ident ['extends' Expr] ['{' {TemplateDef} '}']
ObjectDef    = 'object' ident ['extends' Expr] ['{' {ObjectDef} '}']
TemplateDef  = [Modifier] (Def | Dcl)
ObjectDef    = [Modifier] Def
Modifier     = 'private'  |  'override'
Dcl          = FunDcl  |  ValDcl
FunDcl       = 'def' ident {'(' [Parameters] ')'} ':' Type
ValDcl       = 'val' ident ':' Type
\end{lstlisting}

Uma defini\c{c}\~{a}o pode agora ser uma defini\c{c}\~{a}o de classe, trait ou objeto, tal como  
\begin{lstlisting}
class C(params) extends B { defs }
trait T extends B { defs }
object O extends B { defs }
\end{lstlisting}
As defini\c{c}\~{o}es \code{defs} na classe, trait ou objeto podem ser 
precedidas pelos modificadores \code{private} ou \code{override}.


Classes abstratas e traits podem tamb\'{e}m conter declara\c{c}\~{o}es. Isso introduz
fun\c{c}\~{o}es {\em deferred} (postergadas) ou valores com seus tipos, mas n\~{a}o 
d\~{a}o uma implementa\c{c}\~{a}o. Membros deferred devem ser implementados nas subclasses 
antes que objetos de uma classe abstrata ou trait sejam criados. 

\chapter{Classes Case e Casamento de Padr\~{o}es}

Digamos, queremos escrever um interpretador para express\~{o}es aritm\'{e}ticas. Para 
deixar as coisas simples inicialmente, vamos nos restringir somente a n\'{u}meros e opera\c{c}\~{o}es \code{+}.
Tais express\~{o}es podem ser representadas como hierarquia de classes, 
com uma classe abstrata base \code{Expr} como raiz, e duas subclasses \code{Number} e \code{Sum}.
Ent\~{a}o, uma express\~{a}o \code{1 + (3 + 7)} \'{e} representada como 
 \begin{lstlisting}
 new Sum(new Number(1), new Sum(new Number(3), new Number(7)))
 \end{lstlisting}

Agora, um avaliador de uma express\~{a}o como esta precisa saber de 
qual forma ela \'{e} (ou \code{Sum} ou \code{Number}) e tamb\'{e}m precisa
acessar os componentes da express\~{a}o. A implementa\c{c}\~{a}o a seguir prov\^{e}
todos os m\'{e}todos necess\'{a}rios.
\begin{lstlisting}
abstract class Expr {
  def isNumber: Boolean
  def isSum: Boolean
  def numValue: Int
  def leftOp: Expr
  def rightOp: Expr
}
class Number(n: Int) extends Expr {
  def isNumber: Boolean = true
  def isSum: Boolean = false
  def numValue: Int = n
  def leftOp: Expr = error("Number.leftOp")
  def rightOp: Expr = error("Number.rightOp")
}
class Sum(e1: Expr, e2: Expr) extends Expr {
  def isNumber: Boolean = false
  def isSum: Boolean = true
  def numValue: Int = error("Sum.numValue")
  def leftOp: Expr = e1
  def rightOp: Expr = e2
}
\end{lstlisting}

Com esta classifica\c{c}\~{a}o e m\'{e}todos de acesso, escrever uma fun\c{c}\~{a}o avaliador \'{e} simples:
\begin{lstlisting}
def eval(e: Expr): Int = {
  if (e.isNumber) e.numValue
  else if (e.isSum) eval(e.leftOp) + eval(e.rightOp)
  else error("unrecognized expression kind")
}
\end{lstlisting}

Entretanto, definir todos esses m\'{e}todos dentro das classes \code{Sum} e \code{Number}
\'{e} um tanto quanto tedioso. Al\'{e}m do mais, o problema fica ainda pior se desejarmos 
adicionar novas formas de express\~{o}es. Por exemplo, considere adicionar uma nova 
forma de express\~{a}o \code{Prod} para produtos. N\~{a}o apenas teremos de implementar uma nova classe 
\code{Prod}, com todos os m\'{e}todos de acesso e classifica\c{c}\~{a}o pr\'{e}vios; tamb\'{e}m teremos de 
introduzir um novo m\'{e}todo abstrato \code{isProduct} dentro da classe \code{Expr} e 
implementar aquele m\'{e}todo na subclasse \code{Number}, \code{Sum}, e \code{Prod}.
Ter de  modificar c\'{o}digo existente quando um sistema cresce \'{e} sempre problem\'{a}tico, pois
introduz problemas de vers\~{a}o e manuten\c{c}\~{a}o.  

A promessa da programa\c{c}\~{a}o orientada a objetos \'{e} que tais modifica\c{c}\~{o}es 
s\~{a}o desnecess\'{a}rias, dado que podem ser evitadas pela reutiliza\c{c}\~{a}o de c\'{o}digo 
existente e n\~{a}o modificado, atrav\'{e}s da heran\c{c}a. De fato, uma decomposi\c{c}\~{a}o 
mais orientada a objetos para nosso problema resolve a quest\~{a}o. A id\'{e}ia \'{e} tornar
a opera\c{c}\~{a}o de alto n\'{i}vel \code{eval} um m\'{e}todo para cada classe express\~{a}o, ao 
inv\'{e}s de implement\'{a}-lo como uma fun\c{c}\~{a}o fora da hierarquia de classes express\~{o}es, como 
fizemos anteriormente. Como \code{eval} \'{e} agora um membro de todos os n\'{o}s de express\~{a}o, 
quaisquer m\'{e}todos de classifica\c{c}\~{a}o e acesso tornam-se sup\'{e}rfluos, e a implementa\c{c}\~{a}o 
\'{e} simplificada consideravelmente:  
\begin{lstlisting}
abstract class Expr {
  def eval: Int
}
class Number(n: Int) extends Expr {
  def eval: Int = n
}
class Sum(e1: Expr, e2: Expr) extends Expr {
  def eval: Int = e1.eval + e2.eval
}
\end{lstlisting}

Al\'{e}m disso, adicionar uma nova classe \code{Prod} n\~{a}o leva a qualquer mudan\c{c}a ao c\'{o}digo existente:
\begin{lstlisting}
class Prod(e1: Expr, e2: Expr) extends Expr {
  def eval: Int = e1.eval * e2.eval
}
\end{lstlisting}

A conclus\~{a}o que tiramos deste exemplo \'{e} que a decomposi\c{c}\~{a}o orientada a objetos
\'{e} a t\'{e}cnica de escolha para a constru\c{c}\~{a}o de sistemas que devem ser estens\'{i}veis
com novos tipos de dados. Mas h\'{a} tamb\'{e}m um outro poss\'{i}vel modo para estender a 
express\~{a}o exemplo. Podemos querer adicionar novas {\em opera\c{c}\~{o}es} sobre express\~{o}es.
Por exemplo, podemos querer adicionar uma opera\c{c}\~{a}o que imprime uma \'{a}rvore-express\~{a}o
para a sa\'{i}da padr\~{a}o.  

Se definimos todos os m\'{e}todos de classifica\c{c}\~{a}o e acesso, tal opera\c{c}\~{a}o pode ser 
facilmente escrita como uma fun\c{c}\~{a}o externa. Aqui est\'{a} um exemplo: 
\begin{lstlisting}
def print(e: Expr) {
  if (e.isNumber) Console.print(e.numValue)
  else if (e.isSum) {
    Console.print("(")
    print(e.leftOp)
    Console.print("+")
    print(e.rightOp)
    Console.print(")")
  } else error("unrecognized expression kind")
}
\end{lstlisting}

Entretanto, se optamos por uma decomposi\c{c}\~{a}o orientada a objetos das 
express\~{o}es, precisaremos adicionar um novo procedimento \code{print} 
para cada classe: 
\begin{lstlisting}
abstract class Expr {
  def eval: Int
  def print
}
class Number(n: Int) extends Expr {
  def eval: Int = n
  def print { Console.print(n) }
}
class Sum(e1: Expr, e2: Expr) extends Expr {
  def eval: Int = e1.eval + e2.eval
  def print {
    Console.print("(")
    print(e1)
    Console.print("+")
    print(e2)
    Console.print(")")
  }
}
\end{lstlisting}

Consequentemente, decomposi\c{c}\~{a}o orientada a objetos cl\'{a}ssica requer modifica\c{c}\~{a}o 
de todas as classes existentes quando um sistema for estendido com novas
opera\c{c}\~{o}es.

Ainda como uma outra forma, podemos querer estender o interpretador. 
Considere a simplifica\c{c}\~{a}o de express\~{o}es. Por exemplo, podemos querer criar 
uma fun\c{c}\~{a}o que reescreve express\~{o}es da forma \code{a * b + a * c} para 
\code{a * (b + c)}. Esta opera\c{c}\~{a}o requer inspe\c{c}\~{a}o de mais de um n\'{o} para a 
\'{a}rvore de express\~{o}es ao mesmo tempo. Consequentemente, n\~{a}o pode ser implementada
por um m\'{e}todo dentro de cada tipo de express\~{a}o, a n\~{a}o ser que tal m\'{e}todo tamb\'{e}m 
possa inspecionar outros n\'{o}s. Portanto somos for\c{c}ados a ter m\'{e}todos de acesso e 
classifica\c{c}\~{a}o neste caso. Isto parece nos levar para a casa inicial, com todos os 
problemas de estensibilidade e expressividade.

Olhando mais de perto, observa-se que o \'{u}nico prop\'{o}sito das fun\c{c}\~{o}es de acesso
e classifica\c{c}\~{a}o  \'{e} {\em reverter} o processo de constru\c{c}\~{a}o de dados. Elas nos 
permitem determinar, primeiro, qual subclasse de uma classe base abstrata foi 
usada e, segundo, quais foram os argumentos construtores. Como essa situa\c{c}\~{a}o \'{e} 
bem comum, Scala tem um modo de automatiz\'{a}-lo para classes case.

\section{Classes Case e Objetos Case}

{\em Classes Case} e {\em objetos case} s\~{a}o definidos como classes e objetos 
normais, exceto que a defini\c{c}\~{a}o \'{e} prefixada com um modificador \code{case}. 
Por exemplo, as defini\c{c}\~{o}es:

\begin{lstlisting}
abstract class Expr
case class Number(n: Int) extends Expr
case class Sum(e1: Expr, e2: Expr) extends Expr
\end{lstlisting}

introduzem \code{Number} e \code{Sum} como classes case.
O modificador \code{case} em frente a uma defini\c{c}\~{a}o de classe ou objeto tem 
os seguintes efeitos.
\begin{enumerate}
\item Classes case implicitamente vem com uma fun\c{c}\~{a}o construtora, com o mesmo nome da classe.
No nosso exemplo, as duas fun\c{c}\~{o}es
\begin{lstlisting}
def Number(n: Int) = new Number(n)
def Sum(e1: Expr, e2: Expr) = new Sum(e1, e2)
\end{lstlisting}

ser\~{a}o adicionadas. Consequentemente, pode-se agora construir \'{a}rvores-express\~{o}es de modo um 
pouco mais conciso, como em
\begin{lstlisting}
Sum(Sum(Number(1), Number(2)), Number(3))
\end{lstlisting} 
\item Classes case e objetos case implicitamente vem com implementa\c{c}\~{o}es dos m\'{e}todos 
\code{toString}, \code{equals} e \code{hashCode}, que sobrescrevem os
m\'{e}todos com o mesmo nome na classe \code{AnyRef}. A implementa\c{c}\~{a}o desses 
m\'{e}todos leva em considera\c{c}\~{a}o em cada caso a estrutura de um membro de uma classe 
case. O m\'{e}todo \code{toString} representa uma \'{a}rvore express\~{a}o do modo como foi
constru\'{i}da. Ent\~{a}o,  
\begin{lstlisting}
Sum(Sum(Number(1), Number(2)), Number(3))
\end{lstlisting} 

ser\'{a} convertida exatamente naquela cadeia de caracteres, onde a implementa\c{c}\~{a}o 
default dentro da classe \code{AnyRef} retornar\'{a} uma cadeia de caracteres 
consistindo construtor \code{Sum} mais externo e um n\'{u}mero. O m\'{e}todo 
\code{equals} trata dois membros case da classe case do mesmo modo, caso
eles tenham sido constru\'{i}dos com o mesmo construtor e com argumentos que 
s\~{a}o par a par iguais. Isso tamb\'{e}m afeta a implementa\c{c}\~{a}o de \code{==} e 
\code{!=}, que s\~{a}o implementados em termos de \code{equals} em Scala. Ent\~{a}o,  
 \begin{lstlisting}
 Sum(Number(1), Number(2)) == Sum(Number(1), Number(2))
 \end{lstlisting}

dar\'{a} \code{true}. Se \code{Sum} ou \code{Number} n\~{a}o fossem classes case, a 
mesma express\~{a}o seria \code{false}, pois a implementa\c{c}\~{a}o padr\~{a}o de \code{equals} na 
classe \code{AnyRef} sempre trata objetos criados por diferentes chamadas de construtores 
como sendo diferentes. O m\'{e}todo \code{hashCode} segue a mesmo princ\'{i}pio dos 
outros dois m\'{e}todos. Computa um c\'{o}digo hash a partir do nome do construtor da classe case
e os c\'{o}digos hash dos argumentos do construtor, ao inv\'{e}s de o fazer a partir do endere\c{c}o 
do objeto, que \'{e} o que a implementa\c{c}\~{a}o default de \code{hashCode} faz.
\item
Classes case implicitamente vem com m\'{e}todos de acesso nulos que recuperam os argumentos 
do construtor. Em nosso exemplo, \code{Number} obteria um m\'{e}todo de acesso  
 \begin{lstlisting}
 def n: Int
 \end{lstlisting}

que retorna o par\^{a}metro \code{n} do construtor, onde \code{Sum} obter\'{a} dois m\'{e}todos de acesso
 \begin{lstlisting}
 def e1: Expr, e2: Expr
 \end{lstlisting}

Consequentemente, para um valor \code{s} de tipo \code{Sum}, digamos, 
podemos escrever \code{s.e1} para acessar o operando esquerdo. Entretanto, 
para um valor \code{e} de tipo \code{Expr}, o termo \code{e.e1} ser\'{a} ilegal,
pois \code{e1} \'{e} definido em \code{Sum}; n\~{a}o \'{e} um membro da classe base
\code{Expr}.
Ent\~{a}o, como determinar o construtor e os argumentos do construtor de acesso
para valores cujo tipo est\'{a}tico \'{e} a classe base \code{Expr}? Isso \'{e} resolvido
pela quarta e \'{u}ltima particularidade das classes case.
\item
Classes case permitem constru\c{c}\~{o}es de {\em padr\~{o}es} que se referem ao construtor 
da classe case.
 \end{enumerate}

\section{Casamento de Padr\~{o}es}

O casamento de padr\~{o}es \'{e} uma generaliza\c{c}\~{a}o do comando \code{switch} do C ou
Java para hierarquias de classes. Ao inv\'{e}s de um comando \code{switch}, h\'{a} um 
m\'{e}todo padr\~{a}o \code{match}, que \'{e} definido na classe ra\'{i}z Scala \code{Any}, e 
portanto est\'{a} dispon\'{i}vel para todos os objetos. O m\'{e}todo \code{match} recebe como 
argumento um n\'{u}mero de cases. Por exemplo, aqui est\'{a} uma implementa\c{c}\~{a}o de \code{eval}
usando casamento de padr\~{o}es.

\begin{lstlisting}
def eval(e: Expr): Int = e match {
  case Number(n) => n 
  case Sum(l, r) => eval(l) + eval(r) 
}
\end{lstlisting}

Neste exemplo, h\'{a} dois cases. Cada case associa um padr\~{a}o a uma express\~{a}o. 
Padr\~{o}es s\~{a}o casados contra o valor do seletor \code{e}. O primeiro padr\~{a}o do
nosso exemplo, \code{Number(n)}, casa todos os valores da forma \code{Number(v)},
onde \code{v} \'{e} um valor arbitr\'{a}rio. Naquele caso, a {\em vari\'{a}vel padr\~{a}o} \code{n}
\'{e} ligada ao valor \code{v}. Similarmente, o padr\~{a}o \code{Sum(l, r)} casa com todos 
os valores do seletor da forma \code{Sum(v}$_1$\code{, v}$_2$\code{)} e liga as 
vari\'{a}veis padr\~{a}o \code{l} e \code{r} a \code{v}$_1$ e \code{v}$_2$, respectivamente. 

Em geral, padr\~{o}es s\~{a}o constru\'{i}dos a partir

\begin{itemize}
\item Construtores de classes case, por exemplo \code{Number}, \code{Sum}, cujos
argumentos s\~{a}o, novamente, padr\~{o}es, 
\item vari\'{a}veis padr\~{a}o, por exemplo \code{n}, \code{e1}, \code{e2}, 
\item o padr\~{a}o ``coringa'' \code{_},
\item literais, tal como \code{1}, \code{true},  "abc", 
\item identificadores constantes, tais como \code{MAXINT}, \code{EmptySet}.  
\end{itemize}

Vari\'{a}veis padr\~{a}o sempre iniciam com uma letra min\'{u}scula, para que possamos
distingu\'{i}-las de identificadores constantes, que iniciam com uma letra 
mai\'{u}scula. Cada nome de vari\'{a}vel pode ocorrer somente uma vez em um padr\~{a}o. 
Por exemplo, \code{Sum(x, x)} seria ilegal como padr\~{a}o, pois a vari\'{a}vel padr\~{a}o 
\code{x} ocorre duas vezes dentro dele.  

\paragraph{Significado do Casamento de Padr\~{o}es}
Uma express\~{a}o de casamento de padr\~{o}es

\begin{lstlisting}
e match { case p$_1$ => e$_1$ ... case p$_n$ => e$_n$ }
\end{lstlisting}
casa os padr\~{o}es $p_1 \commadots p_n$ na ordem em que eles s\~{a}o 
escritos contra o valor seletor \code{e}.

\begin{itemize}
\item
Um construtor padrão $C(p_1 \commadots p_n)$ casa com todos os valores que são 
do tipo \code{C} (ou um subtipo dele) e que foram construídos com argumentos \code{C}
casando com padrões $p_1 \commadots p_n$.

\item 
Uma variável padrão \code{x} casa com qualquer valor e liga o nome da variável àquele valor.

\item 
O caracter padrão `\code{_}' casa com qualquer valor, mas não liga um nome àquele valor.

\item 
Um padrão constante \code{C} casa um valor que é igual (em termos de \code{==}) para \code{C}.

\end{itemize}



A expressão de casamento de padrões reescreve no lado direito do primeiro case cujo
padrão casa com o valor seletor. Referências as variáveis padrão são substituídas pelos 
correspondentes argumentos construtores. Se nenhum dos padrões casar, a expressão 
de casamento de padrões é abortada com um erro \code{MatchError}.  


\example Nosso modelo de substituição de avaliação de programa estende de modo natural o casamento de padrões. Por exemplo, aqui temos como \code{eval} aplicado a uma única expressão é reescrito:


\begin{lstlisting}
     eval(Sum(Number(1), Number(2)))

->   $\mbox{\tab\tab\rm(através da reescrita da aplicação)}$

     Sum(Number(1), Number(2)) match {
         case Number(n) => n
         case Sum(e1, e2) => eval(e1) + eval(e2)
     }

->   $\mbox{\tab\tab\rm(através da reescrita do casamento de padrões)}$

     eval(Number(1)) + eval(Number(2))

->   $\mbox{\tab\tab\rm(através da reescrita da primeira aplicação)}$

     Number(1) match {
         case Number(n) => n
         case Sum(e1, e2) => eval(e1) + eval(e2)
     } + eval(Number(2))

->   $\mbox{\tab\tab\rm(através da reescrita do casamento de padrões)}$

     1 + eval(Number(2))

->$^*$ 1 + 2 -> 3
\end{lstlisting}


\paragraph{Casamento de Padrões e Métodos}
No exemplo anterior, usamos casamento de padrões numa função que era definida fora da 
hierarquia de classes da qual pertencia. De fato, é também possível definir uma função 
de casamento de padrões na sua própria hierarquia de classes. Por exemplo, podíamos 
ter definido \code{eval} como um método da classe base \code{Expr}, e ainda assim usar o 
casamento de padrões na sua implementação:

\begin{lstlisting}
abstract class Expr { 
  def eval: Int = this match {
    case Number(n) => n
    case Sum(e1, e2) => e1.eval + e2.eval 
  } 
}
\end{lstlisting}

\begin{exercise} Considere as seguintes definições representando árvores de inteiros. 
Estas definições podem ser vistas como uma representação alternativa para \code{IntSet}: 

\begin{lstlisting}
abstract class IntTree
case object EmptyTree extends IntTree
case class  Node(elem: Int, left: IntTree, right: IntTree) extends IntTree
\end{lstlisting}


Complete as implementações a seguir da função \code{contains} e \code{insert} para 
\code{IntTree}.

\begin{lstlisting}
def contains(t: IntTree, v: Int): Boolean = t match { ...
  ...
}
def insert(t: IntTree, v: Int): IntTree = t match { ...
  ...
}
\end{lstlisting}
\end{exercise}


\paragraph{Funções Anônimas e Casamento de Padrões}

Até aqui, expressões case sempre apareceram conjuntamente com uma operação 
\verb@match@. Mas é também possível usar expressões case por elas mesmas. Um
bloco de expressões case tal como  


\begin{lstlisting}
{ case $P_1$ => $E_1$ ... case $P_n$ => $E_n$ }
\end{lstlisting}

é visto como uma função que casa seus argumentos contra os padrões $P_1 \commadots P_n$,
e produz o resultado de um dos $E_1 \commadots E_n$. (Se nenhum padrão casar, a função 
produzirá uma  exceção \code{MatchError}. 
Em outras palavras, a expressão acima é vista como um atalho para a função anônima
\begin{lstlisting}
(x => x match { case $P_1$ => $E_1$ ... case $P_n$ => $E_n$ })
\end{lstlisting}
onde \code{x} é uma variável nova que não é usada a não ser dentro da expressão.

\chapter{Tipos Genéricos e Métodos}

Classes em Scala podem ter tipos como parâmetros. Demostraremos o uso 
de tipos parâmetros com pilhas funcionais como exemplo. Digamos, desejamos
escrever um tipo de dados para pilhas de inteiros, com métodos \code{push},
\code{top}, \code{pop}, e \code{isEmpty}. Isso é conseguido pela seguinte 
hierarquia de classes:

\begin{lstlisting}
abstract class IntStack {
  def push(x: Int): IntStack = new IntNonEmptyStack(x, this)
  def isEmpty: Boolean
  def top: Int
  def pop: IntStack
}
class IntEmptyStack extends IntStack {
  def isEmpty = true
  def top = error("EmptyStack.top")
  def pop = error("EmptyStack.pop")
}
class IntNonEmptyStack(elem: Int, rest: IntStack) extends IntStack {
  def isEmpty = false
  def top = elem
  def pop = rest
}
\end{lstlisting}

De fato, faz sentido definir uma abstração para uma pilha de Strings. Para
isso, pode-se tomar a abstração existente para \code{IntStack}, renomeá-la para 
\code{StringStack} e ao mesmo tempo renomear todas as ocorrências do tipo
\code{Int} para \code{String}.

Um modo melhor, que não leva a duplicação de código, é parametrizar as
definições da pilha com o tipo do elemento. Parametrizações nos levam
a generalizar a partir de uma instância específica de um problema para 
uma mais genérica. Até aqui, usamos parametrização somente para valores, mas 
também está disponível para tipos. Para obtermos uma versão {\em genérica} de
\code{Stack}, a equiparemos com um parâmetro tipo.

\begin{lstlisting}
abstract class Stack[A] {
  def push(x: A): Stack[A] = new NonEmptyStack[A](x, this)
  def isEmpty: Boolean
  def top: A
  def pop: Stack[A]
}
class EmptyStack[A] extends Stack[A] {
  def isEmpty = true
  def top = error("EmptyStack.top")
  def pop = error("EmptyStack.pop")
}
class NonEmptyStack[A](elem: A, rest: Stack[A]) extends Stack[A] {
  def isEmpty = false
  def top = elem
  def pop = rest
}
\end{lstlisting}

Nas definições acima, `\code{A}' é um {\em parâmetro tipo} da classe
\code{Stack} e suas subclasses. Parâmetros tipo são nomes arbitrários; eles
são envolvidos por chaves ao invés de parênteses, portanto podem facilmente 
distinguidos de parâmetros valor. Aqui está um exemplo de como classes genéricas
são usadas:

\begin{lstlisting}
val x = new EmptyStack[Int]
val y = x.push(1).push(2)
println(y.pop.top)
\end{lstlisting}
A primeira linha cria uma nova pilha vazia de \code{Int}. Observe o tipo argumento 
\code{[Int]} que substitui o tipo parâmetro formal \code{A}.

Também é possível parametrizar métodos com tipos. Como um exemplo, aqui está um
método genérico que determina se uma pilha é um prefixo de outra.
\begin{lstlisting}
def isPrefix[A](p: Stack[A], s: Stack[A]): Boolean = {
  p.isEmpty ||
  p.top == s.top && isPrefix[A](p.pop, s.pop)
}
\end{lstlisting}

Os parâmetros do método são chamados {\em polimórficos}. Métodos genéricos são
também chamados {\em polimórficos}. O termo tem origem no Grego, onde 
significa ``que tem muitas formas''. Para aplicar um método polimórfico tal como 
\code{isPrefix}, passamos parâmetros tipo, bem como parâmetros valor para ele. 
Por exemplo,  

\begin{lstlisting}
val s1 = new EmptyStack[String].push("abc")
val s2 = new EmptyStack[String].push("abx").push(s1.top)
println(isPrefix[String](s1, s2))
\end{lstlisting}


\paragraph{Inferência de Tipos Local}
Passar parâmetros de tipo tais como \code{[Int]} ou \code{[String]} o
tempo todo pode tornar-se enfadonho em aplicações onde funções 
genéricas são muito utilizadas. Frequentemente, a informação dentro
de um parâmetro de tipo é redundante, porque o parâmetro tipo correto
pode também ser determinado pela inspeção dos parâmetros valores da 
função ou do tipo esperado do resultado. Tomando a expressão 
\code{isPrefix[String](s1, s2)} como um exemplo, sabemos que seus
parâmetros valor são ambos do tipo \code{Stack[String]}, portanto 
podemos deduzir que o parâmetro tipo deve ser \code{String}. Scala 
tem um poderoso mecanismo de inferência que nos permite omitir 
parâmetros tipo para funções polimórficas e construtores em 
situações como esta. No exemplo acima, poderíamos ter escrito
\code{isPrefix(s1, s2)} e o tipo do argumento omitido \code{[String]}
seria inserido pelo mecanismo de inferência de tipos.

\section{Parâmetros Tipo Ligados}

Agora que sabemos como criar classes genéricas é natural generalizarmos 
algumas das classes escritas anteriormente. Por exemplo, a classe \code{IntSet}
poderia ser generalizada para conjuntos com tipos arbitrários de elementos.
Vamos tentar. A classe abstrata para conjuntos genéricos é facilmente escrita.

\begin{lstlisting}
abstract class Set[A] {
  def incl(x: A): Set[A]
  def contains(x: A): Boolean
}
\end{lstlisting}
Entretanto, se ainda quisermos implementar conjuntos como árvores binárias 
de busca, encontraremos um problema. Os métodos \code{contains} e \code{incl}, 
ambos comparam elementos usando métodos \code{<} e \code{>}. Para \code{IntSet}
isto está OK, pois o tipo \code{Int} tem estes dois métodos. Mas para um 
tipo arbitrário de parâmetro \code{a}, não podemos garantir isso. Logo, a 
implementação anterior de, digamos, \code{contains} levará a um erro de compilação.

\begin{lstlisting}
  def contains(x: Int): Boolean =
    if (x < elem) left contains x
          ^ < $\mbox{\sl não é membro do tipo}$ A.
\end{lstlisting}

Um modo de resolver o problema é restringir os tipos legais que podem ser
substituídos pelo tipo \code{A} àqueles que contenham os métodos \code{<} e 
\code{>} do tipos corretos. Na biblioteca de classes padrão do Scala há 
o trait \code{Ordered[A]} que representa valores que podem ser comparados (via \code{<}
e \code{>}) a valores do tipo \code{A}. Esse trait é definido como segue:

\begin{lstlisting}
/** Uma classe com todos os dados ordenados. */
trait Ordered[A] {

  /** Resultado da comparacao de `this' com o operando `that'.
   *  returna `x' onde
   *  x < 0    iff    this < that
   *  x == 0   iff    this == that
   *  x > 0    iff    this > that
   */
  def compare(that: A): Int

  def <  (that: A): Boolean = (this compare that) <  0
  def >  (that: A): Boolean = (this compare that) >  0
  def <= (that: A): Boolean = (this compare that) <= 0
  def >= (that: A): Boolean = (this compare that) >= 0
  def compareTo(that: A): Int = compare(that)
}
\end{lstlisting}
Podemos forçar a compatibilidade de um tipo demandando que esse tipo seja
subtipo de \code{Ordered}. Isto é feito dando um limite superior ao 
parâmetro tipo de \code{Set}:

\begin{lstlisting}
trait Set[A <: Ordered[A]] {
  def incl(x: A): Set[A]
  def contains(x: A): Boolean
}
\end{lstlisting}
A declaração de parâmetro \code{A <: Ordered[A]} introduz \code{A} como um 
parâmetro tipo que deve ser um subtipo de \code{Ordered[A]}, ou seja, seus 
valores devem ser comparáveis a valores de mesmo tipo.

Com esta restrição, podemos agora implementar o restante da abstração genérica 
de conjunto como fizemos anteriormente no caso de \code{IntSet}. 

\begin{lstlisting}
class EmptySet[A <: Ordered[A]] extends Set[A] {
  def contains(x: A): Boolean = false
  def incl(x: A): Set[A] = new NonEmptySet(x, new EmptySet[A], new EmptySet[A])
}
\end{lstlisting}

\begin{lstlisting}
class NonEmptySet[A <: Ordered[A]]
        (elem: A, left: Set[A], right: Set[A]) extends Set[A] {
  def contains(x: A): Boolean =
    if (x < elem) left contains x
    else if (x > elem) right contains x
    else true
  def incl(x: A): Set[A] =
    if (x < elem) new NonEmptySet(elem, left incl x, right)
    else if (x > elem) new NonEmptySet(elem, left, right incl x)
    else this
}
\end{lstlisting}

Observe que deixamos de fora o tipo argumento na criações dos objetos 
\code{new NonEmptySet(...)}. Do mesmo modo que para métodos polimórficos, 
tipos de argumentos faltantes nas chamadas de contrutores são inferidos a 
partir do valor dos argumentos e/ou o tipo esperado do resultado. 

Aqui está um exemplo que usa a abstração genérica de conjunto. Vamos primeiro 
criar uma subclasse de \lstinline@Ordered@, como esta:

\begin{lstlisting}
case class Num(value: Double) extends Ordered[Num] {
  def compare(that: Num): Int =
    if (this.value < that.value) -1
    else if (this.value > that.value) 1
    else 0
}
\end{lstlisting}
Então:
\begin{lstlisting}
val s = new EmptySet[Num].incl(Num(1.0)).incl(Num(2.0))
s.contains(Num(1.5))
\end{lstlisting}
Isto está OK, pois o tipo \code{Num} implementa o trait \code{Ordered[Num]}.
Entretanto, o exemplo seguinte está errado. 
\begin{lstlisting}
val s = new EmptySet[java.io.File]
                    ^ java.io.File $\mbox{\sl não implementa o tipo }$
                      Ordered[java.io.File] definido no $\mbox{\sl tipo do parâmetro}$.
\end{lstlisting}

Um problema com ligações para parâmetros tipo é que elas requerem antecipação:
se não declaramos \lstinline@Num@ uma subclasse de\lstinline@Ordered@, 
não estaremos aptos a usar elementos  \lstinline@Num@ dentro dos conjuntos.
A partir do mesmo token, tipos herdados do Java, tais como \lstinline@Int@, 
\lstinline@Double@, ou \lstinline@String@ não são subclasses de  \lstinline@Ordered@,
portanto valores destes tipos não podem ser usados como elementos de conjuntos.

Um desenho mais flexível, que admite elementos destes tipos, usam {\em ligações de visão} 
ao invés de ligações plenas a tipos como temos visto. A única mudança que isto
no leva no exemplo abaixo está nos parâmetros tipo:

\begin{lstlisting}
trait Set[A <% Ordered[A]] ...
class EmptySet[A <% Ordered[A]] ...
class NonEmptySet[A <% Ordered[A]] ...
\end{lstlisting}
Ligações visão \lstinline@<%@ são mais fracas que ligações plenas \verb@<:@:
Uma ligação visão da cláusula do tipo parâmetro \lstinline@[A <% T]@ somente 
especifica que o tipo ligado \lstinline@A@ deve ser {\em convertido} ao tipo
ligado \lstinline@T@, usando uma conversão implícita.

A biblioteca Scala predefine conversões implícitas para vários tipos, incluindo
os tipos primitivos e \lstinline@String@. Entretanto, o redesenho da abstração conjunto 
pode ser, do mesmo modo,  instanciada com estes tipos. Mais explicações sobre 
conversões implicitas e ligações visão são dadas na Seção~\ref{sec:implicits}.

\section{Anotações de Variância}\label{sec:first-arrays}

A combinação de tipos parâmetros e subtipos levantam algumas questões interessantes.
Por exemplo, \code{Stack[String]} deve ser um subtipo de \code{Stack[AnyRef]}? 
Intuitivamente, isto parece OK, pois uma pilha de \code{String}s é um caso 
especial de uma pilha de \code{AnyRef}s. Mais genericamente, se \code{T} é um
subtipo do tipo \code{S}, então, \code{Stack[T]} deve ser um subtipo de 
\code{Stack[S]}. Essa propriedade é chamada subtipificação {\em co-variante}.

Em Scala, tipos genéricos tem por padrão subtipificação não variante. Ou seja, 
com \code{Stack} definido conforme acima, pilhas com tipos de elementos diferentes
nunca estarão numa relação de subtipo. Entretanto, podemos forçar a subtipificação 
co-variante das pilhas mudando a primeira linha da definição da classe \code{Stack}
como segue.

\begin{lstlisting}
class Stack[+A] {
\end{lstlisting}
Prefixando um parâmetro tipo formal com um \code{+} indica que aquela 
subtipificação é covariante naquele parâmetro. Além do \code{+}, há também um
prefixo \code{-} que indica subtipificação contravariante. Se \code{Stack}
foi definida \code{class Stack[-A] ...}, então \code{T}, um subtipo do tipo
\code{S}, poderia implicar que \code{Stack[S]} é um subtipo de \code{Stack[T]}
(o que no caso de pilhas seria um tanto quanto surpreendente!). 

Em um mundo puramente funcional, todos os tipos podem ser covariantes. Entretanto, 
a situação muda quando introduzimos dados mutantes. Considere o caso de vetores 
em Java ou .NET. Tais vetores são representados em Scala por uma classe genérica 
\code{Array}. Aqui está uma definição parcial desta classe.
\begin{lstlisting}
class Array[A] {
  def apply(index: Int): A
  def update(index: Int, elem: A)
}
\end{lstlisting}

A classe acima define o modo que vetores em Scala são vistos a partir de programas 
Scala do usuário. O compilador Scala mapeará esta abstração aos vetores subjacentes
do sistema hospedeiro sempre que possível.

Em Java, vetores são, de fato, covariantes; ou seja, para os tipos referenciados \code{T} e 
\code{S}, se \code{T} é um subtipo de \code{S}, então \code{Array[T]} é um subtipo de 
\code{Array[S]}. Isso pode parecer natural, mas leva a problemas de segurança que requerem
checagem especial em tempo de execução. Aqui está um exemplo: 

\begin{lstlisting}
val x = new Array[String](1)
val y: Array[Any] = x
y(0) = new Rational(1, 2)  // $\mbox{\sl isto \'{e} syntactic sugar para}$
                           // y.update(0, new Rational(1, 2))
\end{lstlisting}
Na primeira linha, um novo vetor de strings é criado. Na segunda linha, 
este vetor é ligado a uma variável \code{y}, de tipo \code{Array[Any]}. 
Assumindo vetores como covariantes, isto está OK, pois \code{Array[String]}
é um subtipo de \code{Array[Any]}. Finalmente, na última linha, um número 
racional é guardado no vetor. Isso também está OK, pois o tipo \code{Rational} é 
um subtipo do tipo do elemento \code{Any} do vetor \code{y}. Acabamos por 
guardar um número racional em um vetor de strings, o que claramente viola
a integridade do tipo.

Java resolve este problema introduzindo checagem em tempo de execução na 
terceira linha que testa se o elemento guardado é compatível com o tipo
de elemento para o qual o vetor foi criado. Vimos no exemplo que este 
tipo de elemento não é necessariamente o tipo estático de elemento do 
vetor que está sendo atualizado. Se o teste falhar, é dado um 
\code{ArrayStoreException}.

Ao invés disto, Scala resolve este problema estáticamente, rejeitando a
segunda linha em tempo de compilação, porque vetores em Scala tem 
subtipificação não variante. Isso nos leva a questão de como o 
compilador Scala verifica que anotações de variância são corretas.
Se simplesmente declararmos vetores como covariantes, como detectar
este potencial problema?

Scala usa uma aproximação conservadora para verificar a integridade de
anotações de variância. Um parâmetro tipo covariante de uma classe pode 
somente aparecer em posições covariantes dentro da classe. Apesar de
posições covariantes serem tipos de valores na classe, o tipo resultante
dos métodos na classe, e tipos argumentos para outros tipos covariantes. 
Não covariantes são tipos de parâmetros formais de métodos. Logo, a seguinte 
definição de classe seria rejeitada
\begin{lstlisting}
class Array[+A] {
  def apply(index: Int): A
  def update(index: Int, elem: A)
                               ^ $\mbox{\sl o tipo parâmetro covariante}$ A
                                 $\mbox{\sl aparece na posição contravariante.}$
}
\end{lstlisting}

Até aqui tudo bem. Intuitivamente, o compilador estava correto rejeitando o 
procedimento \code{update} na classe covariante, porque \code{update} potencialmente 
muda estado, e portanto mina a integridade da subtipificação covariante.

Entretanto, há também métodos que não mudam estado, mas onde um parâmetro tipo ainda
aparece contravariantemente. Como exemplo temos o \code{push} no tipo \code{Stack}. 
Novamente o compilador Scala rejeitará a definição deste método para pilhas covariantes.


\begin{lstlisting}
class Stack[+A] {
  def push(x: A): Stack[A] =
              ^ $\mbox{\sl o tipo parâmetro covariante}$ A
                $\mbox{\sl aparece na posição contravariante.}$
\end{lstlisting}

Isto é uma pena, porque diferente de vetores, pilhas são estruturas de dados 
puramente funcionais e portanto devem habilitar a subtipificação covariante. 
Entretanto,  há um modo de resolver o problema usando um método polimórfico
com uma baixa ligação para tipos de parâmetros. 

\section{Lower Bounds}

Nós temos visto ligações fortes para tipos de parâmetros. Em uma declaração 
de tipo parâmetro tal como \code{T <: U}, o tipo parâmetro \code{T} é restrito
ao intervalo somente sobre subtipos do tipo \code{U}. Simetrico a isso estão as 
ligações fracas em Scala. Em uma declaração de tipo parâmetro \code{T >: S}, o 
tipo parâmetro \code{T} está restrito ao intervalo somente sobre {\em supertipos} 
do tipo \code{S}. (Pode-se também combinar ligações fracas e fortes, como em \code{T >: S <: U}.) 

Usando ligações fracas, podemos generalizar o método \code{push} dentro de \code{Stack}
como segue.

\begin{lstlisting}
class Stack[+A] {
  def push[B >: A](x: B): Stack[B] = new NonEmptyStack(x, this)
\end{lstlisting}

Tecnicamente isso resolve nosso problema de variância, pois agora o tipo parâmetro 
\code{A} não mais aparece como um tipo parâmetro do método \code{push}. Ao invés, 
aparece como ligação fraca para um outro tipo parâmetro de um método, que é 
classificado como uma posição covariante. Logo, o compilador Scala aceita
a nova definição de \code{push}. 

De fato, não apenas resolvemos o problema técnico da variância, mas também 
generalizamos a definição de \code{push}. Antes, só podíamos efetuar push em
elementos com tipos que estivessem em conformidade com o tipo do elemento
declarado da pilha. Agora, também podemos efetuar push sobre elementos de um
supertipo deste tipo, mas o tipo da pilha retornada será alterado de acordo. 
Por exemplo, podemos agora efetuar push de \code{AnyRef} sobre uma pilha de 
\code{String}s, mas a pilha resultante será uma pilha de \code{AnyRef}s ao 
invés de uma pilha de \code{String}s! 

Em resumo, não devemos hesitar em adicionar anotações de variância às estruturas de dados, 
pois isso enriquece naturalmente relacionamentos de subtipificação. O compilador detectará
problemas de integridade potenciais. Mesmo se a aproximação do compilador for muito 
conservadora, frequentemente sugerirá uma generalização útil do método contestado.

\section{Tipos Minimais}

Scala não nos permite parametrizar objetos com tipos. Este é o motivo 
pelo qual originalmente definimos uma classe genérica \code{EmptyStack[A]}, 
ainda que um único valor denotando pilhas vazias de tipos arbitrários o 
fizesse. Para pilhas covariantes, entretanto, pode-se usar o seguinte idioma:

\begin{lstlisting}
object EmptyStack extends Stack[Nothing] { ... }
\end{lstlisting}

O tipo base \code{Nothing} não contém valor, portanto o tipo \code{Stack[Nothing]}
expressa o fato que uma \code{EmptyStack} não contém elementos. Além disso, 
\code{Nothing} é um subtipo de todos os outros tipos. Consequentemente, para 
pilhas covariantes, \code{Stack[Nothing]} é um subtipo de \code{Stack[T]}, para 
qualquer outro tipo \code{T}. Isso torna possível usar um único objeto pilha vazia
no código do usuário. Por exemplo:

\begin{lstlisting}
val s = EmptyStack.push("abc").push(new AnyRef())
\end{lstlisting}
Vamos analisar a atribuição de tipo para esta expressão em detalhes. 
O objeto \code{EmptyStack} é do tipo \code{Stack[Nothing]}, o qual tem um método 
\begin{lstlisting}
push[B >: Nothing](elem: B): Stack[B] .
\end{lstlisting}
A inferência local de tipos determinará que o tipo parâmetro \code{B} deve ser
instanciado para \code{String} na aplicação \code{EmptyStack.push("abc")}. O tipo resultado
desta aplicação é, consequentemente, \code{Stack[String]}, que por sua vez tem um método  
\begin{lstlisting}
push[B >: String](elem: B): Stack[B] .
\end{lstlisting}

A parte final da definição do valor acima é a aplicação deste método a \code{new AnyRef()}.
A inferência local de tipos determinará que o tipo parâmetro \code{b} deve desta vez
ser instanciado para \code{AnyRef}, com tipo resultado \code{Stack[AnyRef]}. 
Consequentemente, o tipo atribuído ao valor \code{s} é \code{Stack[AnyRef]}.

Além de \code{Nothing}, que é um subtipo para cada outro tipo, há também o tipo \code{Null},
que é um subtipo de \code{scala.AnyRef}, e de cada classe derivada dele. O literal \code{Null}
em Scala é o único valor deste tipo. Isto torna \code{null} compatível com cada tipo referência, 
mas não com um valor de tipo tal como \code{Int}.  

Concluímos esta seção com a definição completa melhorada de pilhas. Pilhas tem agora subtipificação
covariante, o método \code{push} foi generalizado, e a pilha vazia é denotada por um único objeto.
\begin{lstlisting}
abstract class Stack[+A] {
  def push[B >: A](x: B): Stack[B] = new NonEmptyStack(x, this)
  def isEmpty: Boolean
  def top: A
  def pop: Stack[A]
}
object EmptyStack extends Stack[Nothing] {
  def isEmpty = true
  def top = error("EmptyStack.top")
  def pop = error("EmptyStack.pop")
}
class NonEmptyStack[+A](elem: A, rest: Stack[A]) extends Stack[A] {
  def isEmpty = false
  def top = elem
  def pop = rest
}
\end{lstlisting}

Muitas classes na biblioteca Scala são genéricas. Agora apresentaremos duas
comumente usadas famílias de classes genéricas, tuplas e funções. A discussão 
de uma outra classe bem comum, listas, é postergada para o próximo capítulo.

\section{Tuplas}

Vez por outra, uma função precisa retornar mais de um resultado. Por exemplo, suponha a 
função \code{divmod} que retorna o quociente inteiro e o resto de dois argumentos inteiros dados.
De fato, pode-se definir uma classe para pegar os dois resultados de \code{divmod}, como em:
\begin{lstlisting}
case class TwoInts(first: Int, second: Int)
def divmod(x: Int, y: Int): TwoInts = new TwoInts(x / y, x % y)
\end{lstlisting}
Entretanto, ter que definir uma nova classe para cada possível par de tipos de resultados é 
bastante tedioso. Em Scala pode-se usar, ao invés, uma classe genérica \lstinline@Tuple$2$@,
que é definida como segue:   
\begin{lstlisting}
package scala
case class Tuple2[A, B](_1: A, _2: B)
\end{lstlisting}
Com \code{Tuple2}, o método \code{divmod} pode ser escrito como segue.
\begin{lstlisting}
def divmod(x: Int, y: Int) = new Tuple2[Int, Int](x / y, x % y)
\end{lstlisting}

Como sempre, parâmetros tipos para construtores podem ser omitidos se forem 
dedutíveis a partir dos valores dos argumentos. Há também classes tuplas para 
cada outro número de elementos (a implementação Scala atual limita isto a tuplas
de algum número razoável de elementos).  
\comment{
Também, Scala define um alias \code{Pair} para \code{Tuple2} (bem como com \code{Triple}
para \code{Tuple3}). Com tais convenções, \code{divmod} pode, equivalentemente ser escrita
como segue. 
\begin{lstlisting}
def divmod(x: Int, y: Int): Pair(Int, Int) = Pair(x / y, x % y)
\end{lstlisting}
}

Como os elementos de tuplas são acessados? Como tuplas são classes case, há duas possibilidades. 
Pode-se ou acessar os campos da tupla usando os nomes dos parâmetros dos construtores 
\lstinline@_$i$@, como no seguinte exemplo:
\begin{lstlisting}
val xy = divmod(x, y)
println("quotient: " + xy._1 + ", rest: " + xy._2)
\end{lstlisting}
Ou usa-se casamento de padrões sobre tuplas, como no seguinte exemplo: 
\begin{lstlisting}
divmod(x, y) match {
  case Tuple2(n, d) =>
    println("quotient: " + n + ", rest: " + d)
}
\end{lstlisting}
Observe que tipos parâmetros nunca são usados nos padrões; seria ilegal escrever 
case \code{Tuple2[Int, Int](n, d)}.

Tuplas são tão convenientes que Scala define uma sintaxe especial para elas. 
Para formar uma tupla com $n$ elementos $x_1 \commadots x_n$ pode-se escrever
$(x_1 \commadots x_n)$. Isto é equivalente a \lstinline@Tuple$n$($x_1 \commadots x_n$)@.
A sintaxe  $(...)$ funciona de modo equivalente para tipos e para padrões. Com esta
sintaxe para tuplas, o exemplo \lstinline@divmod@ é escrito como segue:
\begin{lstlisting}
def divmod(x: Int, y: Int): (Int, Int) = (x / y, x % y)
divmod(x, y) match {
  case (n, d) => println("quotient: " + n + ", rest: " + d)
}
\end{lstlisting}
\section{Funções}\label{sec:functions}

Scala é uma linguagem funcional na qual funções são valores de primeira classe. 
Scala é também uma linguagem orientada a objetos na qual cada valor é um objeto.  
Segue daí que funções são objetos em Scala. Por exemplo, uma função do tipo 
\code{String} para o tipo \code{Int} é representada como uma instância do trait
\code{Funciton1[String, Int]}. O trait \code{Function1} é definido como segue.

\begin{lstlisting}
package scala
trait Function1[-A, +B] {
  def apply(x: A): B
}
\end{lstlisting}

Ao lado de \code{Funciton1}, há também definições para funções de todas as outras 
aridades (a implementação corrente implementa isto somente até um limite razoável).
Ou seja, há uma definição para cada possível número de parâmetros de funções. Sintaxe para 
tipos de funções em Scala ~\lstinline@$(T_1 \commadots T_n)$ => $S$@~ é apenas uma abreviatura 
para o tipo parametrizado  ~\lstinline@Function$n$[$T_1 \commadots T_n, S$]@~.

Scala usa a mesma sintaxe $f(x)$ para aplicações de funções, não importa se 
$f$ é um método ou um objeto função. Isto é possível pela seguinte convenção:
Uma aplicação de função $f(x)$ onde $f$ é um objeto (em contraste com um método)
é tomado para ser um atalho para \lstinline@$f$.apply($x$)@. Consequentemente, 
o método \code{apply} de um tipo de função é inserido automaticamente onde isso 
é necessário.

Isso justifica o porquê definimos subscritos de vetores na Seção~\ref{sec:first-arrays} 
através de um método \code{apply}. Para cada vetor \code{a}, a operação subscritora \code{a(i)} 
é tomada como um atalho para \code{a.apply(i)}.

Funções são exemplos em que uma declaração de um parâmetro tipo 
contravariante é útil. Por exemplo, considere o seguinte código:

\begin{lstlisting}
val f: (AnyRef => Int)  =  x => x.hashCode()
val g: (String => Int)  =  f
g("abc")
\end{lstlisting}

É correto ligar o valor \code{g} de tipo \code{String => Int} a \code{f}, que 
é do tipo \code{AnyRef => Int}. De fato, tudo o que se pode fazer com uma 
função do tipo \code{String => Int} é passar-lhe uma string para se obter um inteiro.
Isso demonstra que subtipificar funções é contravariante nos tipos dos argumentos, enquanto 
é covariante no tipo do seu resultado. Em resumo, $S \Rightarrow T$ é um subtipo de $S' \Rightarrow T'$,
desde que  $S'$ seja um subtipo de $S$ e $T$ seja um subtipo de $T'$.

\example Considere o código Scala 
\begin{lstlisting}
val plus1: (Int => Int)  =  (x: Int) => x + 1
plus1(2)
\end{lstlisting}
Isso é expandido no seguinte código objeto.
\begin{lstlisting}
val plus1: Function1[Int, Int] = new Function1[Int, Int] {
  def apply(x: Int): Int = x + 1
}
plus1.apply(2)
\end{lstlisting}
Aqui, a criação do objeto \lstinline@new Function1[Int, Int]{ ... }@
representa uma instância de uma {\em classe anônima}. Combina a criação 
de um novo objeto \code{Function1} com uma implementação do método \code{apply}
(que é abstrato dentro de \code{Function1}). Equivalentemente, mas mais
prolixo, podería-se usar uma classe local:
\begin{lstlisting}
val plus1: Function1[Int, Int] = {
  class Local extends Function1[Int, Int] {
    def apply(x: Int): Int = x + 1
  }
  new Local: Function1[Int, Int]
}
plus1.apply(2)
\end{lstlisting}

\chapter{Listas}

Listas são uma importante estrutura de dados em muitos programas Scala. Uma 
lista contendo os elementos \code{x}$_1$, \ldots, \code{x}$_n$ é escrita
\code{List(x}$_1$\code{, ..., x}$_n$\code{)}. Alguns exemplos:

\begin{lstlisting}
val fruit = List("apples", "oranges", "pears")
val nums  = List(1, 2, 3, 4)
val diag3 = List(List(1, 0, 0), List(0, 1, 0), List(0, 0, 1))
val empty = List()
\end{lstlisting}

Listas são similares a vetores em linguagens tais como C ou Java, mas há 
também três importantes diferenças. Primeiro, listas são imutáveis. Ou seja, 
elementos de uma lista não podem ser mudados por meio de atribuição. Segundo, 
listas tem uma estrutura recursiva, enquanto vetores são triviais. Terceiro, 
em geral, listas suportam um conjunto muito mais rico de operações que vetores. 
 
\section{Usando Listas}

\paragraph{O tipo lista}

Do mesmo modo que com vetores, listas são {\em homogêneas}. Ou seja, os elementos 
de uma lista têm todos o mesmo tipo. O tipo de uma lista com elementos de tipo 
\code{T} é escrito \code{List[T]} (compare com \code{T[]} em Java).

\begin{lstlisting}
val fruit: List[String]    = List("apples", "oranges", "pears")
val nums : List[Int]       = List(1, 2, 3, 4)
val diag3: List[List[Int]] = List(List(1, 0, 0), List(0, 1, 0), List(0, 0, 1))
val empty: List[Int]       = List()
\end{lstlisting}

\paragraph{Construtores de listas}
Todas as listas são construídas a partir de dois construtores fundamentais, \code{Nil} e 
\code{::} (lê-se ``cons''). \code{Nil} representa uma lista vazia. O operador infixo 
\code{::} expressa a extensão da lista. Ou seja, \code{x :: xs} denota uma lista 
cujo primeiro elemento é \code{x}, e que é seguido pela (os elementos da) lista \code{xs}.
Consequentemente, os valores da lista acima podem também ter sido definidos como segue 
(de fato essa definição prévia é apenas um facilitador sintático para as definições abaixo).
\begin{lstlisting}
val fruit  = "apples" :: ("oranges" :: ("pears" :: Nil))
val nums   = 1 :: (2 :: (3 :: (4 :: Nil)))
val diag3  = (1 :: (0 :: (0 :: Nil))) ::
             (0 :: (1 :: (0 :: Nil))) ::
             (0 :: (0 :: (1 :: Nil))) :: Nil
val empty  = Nil
\end{lstlisting}
A operação `\code{::}' é associativa à direita: \code{A :: B :: C} é 
interpretada como \code{A :: (B :: C)}. Por essa razão, podemos retirar os 
parênteses das definições acima. Por exemplo, podemos escrever de modo resumido
\begin{lstlisting}
val nums  =  1 :: 2 :: 3 :: 4 :: Nil
\end{lstlisting}

\paragraph{Operações básicas sobre listas}
Todas as operações sobre listas podem ser expressas em termos das três a seguir:

\begin{tabular}{ll}
\code{head}  & retorna o primeiro elemento de uma lista,\\
\code{tail}  & retorna a lista que consiste de todos os elementos exceto o\\
& primeiro elemento,\\
\code{isEmpty} & retorna \code{true} se e só se a lista for vazia.
\end{tabular}

Estas operações são definidas como métodos de objetos listas. Portanto as invocamos 
escolhendo da lista aqueles que sofrerão a operação. Exemplos: 

\begin{lstlisting}
empty.isEmpty   = true
fruit.isEmpty   = false
fruit.head      = "apples"
fruit.tail.head = "oranges"
diag3.head      = List(1, 0, 0)
\end{lstlisting}
Os métodos \code{head} e \code{tail} são definidos somente para listas não vazias.
Quando selecionados para uma lista vazia, eles lançam uma exceção.

Como um exemplo de como listas podem ser processadas, considere ordenar os elementos 
de uma lista de números em ordem crescente. Um modo simples de fazer isso é usar o 
{\em insertion sort}, que trabalha da seguinte maneira: Para ordenar uma lista não 
vazia com primeiro elemento \code{x} e resto \code{xs}, ordene o restante \code{xs} e 
insira o elemento \code{x} na posição correta do resultado. Ordenar uma lista vazia dará
uma lista vazia. Em Scala temos o código:
\begin{lstlisting}
def isort(xs: List[Int]): List[Int] =
  if (xs.isEmpty) Nil
  else insert(xs.head, isort(xs.tail))
\end{lstlisting}

\begin{exercise} Escreva a função faltante \code{insert}.
\end{exercise}

\paragraph{Listas e padrões} De fato, \code{::} é definido como uma 
classe case na biblioteca padrão Scala. Consequentemente, é possível 
decompor listas através de casamento de padrões, usando padrões compostos
a partir dos construtores  \code{Nil} e \code{::}. Por exemplo, \code{isort}
pode ser escrito aternativamente como segue.
\begin{lstlisting}
def isort(xs: List[Int]): List[Int] = xs match {
  case List() => List()
  case x :: xs1 => insert(x, isort(xs1))
}
\end{lstlisting}
onde
\begin{lstlisting}
def insert(x: Int, xs: List[Int]): List[Int] = xs match {
  case List() => List(x)
  case y :: ys => if (x <= y) x :: xs else y :: insert(x, ys)
}
\end{lstlisting}

\section{Definição da classe List I: Métodos de Primeira Ordem}
\label{sec:list-first-order}

Listas não são construídas em Scala; elas são definidas por uma classe abstrata
\code{List}, que vem com duas subclasses para \code{::} e \code{Nil}. A seguir
apresentaremos um tour através da classe \code{List}.

\begin{lstlisting}
package scala
abstract class List[+A] {
\end{lstlisting}

\code{List} é uma classe abstrata, logo não pode-se definir elementos 
chamando o construtor de \code{List} vazia (ou seja, através de \code{new List}).
A classe tem uma tipo parâmetro \code{a}. É covariante nesse parâmetro, o que 
significa que \code{List[S] <: List[T]} para todos os tipos \code{S} e \code{T} tal que 
\code{S <: T}. A classe está no pacote \code{scala}. Este pacote contém as mais 
importantes classes Scala. \code{List} define um número de métodos, que são explicados a seguir.

\paragraph{Decompondo listas}
Primeiro, há os três métodos básicos \code{isEmpty}, \code{head}, \code{tail}.
Suas implementações em termos de casamento de padrões são diretas:
\begin{lstlisting}
def isEmpty: Boolean = this match {
  case Nil => true
  case x :: xs => false
}
def head: A = this match {
  case Nil => error("Nil.head")
  case x :: xs => x
}
def tail: List[A] = this match {
  case Nil => error("Nil.tail")
  case x :: xs => xs
}
\end{lstlisting}

A próxima função computa o tamanho de uma lista.
\begin{lstlisting}
def length: Int = this match {
  case Nil => 0
  case x :: xs => 1 + xs.length
}
\end{lstlisting}
\begin{exercise} Escreva uma versão recursiva de cauda de \code{length}.
\end{exercise}

As próximas duas funções são o complemento para \code{head} e \code{tail}.
\begin{lstlisting}
def last: A
def init: List[A]
\end{lstlisting}

\code{xs.last} retorna o último elemento da lista \code{xs}, enquanto 
\code{xs.init} retorna todos os elementos de \code{xs} exceto o último.
Ambas as funções tem de atravessar toda a lista, e são, portanto, menos 
eficientes que seus análogos \code{head} e \code{tail}.
Aqui está a implementação de \code{last}.
\begin{lstlisting}
def last: A = this match {
  case Nil      => error("Nil.last")
  case x :: Nil => x
  case x :: xs  => xs.last
}
\end{lstlisting}
A implementação de \code{init} é análoga.

As próximas três funções retornam um prefixo da lista, ou um sufixo, ou ambos.
\begin{lstlisting}
def take(n: Int): List[A] =
  if (n == 0 || isEmpty) Nil else head :: tail.take(n-1)

def drop(n: Int): List[A] =
  if (n == 0 || isEmpty) this else tail.drop(n-1)

def split(n: Int): (List[A], List[A]) = (take(n), drop(n))
\end{lstlisting}
\code{(xs take n)} retorna os primeiros \code{n} elementos da lista 
\code{xs}, ou a lista inteira, caso seu tamanho seja menor que \code{n}.
\code{(xs drop n)} retorna todos os elementos de \code{xs} exceto os 
\code{n} primeiros. Finalmente, \code{(xs split n)} retorna um par
consistindo das listas resultantes de \code{xs take n} e \code{xs drop n}.

A próxima função retorna um elemento de uma dada posição na lista.
É, portanto, análoga ao subscrito de vetor. Índices começam em 0. 
\begin{lstlisting}
def apply(n: Int): A = drop(n).head
\end{lstlisting}
O método \code{apply} tem um significado especial em Scala. Um objeto com 
um método \code{apply} pode ser aplicado a argumentos como se fosse uma função.
Por exemplo, para pegar o terceiro elemento de uma lista \code{xs}, pode-se 
escrever ou \code{xs.apply(3)} ou \code{xs(3)}---a última expressão expande na primeira.

Com \code{take} e \code{drop}, podemos extrair sublistas consistindo de elementos 
consecutivos da lista original. Para extrair a sublista $xs_m \commadots xs_{n-1}$ da
lista \code{xs}, use:

\begin{lstlisting}
xs.drop(m).take(n - m)
\end{lstlisting}

\paragraph{Zipando listas} A próxima função combina duas listas em uma lista de pares.
Dadas duas listas
\begin{lstlisting}
xs = List(x$_1$, ..., x$_n$)   $\mbox{\rm, e}$
ys = List(y$_1$, ..., y$_n$)   ,
\end{lstlisting}

\code{xs zip ys} constrói a lista \lstinline@List((x$_1$, y$_1$), ..., (x$_n$, y$_n$))@.
Se as duas listas tiverem tamanhos diferentes, a maior das duas é truncada. Aqui está 
a definição de \code{zip}---observe que trata-se de um método polimórfico. 

\begin{lstlisting}
def zip[B](that: List[B]): List[(a,b)] =
  if (this.isEmpty || that.isEmpty) Nil
  else (this.head, that.head) :: (this.tail zip that.tail)
\end{lstlisting}

\paragraph{Consing listas.}

Como qualquer outro operador infixo, \code{::} também é implementado como um 
método de um objeto. Neste caso, o objeto é a lista que é estendida. Isto é 
possível porque operadores terminados com um caracter `\code{:}' são tratados
de modo especial em Scala. Todos esses operadores são tratados como métodos 
de seus operandos direitos. Ou seja, 
\begin{lstlisting}
    x :: y = y.::(x)       $\mbox{\rm enquanto que}$       x + y = x.+(y)                  
\end{lstlisting}
Observe, entretanto, que operandos de uma operação binária são em cada caso
avaliados da esquerda para a direita. Logo, se \code{D} e \code{E} são 
expressões com possíveis efeitos colaterais, \code{D :: E} é traduzido para 
\lstinline@{val x = D; E.::(x)}@ de modo a manter a ordem esquerda-para-direita
da avaliação dos operandos.

Outra diferença entre operadores terminando com um `\code{:}' e outros 
operadores é concernente à associatividade. Operadores terminados com 
`\code{:}' são associativos à direita, enquanto outros operadores são 
associativos à esquerda. Isto é,
\begin{lstlisting}
    x :: y :: z = x :: (y :: z)   $\mbox{\rm enquanto que}$    x + y + z = (x + y) + z
\end{lstlisting}


A definição de \code{::} como um método na classe \code{List} é a seguinte:
\begin{lstlisting}
def ::[B >: A](x: B): List[B] = new scala.::(x, this)
\end{lstlisting}
Observe que \code{::} é definido para todos os elementos \code{x} de tipo
\code{B} e listas do tipo \code{List[A]} tais como o tipo \code{B} de \code{x} é 
um supertipo dos elementos da lista de tipo \code{A}. O resultado neste caso é 
uma lista de \code{B}s. Isto é expresso pelo tipo parâmetro \code{B} com ligação 
fraca \code{A} na assinatura de \code{::}.


\paragraph{Concatenando listas}
Uma operação similar a \code{::} é a concatenação de listas, escrita `\code{:::}'.
O resultado de \code{(xs ::: ys)} é uma lista consistindo de todos os elementos 
de \code{xs}, seguidos para todos os elementos de \code{ys}. Como termina em dois pontos, 
\code{:::} é associativo à direita e é considerado método de seu operando direito. Por isso,
\begin{lstlisting}
xs ::: ys ::: zs  =   xs ::: (ys ::: zs)
                  =   zs.:::(ys).:::(xs)
\end{lstlisting}
Aqui está a implementação do método \code{:::}:
\begin{lstlisting}
  def :::[B >: A](prefix: List[B]): List[B] = prefix match {
    case Nil => this
    case p :: ps => this.:::(ps).::(p)
  }
\end{lstlisting}

\paragraph{Invertendo listas} 
Outra operação útil é a inversão de lista. Há um método \code{reverse} em \code{List}
que tem esse efeito. Vamos tentar dar a implementação:
\begin{lstlisting}
def reverse[A](xs: List[A]): List[A] = xs match {
  case Nil => Nil
  case x :: xs => reverse(xs) ::: List(x)
}
\end{lstlisting}
Esta implementação tem a vantagem de ser mais simples, mas não é muito eficiente. 
Na verdade, uma concatenação é feita para cada elemento da lista. Concatenação de listas
leva tempo proporcional ao tamanho do seu primeiro operando. Consequentemente, a complexidade
de \code{reverse(xs)} é 
\[
n + (n - 1) + ... + 1 = n(n+1)/2
\]
onde $n$ é o tamanho de \code{xs}. Pode-se implementar \code{reverse} mais eficientemente? 
Veremos mais tarde que há uma outra implementação que tem complexidade linear.

\section{Exemplo: Merge sort}

O insertion sort apresentado anteriormente neste capítulo é simples de formular, mas também não 
é muito eficiente. Sua complexidade média é proporcional ao quadrado do tamanho de sua lista 
de entrata. Agora escreveremos um programa para ordenar os elementos de uma lista que é mais 
eficiente que o insertion sort. Um bom algoritmo para isso é {\em merge sort}, que trabalha 
do seguinte modo.

Primeiro, se a lista tem zero ou um elementos, já está ordenada, logo retornamos a lista sem 
modificações. Listas mais longas são divididas em duas sublistas, cada uma contendo por volta
de metade dos elementos da lista original. Cada sublista é ordenada através de uma chamada 
recursiva para a função de ordenação, e as duas listas ordenadas resultantes são então 
combinadas em uma operação merge. 

Para uma implementação geral do merge sort, ainda temos que especificar o tipo dos elementos da lista 
a ser ordenada, bem como a função a ser usada na comparação dos elementos. Obtemos uma função de 
generalidade maximal passando estes dois itens como parâmetros. Isto leva a seguinte implementação.
\begin{lstlisting}
def msort[A](less: (A, A) => Boolean)(xs: List[A]): List[A] = {
  def merge(xs1: List[A], xs2: List[A]): List[A] =
    if (xs1.isEmpty) xs2
    else if (xs2.isEmpty) xs1
    else if (less(xs1.head, xs2.head)) xs1.head :: merge(xs1.tail, xs2)
    else xs2.head :: merge(xs1, xs2.tail)
  val n = xs.length/2
  if (n == 0) xs
  else merge(msort(less)(xs take n), msort(less)(xs drop n))
}
\end{lstlisting}

A complexidade do \code{msort} é $O(N;log(N))$, onde $N$ é o tamanho da lista de entrada.
Para ver porque, observe que dividir uma lista em duas e intercalar as duas listas 
ordenadas leva tempo proporcional ao tamanho das listas argumentos. Cada chamada recursiva 
de \code{msort} reduz a metade o número de elementos na sua entrada, logo há $O(log(N))$
chamadas recursivas consecutivas, até que o caso base das listas de tamanho 1 seja 
alcançado. Entretanto, para listas mais longas, cada chamada gera duas outras chamadas. 
Somando tudo acima obtemos que a cada nível $O(log(N))$ de chamada, cada elemento da lista 
original toma parte em uma operação de divisão e em uma operação merge. Consequentemente, cada 
nível de chamada tem um custo proporcional total de $O(N)$. Como há $O(log(N))$ níveis de
chamada, obtemos um custo total de $O(N;log(N))$. Este custo não depende da distribuição 
inicial dos elementos na lista, portanto o pior caso tem o mesmo custo que o caso médio.
Isto torna o merge sort um algoritmo atraente para ordenação de listas. 

Aqui está um exemplo de como \code{msort} é usado.
\begin{lstlisting}
msort((x: Int, y: Int) => x < y)(List(5, 7, 1, 3))
\end{lstlisting}
A definição de \code{msort} está currificada para tornar sua especialização com funções de  
comparação. Por exemplo,
\begin{lstlisting}
val intSort = msort((x: Int, y: Int) => x < y)
val reverseSort = msort((x: Int, y: Int) => x > y)
\end{lstlisting}

\section{Definição da classe List II: Métodos de Alta Ordem}
Os exemplos encontrados até aqui mostram que funções sobre listas frequentemente 
tem estruturas similares. Podemos identificar vários padrões de computação sobre
listas, tais como:

\begin{itemize}
        \item transformar cada elemento de uma lista de algum modo.
        \item extrair de uma lista todos os elementos que satisfaçam uma critério.
        \item combinar os elementos de uma lista usando algum operador.
\end{itemize}
Linguagens de programação funcional habilitam programadores a escrever funções genéricas
que implementam padrões como estes por meio de funções de alta ordem. Agora discutiremos
um conjunto comumente usado em funções de alta ordem, que são implementados como métodos 
dentro da classe \code{List}. 
\paragraph{Mapping sobre listas}
Um operação comum é transformar cada elemento de uma lista e então retornar a lista de
resultados. Por exemplo, para multiplicar cada elemento de uma lista por um dado fator.
\begin{lstlisting}
def scaleList(xs: List[Double], factor: Double): List[Double] = xs match {
  case Nil => xs
  case x :: xs1 => x * factor :: scaleList(xs1, factor)
}
\end{lstlisting}
Este padrão pode ser generalizado para o método \code{map} da classe \code{List}:
\begin{lstlisting}
abstract class List[A] { ...
  def map[B](f: A => B): List[B] = this match {
    case Nil => this
    case x :: xs => f(x) :: xs.map(f)
  }
\end{lstlisting}
Usando \code{map}, \code{scaleList} pode ser mais concisamente escrito como segue.
\begin{lstlisting}
def scaleList(xs: List[Double], factor: Double) =
  xs map (x => x * factor)
\end{lstlisting}

Como outro exemplo, considere o problema de retornar uma dada coluna de uma matriz 
que é representada como uma lista de linhas, onde cada linha é novamente uma lista. 
Isto é feito através da seguinte função \code{column}. 

\begin{lstlisting}
def column[A](xs: List[List[A]], index: Int): List[A] =
  xs map (row => row(index))
\end{lstlisting}

Um método similar a \code{map} é o método \code{foreach} que aplica uma dada função a todos 
os elementos de uma lista, mas não constrói uma lista de resultados. A função é assim aplicada
somente por seu efeito colateral. \code{foreach} é definido como segue. 
\begin{lstlisting}
  def foreach(f: A => Unit) {
    this match {
      case Nil => ()
      case x :: xs => f(x); xs.foreach(f)
    }
  }
\end{lstlisting}
Esta função pode ser usada para imprimir todos os elementos de uma lista, por exemplo:
\begin{lstlisting}
  xs foreach (x => println(x))
\end{lstlisting} 

\begin{exercise} 
Considere uma função que eleva ao quadrado todos os elementos de uma lista e retorna
uma lista com os resultados. Complete as duas definições a seguir de \code{squareList}.

\begin{lstlisting}
def squareList(xs: List[Int]): List[Int] = xs match {
  case List() => ??
  case y :: ys => ??
}
def squareList(xs: List[Int]): List[Int] =
  xs map ??
\end{lstlisting}
\end{exercise}

\paragraph{Filtrando Listas}

Outra operação comum seleciona de uma lista todos os elemento que satisfazem um dado 
critério. Por exemplo, para retornar uma lista de todos os elementos positivos de 
algumas listas dadas de inteiros:
\begin{lstlisting}
def posElems(xs: List[Int]): List[Int] = xs match {
  case Nil => xs
  case x :: xs1 => if (x > 0) x :: posElems(xs1) else posElems(xs1)
}
\end{lstlisting}
Este padrão é generalizado para o método \code{filter} da classe \code{List}:
\begin{lstlisting}
  def filter(p: A => Boolean): List[A] = this match {
    case Nil => this
    case x :: xs => if (p(x)) x :: xs.filter(p) else xs.filter(p)
  }
\end{lstlisting}
Usando \code{filter}, \code{posElems} pode ser mais concisamente escrito como segue.
\begin{lstlisting}
def posElems(xs: List[Int]): List[Int] =
  xs filter (x => x > 0)
\end{lstlisting}

Uma operação relacionada a filtering é testar se todos os elementos de uma lista satisfazem
uma dada condição. Dualmente, pode-se também estar interessado na questão se há um elemento 
em uma lista que satisfaz uma dada condição. Estas operações são incorporadas nas funções 
de alta ordem \code{forall} e \code{exists} da classe \code{List}.
\begin{lstlisting}
def forall(p: A => Boolean): Boolean =
  isEmpty || (p(head) && (tail forall p))
def exists(p: A => Boolean): Boolean =
  !isEmpty && (p(head) || (tail exists p))
\end{lstlisting}

Para ilustrar o uso de \code{forall}, considere a questão se um número é primo. Lembre que um
número $n$ é primo se puder ser dividido, sem resto, somente por um e por ele mesmo. A 
tradução mais direta desta definição testará se $n$ dividido por todos os números de $2$ até, mas 
excluindo, ele mesmo dá resto diferente de zero. Esta lista de números pode ser gerada usando uma 
função \code{List.range} que é definida no objeto \code{List} como segue. 
\begin{lstlisting}
package scala
object List { ...
  def range(from: Int, end: Int): List[Int] =
    if (from >= end) Nil else from :: range(from + 1, end)
\end{lstlisting}

Por exemplo, \code{List.range(2, n)} gera a lista de todos os inteiros de $2$ até, excluindo, $n$.
A função \code{isPrime} pode agora ser defida como segue. 
\begin{lstlisting}
def isPrime(n: Int) =
  List.range(2, n) forall (x => n % x != 0)
\end{lstlisting}
Vemos que a definição matemática de primalidade pode ser traduzida diretamente em código Scala.

Exercício: Defina \code{forall} e \code{exists} em termos de \code{filter}.

\paragraph{Desdobrando (folding) e Reduzindo Listas}
Uma outra operação comum é combinar os elementos de uma lista com algum operador. Por exemplo:
\begin{lstlisting}
sum(List(x$_1$, ..., x$_n$))       =  0 + x$_1$ + ... + x$_n$
product(List(x$_1$, ..., x$_n$))   =  1 * x$_1$ * ... * x$_n$
\end{lstlisting}

De fato, podemos implementar ambas as funções por meio de um esquema recursivo:
\begin{lstlisting}
def sum(xs: List[Int]): Int = xs match {
  case Nil => 0
  case y :: ys => y + sum(ys)
}
def product(xs: List[Int]): Int = xs match {
  case Nil => 1
  case y :: ys => y * product(ys)
}
\end{lstlisting}

Mas também podemos usar a generalização deste esquema de programa incorporado no método 
\code{reduceLeft} da classe \code{List}. Este método insere um dado operador binário entre
elementos adjacentes de uma dada lista. Ou seja, 
\begin{lstlisting}
List(x$_1$, ..., x$_n$).reduceLeft(op) = (...(x$_1$ op x$_2$) op ... ) op x$_n$
\end{lstlisting}
Usando \code{reduceLeft}, podemos tornar o padrão comum emas \code{sum} e \code{product}
aparente:
\begin{lstlisting}
def sum(xs: List[Int])      =  (0 :: xs) reduceLeft {(x, y) => x + y}
def product(xs: List[Int])  =  (1 :: xs) reduceLeft {(x, y) => x * y}
\end{lstlisting}
Aqui está a implementação de \code{reduceLeft}.
\begin{lstlisting}
  def reduceLeft(op: (A, A) => A): A = this match {
    case Nil     => error("Nil.reduceLeft")
    case x :: xs => (xs foldLeft x)(op)
  }
  def foldLeft[B](z: B)(op: (B, A) => B): B = this match {
    case Nil => z
    case x :: xs => (xs foldLeft op(z, x))(op)
  }
}
\end{lstlisting}

Vemos que o método \code{reduceLeft} é definido em termos de um outro método, geralmente útil, 
\code{foldLeft}. O último pega como parâmetro adicional um {\em acumulador} \code{z}, que é 
retornado quando \code{foldLeft} é aplicado sobre uma lista vazia. Ou seja, 
\begin{lstlisting}
(List(x$_1$, ..., x$_n$) foldLeft z)(op)   =  (...(z op x$_1$) op ... ) op x$_n$
\end{lstlisting}
Os métodos \code{sum} e \code{product} podem ser defidos alternativamente usando \code{foldLeft}:
\begin{lstlisting}
def sum(xs: List[Int])      =  (xs foldLeft 0) {(x, y) => x + y}
def product(xs: List[Int])  =  (xs foldLeft 1) {(x, y) => x * y}
\end{lstlisting}

\paragraph{FoldRight e ReduceRight}
Aplicações de \code{foldLeft} e \code{reduceLeft} expandem para árvores inclinadas à esquerda. 
\todo{insert pictures}. Eles têm duals \code{foldRight} e \code{reduceRight} que produzem 
árvores inclinadas à direita.
\begin{lstlisting}
List(x$_1$, ..., x$_n$).reduceRight(op)     =  x$_1$ op ( ... (x$_{n-1}$ op x$_n$)...)
(List(x$_1$, ..., x$_n$) foldRight acc)(op) =  x$_1$ op ( ... (x$_n$ op acc)...)
\end{lstlisting}
Estes são definidos como segue.
\begin{lstlisting}
  def reduceRight(op: (A, A) => A): A = this match {
    case Nil => error("Nil.reduceRight")
    case x :: Nil => x
    case x :: xs => op(x, xs.reduceRight(op))
  }
  def foldRight[B](z: B)(op: (A, B) => B): B = this match {
    case Nil => z
    case x :: xs => op(x, (xs foldRight z)(op))
  }
\end{lstlisting}
A classe  \code{List} define também duas abreviaturas simbólicas para \code{foldLeft}
e \code{foldRight}:
\begin{lstlisting}
  def /:[B](z: B)(f: (B, A) => B): B = foldLeft(z)(f)
  def :\[B](z: B)(f: (A, B) => B): B = foldRight(z)(f)
\end{lstlisting}
Os nomes dos métodos ilustram a inclinação à esquerda/direita das árvores das operações 
fold através de barra simples ou invertida. O \code{:} aponta em cada caso para a lista 
de argumentos enquanto o fim da barra aponta para o acumulador (ou: zero) argumento \code{z}.
Ou seja,  
\begin{lstlisting}
(z /: List(x$_1$, ..., x$_n$))(op) = (...(z op x$_1$) op ... ) op x$_n$ 
(List(x$_1$, ..., x$_n$) :\ z)(op) = x$_1$ op ( ... (x$_n$ op z)...)
\end{lstlisting}
Através de operadores associativos e comutativos, \code{/:} e \code{:\\} são equivalentes
(mesmo sabendo que podem ser diferentes em eficiência).

%But sometimes, only one of the two operators is
%appropriate or has the right type:

\begin{exercise} Considere o problema de escrever uma função \code{flatten}, que recebe 
uma lista de listas como argumentos. O resultado de \code{flatten} deve ser a concatenação 
de todos os elementos listas em uma única lista. Aqui está uma implementação deste método 
em termos de 
\code{:\\}.
\begin{lstlisting}
def flatten[A](xs: List[List[A]]): List[A] =
  (xs :\ (Nil: List[A])) {(x, xs) => x ::: xs}
\end{lstlisting} 
Considere substituir o corpo de  \lstinline@flatten@ por 
\begin{lstlisting}
  ((Nil: List[A]) /: xs) ((xs, x) => xs ::: x)
\end{lstlisting}
Qual a diferença na complexidade assintótica entre as duas versões de \lstinline@flatten@? 

De fato \code{flatten} é predefinido junto com um conjunto de outras funções úteis no objeto 
chamado \code{List} na biblioteca padrão Scala. Pode ser acessado de um programa usuário 
chamando \code{List.flatten}. Observe que \code{flatten} não é um método da classe
\code{List}---não faz sentido, pois aplica-se somente a listas de listas, não a todas as
listas em geral. 

\end{exercise}

\paragraph{Novamente Inversão de Lista} Vimos na Seção~\ref{sec:list-first-order} uma 
implementação do método \code{reverse} cujo tempo de execução era quadrático para o 
tamanho da lista a ser invertida. Agora desenvolveremos uma nova implementação de
\code{reverse}, cujo custo é linear. A idéia é usar uma operação \code{foldLeft} 
baseada no seguinte programa scheme.
\begin{lstlisting}
class List[+A] { ...
  def reverse: List[A] = (z? /: this)(op?)
\end{lstlisting}


Agora falta preencher \code{z?} e \code{op?}. Vamos tentar deduzir a partir dos exemplos.
\begin{lstlisting}
  Nil
= Nil.reverse                 // pela especifica\c{c}\~{a}o 
= (z /: Nil)(op)              // pelo template para reverse
= (Nil foldLeft z)(op)        // pela defini\c{c}\~{a}o de /:
= z                           // pela defini\c{c}\~{a}o de foldLeft
\end{lstlisting}
Consequentemente, \code{z?} deve ser \code{Nil}. Para deduzir o segundo operando, vamos estudar
o inverso de uma lista de tamanho um.
\begin{lstlisting}
  List(x)
= List(x).reverse             // pela especifica\c{c}\~{a}o 
= (Nil /: List(x))(op)        // pelo template para reverse, com  z = Nil
= (List(x) foldLeft Nil)(op)  // pela defini\c{c}\~{a}o de /:
= op(Nil, x)                  // pela defini\c{c}\~{a}o de foldLeft
\end{lstlisting}
Consequentemente, \code{op(Nil, x)} é igual a \code{List(x)}, o que é o mesmo que \code{x :: Nil}.
Isto sugere pegar como \code{op} o operador \code{::} com seus operandos trocados. Consequentemente,
chegamos a seguinte implementação para \code{reverse}, que tem complexidade linear.
\begin{lstlisting}
def reverse: List[A] =
  ((Nil: List[A]) /: this) {(xs, x) => x :: xs}
\end{lstlisting}
(Obs: O tipo de anotação para \code{Nil} é necessário para que a inferência de tipos funcione.)

\begin{exercise} Preencha as expressões faltantes para completar as seguintes definições de 
algumas operações básicas de manipulação de listas como operações fold. 
\begin{lstlisting}
def mapFun[A, B](xs: List[A], f: A => B): List[B] =
  (xs :\ List[B]()){ ?? }

def lengthFun[A](xs: List[A]): int =
  (0 /: xs){ ?? }
\end{lstlisting}
\end{exercise}


\paragraph{Mapeamentos Aninhados}

Podemos empregar funções de processamento de listas de alta ordem para expressar muita
computação que, normalmente é expressa através de aninhamento de laços nas linguagens imperativas.

Como exemplo, considere o seguinte problema: Dado um inteiro positivo $n$, encontre todos os pares
de inteiros positivos $i$ e $j$, onde $1 \leq j < i < n$ tal que $i + j$ seja primo. Por exemplo, 
se $n= 7$, os pares são 
\bda{c|lllllll}
i     & 2 & 3 & 4 & 4 & 5 & 6 & 6\\
j     & 1 & 2 & 1 & 3 & 2 & 1 & 5\\ \hline
i + j & 3 & 5 & 5 & 7 & 7 & 7 & 11
\eda

Um modo natural de resolver este problema consiste em dois passos. Num primeiro passo, gera-se
a sequência de todos os pares $(i, j)$ de inteiros tal que $1 \leq j < i < n$. Num segundo passo
filtra-se, a partir desta sequência, todos os pares $(i,j)$ tal que $i + j$ é primo.

Examinando o primeiro passo em detalhe, um modo natural de gerar a sequência de pares consiste
de três sub-passos. Primeiro, gera-se todos os inteiros entre $1$ e $n$ para $i$.

Segundo, para cada inteiro $i$ entre $1$ e $n$, gera-se a lista de pares $(i, 1)$ up to $(i, i-1)$. 
Isso pode ser conseguido através de uma combinação de \code{range} e \code{map}:
\begin{lstlisting}
  List.range(1, i) map (x => (i, x))
\end{lstlisting}

Finalmente, combina-se todas as sublistas usando \code{foldRight} com \code{:::}. Juntando tudo
dá a seguinte expressão:
\begin{lstlisting}
List.range(1, n)
  .map(i => List.range(1, i).map(x => (i, x)))
  .foldRight(List[(Int, Int)]()) {(xs, ys) => xs ::: ys}
  .filter(pair => isPrime(pair._1 + pair._2))
\end{lstlisting}

\paragraph{Flattening Maps}

A combinação entre mapeamento e a concatenação das sublistas resultantes do mapeamento é tão comum 
que há um método especial para isto na classe \code{List}:
\begin{lstlisting}
abstract class List[+A] { ...
  def flatMap[B](f: A => List[B]): List[B] = this match {
    case Nil => Nil
    case x :: xs => f(x) ::: (xs flatMap f)
  }
}
\end{lstlisting}
Com \code{flatMap}, os expressão dos ``pares cuja soma dá um primo'' pode ser escrita de modo mais
sucinto como segue.
\begin{lstlisting}
List.range(1, n)
  .flatMap(i => List.range(1, i).map(x => (i, x)))
  .filter(pair => isPrime(pair._1 + pair._2))
\end{lstlisting}



\section{Sumário}

Este capítulo introduziu listas como uma estrutura de dados fundamental na programação. Como listas 
são imutáveis, elas são um tipo de dado comum na programação em linguagens funcionais. Elas têm 
importância comparável a vetores nas linguagens imperativas. Entretanto, o padrão de acesso é bem diferente 
entre os dois. Enquanto o acesso em vetores é sempre feito através de indexação, isto é muito incomum em 
listas. Nós vimos que \code{scala.List} define um método chamado \code{apply} para a indexação, entretanto, 
esta operação é muito mais custosa que no caso dos vetores (linear em comparação a tempo constante). Ao
invés da indexação, listas são geralmente percorridas recursivamente, onde passos recursivos são em geral
baseados em casamento de padrões sobre a lista percorrida. Há também um rico conjunto de combinadores de
alta ordem que permitem a instanciação de um conjunto de padrões pré-definidos de computações sobre listas.

\comment{
\bsh{Pensando sobre Listas}

Lembre da operação de concatenação para listas:

\begin{lstlisting}
class List[+A] {
  ...
  def ::: (that: List[A]): List[A] =
    if (isEmpty) that
    else head :: (tail ::: that)
}
\end{lstlisting}

We would like to verify that concatenation is associative, with the
empty list \code{List()} as left and right identity:

Poderíamos querer verificar que a concatenação é associativa, com a lista vazia \code{List()} como 
identidade esquerda e direita:
\bda{lcl}
   (xs ::: ys) ::: zs &=& xs ::: (ys ::: zs) \\
   xs ::: List()          &=& xs \gap =\ List() ::: xs
\eda
\emph{Q}: Como podemos provar declarações como a expressa acima?

\emph{R}: Através de \emph{indução estrutural} sobre listas.
\es
\bsh{Lembrete: Indução Natural}

Lembrando o princípio da prova por \emph{indução natural}:

Para mostrar uma propriedade \mathtext{P(n)} para todos os números \mathtext{n \geq b}:
\be
\item Mostre que \mathtext{P(b)} vale para o (\emph{caso base}).
\item Para \mathtext{n \geq b} arbitrários, mostre:
\begin{quote}
     se vale \mathtext{P(n)}, então \mathtext{P(n+1)} também vale
\end{quote}
(\emph{passo indutivo}).
\ee
%\es\bs
\emph{Examplo}: Dado
\begin{lstlisting}
def factorial(n: Int): Int =
  if (n == 0) 1
  else n * factorial(n-1)
\end{lstlisting}
mostre que, para todos \code{n >= 4},
\begin{lstlisting}
   factorial(n) >= 2$^n$
\end{lstlisting}
\es\bs
\Case{\code{4}}
é estabelecido pelo simples cálculo de \code{factorial(4) = 24} e \code{2$^4$ = 16}.
\Case{\code{n+1}} 
Temos para \code{n >= 4}:
\begin{lstlisting}
    \= factorial(n + 1)
 =     \> $\expl{pela segundo cláusula de factorial(*)}$
       \> (n + 1) * factorial(n)
 >=    \> $\expl{pelo cálculo}$
       \> 2 * factorial(n)
 >=    \> $\expl{pela hipótese de indução}$
       \> 2 * 2$^n$.
\end{lstlisting}
Observe que em nossa prova podemos aplicar livremente passos de redução tais como em (*) qualquer lugar do termo.

Isto funciona porque programas puramente funcionais não têm efeitos colaterais; logo um termo é equivalente 
ao termo a que se reduz.
O princípio é chamado  {\em\emph{transparência referencial}}.

\es
\bsh{Indução Estrutural}

O princípio da indução estrutural é análogo à indução natural:

No caso de listas, funciona como segue:

Para provar uma propriedade \mathtext{P(xs)} para todas as listas  \mathtext{xs},

\be
\item Mostre que \code{P(List())} vale no (\emph{caso base}).
\item Para listas arbitrárias \mathtext{xs} e elementos \mathtext{x}, mostre: 
\begin{quote}
     se \mathtext{P(xs)} vale, então \mathtext{P(x :: xs)} também vale.
\end{quote}
(\emph{passo indutivo}).
\ee

\es
\bsh{Exemplo}

Mostramos \code{(xs ::: ys) ::: zs  =  xs ::: (ys ::: zs)} através de indução estrutural sobre \code{xs}.

\Case{\code{List()}}
Para a parte esquerda, temos:
\begin{lstlisting}
    \= (List() ::: ys) ::: zs
 =     \> $\expl{pela primeira cláusula de \prog{:::}}$
       \> ys ::: zs
\end{lstlisting}
Para a parte direita, temos:
\begin{lstlisting}
    \= List() ::: (ys ::: zs)
 =     \> $\expl{pela primeira cláusula de \prog{:::}}$
       \> ys ::: zs
\end{lstlisting}
Então, o case é estabelecido.

\es
\bs
\Case{\code{x :: xs}} 

Para a parte esquerda, temos:
\begin{lstlisting}
    \= ((x :: xs) ::: ys) ::: zs
 =     \> $\expl{pela segunda cláusula de \prog{:::}}$
       \> (x :: (xs ::: ys)) ::: zs
 =     \> $\expl{pela segunda cláusula de \prog{:::}}$
       \> x :: ((xs ::: ys) ::: zs)
 =     \> $\expl{pela hipótese de indução}$
       \> x :: (xs ::: (ys ::: zs))
\end{lstlisting}

Para a parte direita, temos:
\begin{lstlisting}
    \= (x :: xs) ::: (ys ::: zs)
 =     \> $\expl{pela segunda cláusula de \prog{:::}}$
       \> x :: (xs ::: (ys ::: zs))
\end{lstlisting}
Então, o case (e com ele a propriedade) é estabelecido.
\begin{exercise}
%% Show by induction on \code{xs} that \code{xs ::: List()  =  xs}.
Mostre por indu\c{c}\~{a}o que dado \code{xs} temos \code{xs ::: List() = xs}. 
\es
\bsh{Example (2)}
\end{exercise}

Como um exemplo mais dif\'{i}cil, considere a fun\c{c}\~{a}o
\begin{lstlisting}
abstract class List[A] { ...
  def reverse: List[A] = this match {
    case List() => List()
    case x :: xs => xs.reverse ::: List(x)
  }
}
\end{lstlisting}
Gostaríamos de provar a proposição 
\begin{lstlisting}
   xs.reverse.reverse  =  xs  .
\end{lstlisting}
Procedemos por indução sobre \code{xs}. O caso base é fácil de se estabelecer:
\begin{lstlisting}
    \= List().reverse.reverse
 =     \> $\expl{pela primeira cláusula de \prog{reverse}}$
       \> List().reverse
 =     \> $\expl{pela primeira cláusula de \prog{reverse}}$
       \> List()
\end{lstlisting}
\es\bs
Para o passo indutivo, tentamos:
\begin{lstlisting}
    \= (x :: xs).reverse.reverse
 =     \> $\expl{pela segunda cláusula de \prog{reverse}}$
       \> (xs.reverse ::: List(x)).reverse
\end{lstlisting}
Não há nada mais o que se fazer com esta expressão, logo nos voltamos para a parte direita:
\begin{lstlisting}
    \= x :: xs
 =     \> $\expl{pela hipótese indutiva}$
       \> x :: xs.reverse.reverse
\end{lstlisting}
Os dois lados foram simplificados para expressões diferentes.
Portanto, ainda temos que mostrar que 
\begin{lstlisting}
  (xs.reverse ::: List(x)).reverse  =  x :: xs.reverse.reverse
\end{lstlisting}
Tentar provar isto diretamente através de indução não funciona.

Ao invés, temos que {\em generalizar} a equação para:
\begin{lstlisting}
  (ys ::: List(x)).reverse  =  x :: ys.reverse
\end{lstlisting}
\es\bs
Esta equação pode ser provada por um segundo argumento indutivo sobre \code{ys}.
(Veja o blackboard).

\begin{exercise}
No caso em que \code{(xs drop m) at n  =  xs at (m + n)} para todos os números naturais \code{m}, 
\code{n} e todas as listas \code{xs}?
\end{exercise}

\es
\bsh{Indução Estrutural sobre Árvores}

Indução estrutural não se restringe à listas; funciona para árvores arbitrárias.

O princípio geral de indução é como segue.

Para mostrar que a propriedade \code{P(t)} vale para todas as árvores de um certo tipo,
\begin{itemize}
\item Mostre \code{P(l)} para todas as folhas das árvores \code{$l$}.
\item Para cada nó interno \code{t} com subárvores \code{s$_1$, ..., s$_n$},
      mostre que  \code{P(s$_1$) $\wedge$ ... $\wedge$ P(s$_n$) => P(t)}. 
\end{itemize} 

\example Lembre de nossa definição de \code{IntSet} com operações \code{contains} e \code{incl}:

\begin{lstlisting}
abstract class IntSet {
  abstract def incl(x: Int): IntSet
  abstract def contains(x: Int): Boolean
}
\end{lstlisting}
\es\bs
\begin{lstlisting}
case class Empty extends IntSet {
  def contains(x: Int): Boolean = false
  def incl(x: Int): IntSet = NonEmpty(x, Empty, Empty)
}
case class NonEmpty(elem: Int, left: Set, right: Set) extends IntSet {
  def contains(x: Int): Boolean =
    if (x < elem) left contains x
    else if (x > elem) right contains x
    else true
  def incl(x: Int): IntSet =
    if (x < elem) NonEmpty(elem, left incl x, right)
    else if (x > elem) NonEmpty(elem, left, right incl x)
    else this
}
\end{lstlisting}
(Com \code{case} adicionado, podemos usar métodos de fábrica ao invés de \code{new}).

O que significa provar a correção desta implementação?
\es
\bsh{Leis do IntSet}

Um modo de declarar e provar a correção de uma implementação é provar leis que valem para ela.


No caso de \code{IntSet}, três dessas leis serão:


Para todos os conjuntos \code{s}, elementos \code{x}, \code{y}:
\begin{lstlisting}
Empty contains x          \= =  false
(s incl x) contains x     \> =  true
(s incl x) contains y     \> =  s contains y         if x $\neq$ y
\end{lstlisting}

(De fato, podemos mostrar que estas leis caracterizam o tipo de dado desejado completamente).
Como podemos estabelecer que essas leis valem?

\emph{Proposition 1}: \code{Empty contains x =  false}.

\emph{Proof}: Pela definição de \code{contains} in \code{Empty}.
\es\bs
\emph{Proposition 2}: \code{(xs incl x) contains x = true}

\emph{Proof:}

\Case{\code{Empty}}
\begin{lstlisting}
    \= (Empty incl x) contains x
 =     \> $\expl{by definition of \prog{incl} in \prog{Empty}}$
       \> NonEmpty(x, Empty, Empty) contains x
 =     \> $\expl{by definition of \prog{contains} in \prog{NonEmpty}}$
       \> true
\end{lstlisting}

\Case{\code{NonEmpty(x, l, r)}}
\begin{lstlisting}
    \= (NonEmpty(x, l, r) incl x) contains x
 =     \> $\expl{by definition of \prog{incl} in \prog{NonEmpty}}$
       \> NonEmpty(x, l, r) contains x
 =     \> $\expl{by definition of \prog{contains} in \prog{Empty}}$
       \> true
\end{lstlisting}
\es\bs
\Case{\code{NonEmpty(y, l, r)} where \code{y < x}}
\begin{lstlisting}
    \= (NonEmpty(y, l, r) incl x) contains x
 =     \> $\expl{by definition of \prog{incl} in \prog{NonEmpty}}$
       \> NonEmpty(y, l, r incl x) contains x
 =     \> $\expl{by definition of \prog{contains} in \prog{NonEmpty}}$
       \> (r incl x) contains x
 =     \> $\expl{by the induction hypothesis}$
       \> true
\end{lstlisting}

\Case{\code{NonEmpty(y, l, r)} where \code{y > x}} is analogous.

\bigskip

\emph{Proposition 3}: If \code{x $\neq$ y} then
\code{xs incl y contains x  =  xs contains x}.

\emph{Proof:} Veja o blackboard.
\es
\bsh{Exercise}

Digamos que adicionamos a função \code{union} à  \code{IntSet}:
\begin{lstlisting}
class IntSet { ...
  def union(other: IntSet): IntSet
}
class Expty extends IntSet { ...
  def union(other: IntSet) = other
}
class NonEmpty(x: Int, l: IntSet, r: IntSet) extends IntSet { ...
  def union(other: IntSet): IntSet = l union r union other incl x
}
\end{lstlisting}
A correção de \code{union} pode ser incluída com a seguinte lei:

\emph{Proposição 4}: 
\code{(xs union ys) contains x  =  xs contains x || ys contains x}.

Será verdadeiro? Que hipótese está faltando? Mostre um contra-exemplo.

Mostre a Proposição 4 usando indução estrutural sobre \code{xs}.
\es
\comment{

\emph{Prova:} Por indução sobre \code{xs}.

\Case{\code{Empty}}

\Case{\code{NonEmpty(x, l, r)}}

\Case{\code{NonEmpty(y, l, r)} onde \code{y < x}}

\begin{lstlisting}
    \= (Empty union ys) contains x 
 =      \> $\expl{by definition of \prog{union} in \prog{Empty}}$
        \> ys contains x
 =      \> $\expl{Boolean algebra}$
        \> false || ys contains x
 =      \> $\expl{by definition of \prog{contains} in \prog{Empty} (reverse)}$
        \> (Empty contains x) || (ys contains x)
\end{lstlisting}

\begin{lstlisting}
    \= (NonEmpty(x, l, r) union ys) contains x
 =      \> $\expl{by definition of \prog{union} in \prog{NonEmpty}}$
        \> (l union r union ys incl x) contains x
 =      \> $\expl{by Proposition 2}$
        \> true
 =      \> $\expl{Boolean algebra}$
        \> true || (ys contains x)
 =      \> $\expl{by definition of \prog{contains} in \prog{NonEmpty} (reverse)}$
        \> (NonEmpty(x, l, r) contains x) || (ys contains x)
\end{lstlisting}

\begin{lstlisting}
    \= (NonEmpty(y, l, r) union ys) contains x
 =      \> $\expl{by definition of \prog{union} in \prog{NonEmpty}}$
        \> (l union r union ys incl y) contains x
 =      \> $\expl{by Proposition 3}$
        \> (l union r union ys) contains x
 =      \> $\expl{by the induction hypothesis}$
        \> ((l union r) contains x) || (ys contains x)
 =      \> $\expl{by Proposition 3}$
        \> ((l union r incl y) contains x) || (ys contains x)
\end{lstlisting}

\Case{\code{NonEmpty(y, l, r)} where \code{y < x}}
 ... é análogo.

\es
}}
\chapter{\label{sec:for-notation}For-Comprehensions}

O capítulo anterior mostrou que funções de alta ordem, tais como \verb@map@, \verb@flatMap@, \verb@filter@
provém poderosas construções para lidar com listas. Mas algumas vezes o nível de abstração requerido por 
estas funções tornam um programa difícil de entender.

Para ajudar a inteligibilidade, Scala tem uma notação especial que simplifica padrões comuns de aplicações 
de funções de alta ordem. Esta notação cria uma ponte entre abrangência de conjuntos (set-comprehensions) 
na matemática e laços for em linguagens imperativas tais como C ou Java. Também lembram de perto
a notação de pesquisa em bases de dados relacionais.  

Como um primeiro exemplo, digamos que nos é dada uma lista \code{persons} de pessoas com campos \code{name} 
e \code{age} (idade). Para imprimir os nomes de todas as pessoas na sequência para idades acima de $20$, 
pode-se escrever:
 
\begin{lstlisting}
for (p <- persons if p.age > 20) yield p.name
\end{lstlisting}
Isto é equivalente à seguinte expressão, que usa as funções de alta ordem \code{filter} e \code{map}: 
\begin{lstlisting}
persons filter (p => p.age > 20) map (p => p.name)
\end{lstlisting}
A abrangência for (for-comprehension) parece um pouco com um laço for nas linguagens imperativas, 
exceto que constrói uma lista de resultados de todas iterações.

Geralmente, um for-comprehension tem a forma
\begin{lstlisting}
for ( $s$ ) yield $e$
\end{lstlisting}

Aqui, $s$ é uma sequência de {\em geradores}, {\em definições} e {\em filtros}. Um {\em gerador} tem a 
forma \code{val x <- e}, onde \code{e} é uma expressão avaliada como lista. Liga \code{x} a sucessivos
valores na lista. Uma {\em definição} tem a forma \code{val x = e}. Introduz \code{x} como um nome para 
o valor de \code{e} no restante da abrangência. Um {\em filtro} é uma expressão \code{f} do tipo 
\code{Boolean}. Omite da consideração todas as ligações para as quais \code{f} é \code{falso}. A
sequência $s$ começa em caad case com um gerador. Se houver vários geradores na sequência, os geradores 
subsequentes variarão mais rapidamente que os anteriores.

A sequência $s$ pode também ser envolvida em chaves ao invés de parênteses, e os dois pontos 
entre geradores, definições e filtros podem ser omitidos. 

Aqui estão dois exemplos que mostram como for-comprehensions são usados. Primeiro, vamos refazer um 
exemplo do capítulo anterior: Dado um inteiro positivo $n$, encontre todos os pares de inteiros 
positivos $i$ e $j$, onde $1 \leq j < i < n$ such that $i + j$ é primo. Com um for-comprehension
este problema é resolvido como segue:
\begin{lstlisting}
for { i <- List.range(1, n)
      j <- List.range(1, i)
      if isPrime(i+j) } yield {i, j}
\end{lstlisting}

Isto é discutivelmente mais claro que a solução usando \code{map}, \code{flatMap} e \code{filter}
que desenvolvemos previamente.

Como segundo exemplo, considere calcular o produto escalar de dois vetores \code{xs} e \code{ys}. 
Usando um for-comprehension, isto pode ser escrito como segue.
\begin{lstlisting}
  sum(for ((x, y) <- xs zip ys) yield x * y)
\end{lstlisting}

\section{O Problema das N-Rainhas}

For-comprehensions são especialmente úteis para resolver puzzles combinatórios. Um exemplo é o problema 
das $8$-rainhas: Dado um tabuleiro de xadrez padrão, coloque $8$ rainhas, tal que nenhuma rainha
esteja atacada por nenhuma outra (uma rainha pode atacar qualquer outra peça se estiver na mesma coluna, 
linha ou diagonal que a mesma). Desenvolveremos agora uma solução para este problema, generalizando 
para tabuleiros de xadrez de tamanho arbitrário. Consequentemente, o problema é colocar $n$ rainhas 
em um tabuleiro de xadrez de tamanho $n \times n$.

Para resolver este problema, observe que precisamos colocar uma rainha em cada linha. 
Logo podemos colocar rainhas em linhas sucessivas, cada vez checando que uma rainha recentemente colocada
não esteja atacada por qualquer outra rainha que já se encontra no tabuleiro. No curso desta busca, pode 
acontecer que uma rainha a ser colocada na linha $k$ esteja atacada em todas as casas desta linha por rainhas
rainhas das linhas $1$ até $k-1$. Neste caso, precisamos interromper esta parte da busca e continuar com uma 
configuração diferente de rainhas nas colunas $1$ até $k-1$.

Isso sugere um algoritmo recursivo. Assuma que já geramos todas as soluções para colocar $k-1$ rainhas em
um tabuleiro de tamanho $n \times n$. Podemos representar tal solução por uma lista de tamanho $k-1$ de 
números das colunas (no intervalo de $1$ a $n$). Tratamos estas listas de soluções parciais como pilhas,
onde o número da coluna da rainha na linha $k-1$ vem primeiro dentro da lista, seguido pelo número da 
coluna da rainha na linha $k-2$ etc. O fundo da pilha é o número da coluna da rainha colocada na 
primeira linha do tabuleiro. Todas as soluções juntas são então representadas como uma lista de listas, 
com um elemento para cada solução.

Agora, para colocar a $k$-ésima rainha, geramos todas as possíveis extensões para cada solução prévia com uma 
rainha a mais. Isto leva a uma outra lista de listas soluções, desta vez de tamanho $k$. Continuamos o processo
até atingirmos soluções do tamanho $n$ do tabuleiro de xadrez. Esta idéia algorítmica é incorporada na 
função \code{placeQueens} abaixo: 

\begin{lstlisting}
def queens(n: Int): List[List[Int]] = {
  def placeQueens(k: Int): List[List[Int]] =
    if (k == 0) List(List())
    else for { queens <- placeQueens(k - 1)
               column <- List.range(1, n + 1)
               if isSafe(column, queens, 1) } yield column :: queens
  placeQueens(n)
}
\end{lstlisting}

\begin{exercise} Escreva a função 
\begin{lstlisting}
  def isSafe(col: Int, queens: List[Int], delta: Int): Boolean
\end{lstlisting}
que testa se uma rainha numa dada coluna \verb@col@ está segura com respeito às \verb@queens@ já colocadas.
Aqui, \verb@delta@ é a diferença entre a linha da rainha a ser colocada e a linha da primeira rainha da lista.
\end{exercise}

\section{Pesquisando com For-Comprehensions}

A notação for é essencialmente equivalente a operações comuns de linguagens de pesquisa de bases de dados.
Por exemplo, digamos que temos uma base de dados \code{books}, representada como uma lista de livros, onde
\code{Book} é definido como segue.
\begin{lstlisting}
case class Book(title: String, authors: List[String])
\end{lstlisting}
Aqui está um pequeno exemplo de base de dados:
\begin{lstlisting}
val books: List[Book] = List(
  Book("Structure and Interpretation of Computer Programs",
       List("Abelson, Harold", "Sussman, Gerald J.")),
  Book("Principles of Compiler Design",
       List("Aho, Alfred", "Ullman, Jeffrey")),
  Book("Programming in Modula-2",
       List("Wirth, Niklaus")),
  Book("Introduction to Functional Programming"),
       List("Bird, Richard")),
  Book("The Java Language Specification",
       List("Gosling, James", "Joy, Bill", "Steele, Guy", "Bracha, Gilad")))
\end{lstlisting}
Então, para encontrar os títulos de todos os livros cujos autores tenham sobrenome ``Ullman'':
\begin{lstlisting}
for (b <- books; a <- b.authors if a startsWith "Ullman")
yield b.title
\end{lstlisting}
(Aqui, \code{startsWith} é um método dentro em \code{java.lang.String}).  Ou, para encontrar os 
títulos de todos os livros que tenham a cadeia de caracteres ``Program'' em seu título: 
\begin{lstlisting}
for (b <- books if (b.title indexOf "Program") >= 0)
yield b.title
\end{lstlisting}
Ou, para encontrar os nomes de todos os autores que escreveram pelo menos dois livros, na base de dados.
\begin{lstlisting}
for (b1 <- books; b2 <- books if b1 != b2;
     a1 <- b1.authors; a2 <- b2.authors if a1 == a2)
yield a1
\end{lstlisting}
A última solução ainda não é perfeita, porque autores aparecerão diversas vezes na lista de resultados.
Ainda precisamos remover autores duplicados das listas resultantes. Isto pode ser obtido através da seguinte 
função.
\begin{lstlisting}
def removeDuplicates[A](xs: List[A]): List[A] =
  if (xs.isEmpty) xs
  else xs.head :: removeDuplicates(xs.tail filter (x => x != xs.head))
\end{lstlisting}
Observe que a última expressão no método \code{removeDuplicates} pode ser equivalentemente expresso usando 
um for-comprehension.
\begin{lstlisting}
xs.head :: removeDuplicates(for (x <- xs.tail if x != xs.head) yield x)
\end{lstlisting}

\section{Tradução de For-Comprehensions}

Cada for-comprehension pode ser expresso em termos de três funções de alta-ordem: \code{map}, 
\code{flatMap} e \code{filter}. Aqui está o esquema de tradução, que também é usado pelo compilador Scala.
\begin{itemize}
\item
Um for-comprehension simples
\begin{lstlisting}
for (x <- e) yield e'
\end{lstlisting}
é traduzido para
\begin{lstlisting}
e.map(x => e')
\end{lstlisting}
\item
Um for-comprehension 
\begin{lstlisting}
for (x <- e if f; s) yield e'
\end{lstlisting}
onde \code{f} é um filtro e \code{s} é uma (possivelmente vazia) sequência de geradores ou filtros, 
é traduzida para 
\begin{lstlisting}
for (x <- e.filter(x => f); s) yield e'
\end{lstlisting}
e então, a tradução continua com a última expressão.
\item
Um for-comprehension 
\begin{lstlisting}
for (x <- e; y <- e'; s) yield e''
\end{lstlisting}
onde \code{s} é uma (possivelmente vazia) sequência de geradores ou filtros é traduzida para 
\begin{lstlisting}
e.flatMap(x => for (y <- e'; s) yield e'')
\end{lstlisting}
e então, a tradução continua com a última expressão.
\end{itemize}
Por exemplo, tomando nosso exemplo  ``pares de inteiros cuja soma é um primo'':
\begin{lstlisting}
for { i <- range(1, n)
      j <- range(1, i)
      if isPrime(i+j)
} yield {i, j}
\end{lstlisting}
Aqui está o que obtemos quando traduzimos esta expressão:
\begin{lstlisting}
range(1, n)
  .flatMap(i =>
    range(1, i)
      .filter(j => isPrime(i+j))
      .map(j => (i, j)))
\end{lstlisting}

De modo inverso, também seria possível expressar as funções \code{map}, \code{flatMap} e \code{filter}
usando for-comprehensions. Aqui estão as três funções novamente, desta vez implementadas usando
for-comprehensions.

\begin{lstlisting}
object Demo {
  def map[A, B](xs: List[A], f: A => B): List[B] =
    for (x <- xs) yield f(x)

  def flatMap[A, B](xs: List[A], f: A => List[B]): List[B] =
    for (x <- xs; y <- f(x)) yield y

  def filter[A](xs: List[A], p: A => Boolean): List[A] =
    for (x <- xs if p(x)) yield x
}
\end{lstlisting}
Não surpreendentemente, a tradução do for-comprehension no corpo de \code{Demo.map} produzirá
uma chamada para \code{map} na classe \code{List}. Similarmente, \code{Demo.flatMap} e
\code{Demo.filter} são traduzidos para \code{flatMap} e \code{filter} na classe \code{List}.

\begin{exercise}
Defina a seguinte função em termos de \code{for}.
\begin{lstlisting}
def flatten[A](xss: List[List[A]]): List[A] =
  (xss :\ (Nil: List[A])) ((xs, ys) => xs ::: ys)
\end{lstlisting}
\end{exercise}

\begin{exercise}
Traduza 
\begin{lstlisting}
for (b <- books; a <- b.authors if a startsWith "Bird") yield b.title
for (b <- books if (b.title indexOf "Program") >= 0) yield b.title
\end{lstlisting}
para funções de alta ordem.
\end{exercise}

\section{Laços For}\label{sec:for-loops}

For-comprehensions lembram os laços for das linguagens imperativas, exceto que eles produzem uma lista 
de resultados. Algumas vezes, uma lista de resultados não é necessária, mas ainda gostaríamos da
flexibilidade dos geradores e filtros nas iterações sobre listas. Isso é possível por uma variante
da sintaxe dos for-comprehensions, os quais expressam laços for:  
\begin{lstlisting}
for ( $s$ ) $e$
\end{lstlisting}
Esta construção é a mesma da sintaxe padrão do for-comprehension, exceto que a palavra chave \code{yield}
está faltando. O laço for é executado pela execução da expressão $e$ para cada elemento gerado da sequência 
de geradores e filtros $s$.

Como um exemplo, a seguinte expressão imprime todos os elementos de uma matriz representada como 
uma lista de listas:
 \begin{lstlisting}
for (xs <- xss) {
  for (x <- xs) print(x + "\t")
  println()
}
\end{lstlisting}
A tradução de laços for para métodos de alta ordem da classe \code{List} é similar à tradução de
for-comprehensions, mas mais simples. Onde for-comprehensions são traduzidos para \code{map} e 
\code{flatMap}, laços for traduzem em cada caso para \code{foreach}.

\section{Generalizando For}

Temos visto que a tradução de for-comprehensions somente ocorre na presença dos métodos \code{map},
\code{flatMap}, e \code{filter}. Portanto é possível aplicar a mesma notação para geradores que 
produzam outros objetos além de listas; tais objetos somente tem de atender as três funções-chave \code{map},
\code{flatMap}, e \code{filter}.

A biblioteca padrão Scala tem diveras outras abstrações que suportam estes três métodos e com eles suportam 
for-comprehensions. Encontraremos alguns deles nos capítulos seguintes. Como programador você também pode
usar este princípio para habilitar for-comprehensions para tipos que você definiu---estes tipos somente 
precisam suportar os métodos \code{map}, \code{flatMap}, e \code{filter}.



Há muitos exemplos onde isto é útil: interfaces de base de dados, árvores XML, ou valores opcionais. 
Uma advertência: não há garantia automática que a tradução resultante de um for-comprehension seja 
bem tipada. Para garantir isso, os tipos de \code{map}, \code{flatMap}, e \code{filter} tem de ser
essencialmente similares aos tipos desses métodos na classe \code{List}.
Para tornar isto preciso, assuma que você tenha uma classe parametrizada
 \code{C[A]} para a qual você deseja habilitar for-comprehensions. Então \code{C} deve definir 
\code{map}, \code{flatMap}, e \code{filter} com os seguintes tipos:
\begin{lstlisting}
def map[B](f: A => B): C[B]
def flatMap[B](f: A => C[B]): C[B]
def filter(p: A => Boolean): C[A]
\end{lstlisting}

Seria atrativo forçar estes tipos estáticamente dentro do compilador Scala, por exemplo, requerendo que 
qualquer tipo que suporte for-comprehensions implemente um trait padrão com estes métodos \footnote{Na 
linguagem de programação Haskell, que tem construtores similares, esta abstração é chamada 
um ``monada com zero''}. O problema é que tal trait padrão tem de abstrair sobre a identidade da classe \code{C}, 
por exemplo tomando \code{C} como um tipo parâmetro. Observe que este parâmetro deve ser um tipo construtor, 
que é aplicado a {\em diversos diferentes} tipos nas assinaturas dos métodos \code{map} e \code{flatMap}.
Infelizmente, o sistema de tipos Scala é muito fraco para expressar este construtor, desde que pode lidar somente 
com tipos parâmetros que são tipos totalmente aplicados.

\chapter{Estados Mutáveis}

A maioria dos programas apresentados até o momento não possui efeitos colaterais.
\footnote{Ignoramos o fato de que algums dos programas imprimem na tela, o que, 
tecnicamente, é um efeito colateral.}.  Portanto, a noção de {\em tempo} não
importou.  

Para um programa que termina, qualquer sequência de ações levará ao mesmo resultado! Isso também é refletido
pelo modelo de computação de substituição, onde um passo de reescrita pode ser aplicado em qualquer lugar de
um termo, e todas as reescritas que terminam levam a mesma solução. De fato, esta propriedade de 
{\em confluência} é um profundo resultado do cálculo $\lambda$, a teoria que embasa a programação funcional.

Neste capítulo, introduziremos funções com efeitos colaterais e estudaremos seu comportamento. Veremos que 
como consequência temos fundamentalmente que modificar o modelo de substituição de computação empregado até aqui.

\section{Objetos Mutáveis} 

Normalmente vemos o mundo como um conjunto de objetos, alguns dos quais com estado que {\em muda} através 
do tempo. Normalmente, o estado é associado com um conjunto de variáveis que podem ser alteradas no curso 
de uma computação. Há também uma noção mais abstrata de estado, que não se refere a construções particulares
de uma linguagem de programação: um objeto {\em tem estado} (ou: {\em é mutável}) se seu comportamento é 
influenciado por sua história.

Por exemplo, uma objeto conta de banco tem estado, porque a questão
``Eu posso sacar R\$ 100?''
pode ter diferentes respostas durante o tempo de vida da conta.

Em Scala, todos os estados mutáveis são em última análise criados a partir das variáveis. Uma definição de 
variável é escrita como uma definição de valor, mas começa com \verb@var@ ao invés de \verb@val@. Por exemplo, 
os duas definições seguintes introduzem e inicializam duas variáveis \code{x} e \code{count}.
\begin{lstlisting}
var x: String = "abc"
var count = 111
\end{lstlisting}

Como uma definição de valor, uma definição de variável associa um nome com um valor. Mas no caso da definição 
de variável, esta associação pode ser alterada posteriormente através de uma atribuição. Tais atribuições são 
escritas em C ou Java. Exemplos: 
\begin{lstlisting}
x = "hello"
count = count + 1
\end{lstlisting}
Em Scala, cada variável definida tem de ser inicializada no ponto de sua definição. Por exemplo, a declaração 
~\code{var x: Int;}~ {\em não} é tida como uma definição de variável, porque o inicializador está 
ausente\footnote{Se uma declaração como esta aparece numa classe, é tida como uma declaração de variável, que 
introduz métodos de acesso abstratos para a variável, mas não associa estes métodos com um pedaço do estado.}.
Se não se sabe, ou não é importante, o inicializador apropriado, pode-se usar um caracter coringa no lugar. 
Ou seja,
\begin{lstlisting}
val x: T = _
\end{lstlisting}
inicializará \code{x} para algum valor default (\code{null} para tipos referência, \code{false} para boleanos, e
a versão apropriada de \code{0} para valores de tipos numéricos).

Objetos do mundo real com estado são representados em Scala através de objetos que tem variáveis como membros.
Por exemplo, aqui está uma classe que representa contas bancárias.
\begin{lstlisting}
class BankAccount {
  private var balance = 0
  def deposit(amount: Int) {
    if (amount > 0) balance += amount
  }

  def withdraw(amount: Int): Int =
    if (0 < amount && amount <= balance) {
      balance -= amount
      balance
    } else error("insufficient funds")
}
\end{lstlisting}


A classe define uma variável \code{balance} que contém o balanço corrente de uma conta. Métodos \code{deposit} e
\code{whithdraw} mudam o valor desta variável através de atribuições. Observe que \code{balance} e \code{private}
na classe \code{BankAccount} -- consequentemente não pode ser acessado diretamente fora da classe.
Para criar contas bancárias, usamos a notação usual para criação de objeto:
\begin{lstlisting}
val myAccount = new BankAccount
\end{lstlisting}

\example Aqui está uma sessão \code{scalaint} que lida com contas bancárias.

\begin{lstlisting}
scala> :l bankaccount.scala
Loading bankaccount.scala...
defined class BankAccount
scala> val account = new BankAccount
account: BankAccount = BankAccount$\Dollar$class@1797795
scala> account deposit 50
unnamed0: Unit = ()
scala> account withdraw 20
unnamed1: Int = 30
scala> account withdraw 20
unnamed2: Int = 10
scala> account withdraw 15
java.lang.Error: insufficient funds
        at scala.Predef$\Dollar$error(Predef.scala:74)
        at BankAccount$\Dollar$class.withdraw(<console>:14)
        at <init>(<console>:5)
scala> 
\end{lstlisting}
O exemplo mostra que aplicando a mesma operação (\code{withdraw 20}) duas vezes para uma conta gera resultados
diferentes. Então, claramente, contas são objetos dinâmicos.
\paragraph{Constância e Alteração}
Atribuições colocam novos problemas na decisão de quando duas expressões são ``a mesma''.
Se atribuições são excluídas, e escrevemos
\begin{lstlisting}
val x = E; val y = E
\end{lstlisting}
onde \code{E} é alguma expressão arbitrária, então \code{x} e \code{y}
podem ser assumidos razoavelmente como sendo o mesmo.
Ou seja, poderia-se equivalentemente escrever
\begin{lstlisting}
val x = E; val y = x
\end{lstlisting}
(Esta propriedade é geralmente chamada {\em transparência referencial}). Mas uma vez que admitimos atribuições, 
as duas sequências de definições são diferentes. Considere: 
\begin{lstlisting}
val x = new BankAccount; val y = new BankAccount
\end{lstlisting}
Para responder a questão se \code{x} e \code{y} são o mesmo, precisamos ser mais precisos sobre o que significa
constância. Este significado é capturado na noção de {\em equivalência operacional}, a qual, de modo um tanto 
quanto informal, é descrita como segue.

Suponha que temos duas definições para \code{x} e \code{y}. Para testar se \code{x} e \code{y} definem o mesmo 
valor, proceda como segue.
\begin{itemize}
\item
Execute as definições seguidas para uma sequência arbitrária \code{S} de operações que envolvam \code{x} e 
\code{y}. Observe o resultado (se houver).
\item
Então, execute as definições com uma outra sequência \code{S'} resultante de \code{S} pela renomeação de 
todas as ocorrências de \code{y} em \code{S} para \code{x}. 
\item
Se os resultados da execução de \code{S'} forem diferentes, então certamente \code{x} e \code{y} são diferentes. 
\item
Por outro lado, se todos os possíveis pares de sequências \lstinline@{S, S'}@ dão os mesmos resultados, então
\code{x} e \code{y} são o mesmo.
\end{itemize}
Em outras palavras, equivalência operacional levam duas definições \code{x} e \code{y} como definindo o mesmo 
valor, se nenhum experimento possível puder distinguir entre \code{x} e \code{y}. Um experimento neste contexto
são duas versões de um programa arbitrário que usa ou \code{x} ou \code{y}.
 
Dada esta definição, vamos testar se
\begin{lstlisting}
val x = new BankAccount; val y = new BankAccount
\end{lstlisting}
definem valores \code{x} e \code{y} que são o mesmo.
Aqui estão as definições novamente, seguidas por uma sequência de testes:

\begin{lstlisting}
> val x = new BankAccount
> val y = new BankAccount
> x deposit 30
30
> y withdraw 20
java.lang.RuntimeException: insufficient funds
\end{lstlisting}

Agora, renomeie todas as ocorrências de \code{y} naquela sequência para \code{x}. Obtemos:
\begin{lstlisting}
> val x = new BankAccount
> val y = new BankAccount
> x deposit 30
30
> x withdraw 20
10
\end{lstlisting}
Como os resultados finais são diferentes, estabelecemos que \code{x} e \code{y} não são o mesmo.
Por outro lado, se definimos
\begin{lstlisting}
val x = new BankAccount; val y = x
\end{lstlisting}
então nenhuma sequência de operações pode distiguir entre \code{x} e \code{y}, portanto \code{x} e \code{y} 
são o mesmo neste caso.

\paragraph{Atribuição e o Modelo de Substituição} 

Estes exemplos mostram que nosso modelo de substituição computacional não mais pode ser usado. Afinal de contas,
sob este modelo nem sempre podemos substituir um valor de nome por sua expressão definida. 
Por exemplo em
\begin{lstlisting}
val x = new BankAccount; val y = x
\end{lstlisting}
o \code{x} na definição de \code{y} pode ser substituído por \code{new BankAccount}. Mas vimos que esta 
alteração leva a programas distintos. Então o modelo de substituição deve ser inválido, uma vez que adicionemos
atribuições.

\section{Estruturas Imperativas de Controle}

Scala tem construções de laços \code{while} e \code{do-while} derivadas das linguagens de programação C e Java. 
Também há uma ramificação única \code{if} que deixa de fora a parte ``else'', bem como uma declaração 
\code{return} que aborta uma função prematuramente. Isso torna possível programar no estilo imperativo 
convencional. Por exemplo, a seguinte função, que computa a en\'{e}sima potência de um dado parâmetro \code{x},
é implementada usando \code{while} e um \code{if} simples.
 
\begin{lstlisting}
def power(x: Double, n: Int): Double = {
  var r = 1.0
  var i = n
  var j = 0
  while (j < 32) {
    r = r * r
    if (i < 0)
      r *= x
    i = i << 1
    j += 1
  }
  r
}
\end{lstlisting}
Estas construções de controle imperativo estão na linguagem por conveniência. Poderiam ser deixadas de fora, 
pois as mesmas construções podem ser implementadas usando apenas funções. Como exemplo, vamos desenvolver uma 
implementação funcional para o laço while. \code{whileLoop} deve ser uma função que recebe dois parâmetros:
uma condição, de tipo \code{Boolean}, e um comando, de tipo \code{Unit}. Ambos, condição e comando, devem 
ser passados por nome, dado que serão avaliados repetidamente para cada iteração do laço. Isso leva a seguinte 
definição para \code{whileLoop}. 

\begin{lstlisting}
def whileLoop(condition: => Boolean)(command: => Unit) {
  if (condition) {
    command; whileLoop(condition)(command)
  } else ()
}
\end{lstlisting}
Observe que \code{WhileLoop} é uma recursão de cauda, logo opera em um espaço de pilha constante.

\begin{exercise} Escreva uma função \code{repeatLoop}, que deve ser aplicada como segue:
\begin{lstlisting}
repeatLoop { command } ( condition )
\end{lstlisting}
Há também um modo de se obter uma sintaxe de laço como a seguinte?
\begin{lstlisting}
repeatLoop { command } until ( condition )
\end{lstlisting}
\end{exercise}

Algumas outras construções de controle conhecidas do C e do Java estão ausentes em Scala: não há \code{break} e 
\code{continue}. Também não há laços ``for'' similares ao Java -- estes foram substituídos por uma construção 
de laço ``for'' mais geral, discutida na Seção~\ref{sec:for-loops}.

\section{Exemplo Estendido: Simulação de Eventos Discretos}
Agora discutiremos um exemplo que demonstra como atribuições e funções de alta ordem podem ser combinados
de maneiras interessantes. Construiremos um simulador para circuitos digitais.

O exemplo é emprestado do livro do Abelson e
Sussman \cite{abelson-sussman:structure}.  Nós expandimos o código
básico (Scheme-) através de uma estrutura orientada a objetos que
permite reuso de código por meio de herança. O exemplo também mostra
como programas de simulação de eventos discretos em geral são
estruturados e construídos.

Começamos com uma pequena linguagem para descrever circuitos digitais. Um circuito digital é criado a partir
de {\em fios} e {\em caixas função}. Fios carregam sinais que são transformados por caixas função. 
Representaremos sinais pelos boleanos \code{true} e \code{false}.

Caixas função básicas (ou: {\em portas}) são: 

\begin{itemize}
\item Um \emph{inversor}, o qual nega seu sinal.
\item Uma \emph{porta E}, o qual determina sua saída com base na conjunção da sua entrada.
\item Uma \emph{porta OU}, o qual determina sua saída com base na disjunção da sua entrada.
\end{itemize}
Outras portas lógicas pode ser construídas pela combinação das portas básicas.

Portas tem {\em delays}, portanto a saída de uma porta somente mudará
algum tempo após a mudança da sua entrada.

\paragraph{Uma Linguagem para Circuitos Digitais}

Descrevemos os elementos de um circuito digital através do seguinte conjunto de classes e funções Scala.

Primeiro, há uma classe \code{Wire} para fios. Podemos construir fios como segue.
\begin{lstlisting}
val a = new Wire
val b = new Wire
val c = new Wire
\end{lstlisting}
Segundo, há procedimentos
\begin{lstlisting}
def inverter(input: Wire, output: Wire)
def andGate(a1: Wire, a2: Wire, output: Wire)
def orGate(o1: Wire, o2: Wire, output: Wire)
\end{lstlisting}
que ``criam'' as portas lógicas básicas que precisamos (como efeitos
colaterais).  Portas mais complicadas pode agora ser construídas a
partir destas. Por exemplo, para construir um circuito meia soma, podemos
definir:
\begin{lstlisting}
  def halfAdder(a: Wire, b: Wire, s: Wire, c: Wire) {
    val d = new Wire
    val e = new Wire
    orGate(a, b, d)
    andGate(a, b, c)
    inverter(c, e)
    andGate(d, e, s)
  }
\end{lstlisting}
Esta abstração pode ela mesma ser usada, por exemplo, na definição de um circuito soma completo:
\begin{lstlisting}
  def fullAdder(a: Wire, b: Wire, cin: Wire, sum: Wire, cout: Wire) {
    val s = new Wire
    val c1 = new Wire
    val c2 = new Wire
    halfAdder(a, cin, s, c1)
    halfAdder(b, s, sum, c2)
    orGate(c1, c2, cout)
  }
\end{lstlisting}
A classe \code{Wire} e as funções \code{inverter}, \code{andGate},
e \code{orGate} representam, portanto, uma pequena linguagem na qual
usuários podem definir circuitos digitais. Agora damos implementações
destas classes e funções, que nos permite simalar circuitos. Essa
implementações são baseadas numa API simples e geral para simulação de
eventos discretos.

\paragraph{A API Simulação}

A simulação de eventos discretos realiza \emph{ações} definidas pelo
usuário em \emph{tempos} específicos.  Uma {\em ação} é representada
como uma função que não recebe parâmetros e retorna um
resultado \code{Unit}:
\begin{lstlisting}
type Action = () => Unit
\end{lstlisting}
O \emph{tempo} é simulado; não é o horário atual do ``relógio de parede''.

Uma simulação concreta será efetuada dentro do objeto que herda a
classe abstrata \code{Simulation}. Esta classe tem a seguinte
assinatura:

\begin{lstlisting}
abstract class Simulation {
  def currentTime: Int
  def afterDelay(delay: Int, action: => Action)
  def run()
}
\end{lstlisting}
Aqui,
\code{currentTime} retorna o tempo corrente como um número inteiro, 
\code{afterDelay} agenda uma ação para ser realizada com um atraso específico após \code{currentTime}, e 
\code{run} executa a simulação até que não haja mais ações a serem realizadas.

\paragraph{A Classe Fio (Wire)}
Um fio precisa atender a três ações básicas.
\begin{itemize}
\item[]
\code{getSignal: Boolean}~~ retorna o sinal corrente sobre o fio.
\item[]
\code{setSignal(sig: Boolean)}~~ atualiza o sinal do fio para \code{sig}.
\item[]
\code{addAction(p: Action)}~~ junta o procedimento especificado \code{p} nas {\em ações} do fio. Todos os 
procedimentos juntados às ações serão executados toda vez que o sinal
do fio mudar.
\end{itemize}
Aqui está uma implementação da classe \code{Wire (fio)}:
\begin{lstlisting}
class Wire {
  private var sigVal = false
  private var actions: List[Action] = List()
  def getSignal = sigVal
  def setSignal(s: Boolean) =
    if (s != sigVal) {
      sigVal = s
      actions.foreach(action => action())
    }
  def addAction(a: Action) {
    actions = a :: actions; a()
  }
}
\end{lstlisting}
Duas variáveis privadas compõem o estado de um fio. A variável \code{sigVal} denota o sinal corrente, e a
variável \code{actions} denota os procedimentos de ação atualmente juntados ao fio.

\paragraph{A Classe Inversor}
Implementamos um inversor instalando uma ação ao seu fio de entrada,
ou seja, a ação que coloca a entrada negada sobre o sinal de saída. A
ação precisa ter efeito nas unidades de tempo
simulado \code{InverterDelay} após a entrada mudar. Isso sugere a
seguinte implementação:

\begin{lstlisting}
def inverter(input: Wire, output: Wire) {
  def invertAction() {
    val inputSig = input.getSignal
    afterDelay(InverterDelay) { output setSignal !inputSig }
  }
  input addAction invertAction
}
\end{lstlisting}

\paragraph{A Classe And-Gate (Porta E)}
Portas E são implementadas analogamente a inversores. A ação de
uma \code{andGate} é criar na saída a conjunção dos seus sinais de
entrada. Isso deve ocorrer nas unidades de tempo
simulado \code{AndGateDelay} após qualquer de suas duas entradas
mudar. Consequentemente, temos a seguinte implementação:
\begin{lstlisting}
def andGate(a1: Wire, a2: Wire, output: Wire) {
  def andAction() {
    val a1Sig = a1.getSignal
    val a2Sig = a2.getSignal
    afterDelay(AndGateDelay) { output setSignal (a1Sig & a2Sig) }
  }
  a1 addAction andAction
  a2 addAction andAction
}
\end{lstlisting}

\begin{exercise} Escreva a implementação da porta lógica OU (\code{orGate}).
\end{exercise}

\begin{exercise} Um outro modo de se definir uma porta OU é pela combinação de inversores e portas E.
Defina uma função \code{orGate} em termos de \code{andGate} e \code{inverter}. Qual o tempo de atraso 
desta função?
\end{exercise}

\paragraph{A Classe Simulação}
Agora, só falta implementar a classe \code{Simulation}. A idéia é
manter dentro de um objeto \code{Simulation} uma \emph{agenda} de
ações a serem realizadas. A agenda é representada como uma lista de
pares de ações e os tempos a serem executadas. A lista agenda é
ordenada, portanto ações que devem ocorrer mais cêdo precedem as que
devem ocorrer depois.
\begin{lstlisting} 
abstract class Simulation {
  case class WorkItem(time: Int, action: Action)
  private type Agenda = List[WorkItem]
  private var agenda: Agenda = List()
\end{lstlisting}
Há também uma variável privada \code{curtime} para acompanhar o tempo
simulado corrente.
\begin{lstlisting}
  private var curtime = 0
\end{lstlisting}
Uma aplicação do método \code{afterDelay(delay, block)} insere o
elemento \lstinline@WorkItem(currentTime + delay, () => block)@ 
dentro da lista \code{agenda} no lugar apropriado.
\begin{lstlisting}
private def insert(ag: Agenda, item: WorkItem): Agenda =
  if (ag.isEmpty || item.time < ag.head.time) item :: ag
  else ag.head :: insert(ag.tail, item)

def afterDelay(delay: Int)(block: => Unit) {
  val item = WorkItem(currentTime + delay, () => block)
  agenda = insert(agenda, item)
}
\end{lstlisting}
Uma aplicação para o método \code{run} remove sucessivos elementos
da \code{agenda} e realiza suas ações. Continua até que a agenda
esteja vazia:
\begin{lstlisting}
private def next() {
  agenda match {
    case WorkItem(time, action) :: rest =>
      agenda = rest; curtime = time; action()
    case List() =>
  }
}

def run() {
  afterDelay(0) { println("*** simulation started ***") }
  while (!agenda.isEmpty) next()
}
\end{lstlisting}

\paragraph{Executando o Simulador}
Para executar o simulador, ainda precisamos de um modo de inspecionar
mudanças de sinais sobre os fios.  Para este propósito, escrevemos uma
função \code{probe} (sonda).

\begin{lstlisting}
def probe(name: String, wire: Wire) {
  wire addAction { () =>
    println(name + " " + currentTime + " new_value = " + wire.getSignal)
  }
}
\end{lstlisting}
Agora, para vermos o simulador em ação, vamos definir quatro fios, e
colocar duas sondas sobre dois deles: 
\begin{lstlisting}
scala> val input1, input2, sum, carry = new Wire

scala> probe("sum", sum)
sum 0 new_value = false

scala> probe("carry", carry)
carry 0 new_value = false
\end{lstlisting}
Agora vamos definir um circuito meia soma conectando os fios:
\begin{lstlisting}
scala> halfAdder(input1, input2, sum, carry)
\end{lstlisting}
Finalmente, setamos um após o outro os sinais sobre os dois fios de
entrada para \code{true} e rodamos a simulação.
\begin{lstlisting}
scala> input1 setSignal true; run
*** simulation started ***
sum 8 new_value = true

scala> input2 setSignal true; run
carry 11 new_value = true
sum 15 new_value = false
\end{lstlisting}

\section{Sumário}

Vimos neste capítulo as construções que nos permitiram modelar estados
em Scala -- que são variáveis, atribuições, e estruturas de controle
imperativo. Estados e Atribuições complicam nosso modelo mental de
computação. Em particular, a transparência referencial é perdida. Por
outro lado, atribuição nos dá novos meios para formular programas
elegantemente. Como sempre, isso depende de qual funciona melhor para
uma dada situação: programas puramente funcionais ou programas com
atribuições.

\chapter{Computando com Streams}

Os capítulos anteriores apresentaram variáveis, atribuição e objetos com estado.
Vimos como objetos no mundo real mudam com o tempo e podem ser modelados através da
mudança de estado das suas variáveis durante a computação. Desta maneira, mudanças no 
tempo no mundo real  são modeladas por mudanças no tempo durante a execução do programa.
Obviamente, usa-se uma escala e estas mudanças no tempo são alargadas ou comprimidas, mas
sua ordem relativa permanece a mesma. Isto pode parecer natural, mas existe um preço a se
pagar: o modelo de substituição usado na computação funcional não pode ser aplicado ao se
introduzir variáveis e atribuições.

Será que não existe uma outra maneira? Não seria possível modelar
mudanças de estado no mundo real usando somente funções imutáveis?
Tomando matemática como um guia, a resposta claramente é sim: um
quantidade que muda no tempo é modelada através da função \code{f(t)}
que tem como parâmetro \code{t} para representar o tempo. O mesmo pode
ser feito na computação. Ao invés de sobre-escrever uma variável com
sucessivos valores, podemos representar estes valores como sucessivos
elementos em uma lista.  Desta forma, a variável mutável \code{var x:
T} pode ser substituída por uma variável imutável \code{val x:
List[T]}.  De certa maneira, troca-se espaço por tempo -- os
diferentes valores da variável agora existem concorrentemente como
diferentes elementos da lista. Uma das vantagens do modelo baseado em
lista é a possibilidade de ``viajar no tempo'', ou seja, de ver
sucessivos valores da variável ao mesmo tempo. Uma outra vantagem é
que podemos fazer uso da poderosa biblioteca de funções processamento
de listas, que normalmente simplifica a computação. Por exemplo,
considere a forma imperativa de computar a soma de todos os primos em
um intervalo:
\begin{lstlisting}
def sumPrimes(start: Int, end: Int): Int = {
  var i = start
  var acc = 0
  while (i < end) {
    if (isPrime(i)) acc += i
    i += 1
  }
  acc
}
\end{lstlisting}
Note que a variável \code{i} ``passa por'' todos os valores do intervalo
\code{[start .. end-1]}.

Uma forma mais funcional, é representar a lista de valores da
variável \code{i} diretamente como \code{range(start, end)}.  Então a
função pode ser re-escrita da seguinte maneira:
\begin{lstlisting}
def sumPrimes(start: Int, end: Int) =
  sum(range(start, end) filter isPrime)
\end{lstlisting}

Não dúvida que o programa é mais curto e mais claro! Porém, o 
programa funcional é também consideravelmente menos eficiente, uma
vez que ele constrói a lista de todos os número no intervalo e, posteriormente,
constrói uma outra lista com os números primos. Ainda pior sob o ponto de vista
da eficiência é o seguinte exemplo:

Para encontrar o segundo número primio entre \code{1000} e \code{10000}:
\begin{lstlisting}
  range(1000, 10000) filter isPrime at 1
\end{lstlisting}
Aqui, a lista de todos os números entre \code{1000} e \code{10000} é construída,
mas a maior parte da lista nunca é usada!

No entanto, pode-se obter uma execução eficiente para exemplos como este usando
um truque:
\begin{quote}
%\red
 Nunca compute o resto (tail) de uma sequência a não ser que o resto seja realmente
necessário para a computação.
\end{quote}
Para isso, definimos uma nova classe para sequências, que é chamada \code{Stream}.

Streams são criados usando a constante  \code{empty} e o construtor \code{cons},
ambos definidos no módulo \code{scala.Stream}. Por exemplo, a seguinte expressão constrói
um stream como os elementos \code{1} e \code{2}:
\begin{lstlisting}
Stream.cons(1, Stream.cons(2, Stream.empty))
\end{lstlisting}
Como um outro exemplo, este é o análogo de \code{List.range},
mas que retorna um stream ao invés de uma lista:
\begin{lstlisting}
def range(start: Int, end: Int): Stream[Int] =
  if (start >= end) Stream.empty
  else Stream.cons(start, range(start + 1, end))
\end{lstlisting}
(Esta função também foi definida como mostrado anteriormente no módulo 
\code{Stream}).  Embora \code{Stream.range} e \code{List.range} se pareçam,
seu comportamento em tempo de execução é completamente diferente: 

\code{Stream.range} retorna imediatamente um objeto do tipo \code{Stream} cujo primeiro
elemento é \code{start}.  Todos os outros elementos são computados somente quando eles são 
\emph{demandados} através da chamada do método \code{tail} (o que pode nunca acontecer).  

Streams são acessados exatamente como listas. Similarmente às listas, os métodos básicos de acesso são
 \code{isEmpty}, \code{head} e \code{tail}. Por exemplo, podemos
imprimir todos os elementos de um stream da seguinte maneira.
\begin{lstlisting}
def print(xs: Stream[A]) {
  if (!xs.isEmpty) { Console.println(xs.head); print(xs.tail) }
}
\end{lstlisting}
Streams também oferecem praticamente todos os outros métodos definidos nas listas (veja a seguir onde
os conjuntos de métodos são diferentes). Por exemplo, podemos encontrar o segundo número primo entre 
\code{1000} e \code{10000} através do uso dos métodos 
\code{filter} e \code{apply} no stream que fornece o intervalo:
\begin{lstlisting}
  Stream.range(1000, 10000) filter isPrime at 1
\end{lstlisting}
A diferença entre a implementação anterior que usada lista, é que agora não
construímos nem testamos se é primo nenhum número maior que 1013.

\paragraph{Retorno e concatenação de streams} Há dois métodos na classe \code{List}
que não estão presentes na classe \code{Stream}. São eles \code{::} e
\code{:::}.  O motivo é que estes métodos são chamados pelo argumento da direita, o
que significa que este argumento precisa ser computado antes que o método seja chamado.
Por exemplo, no caso de \code{x :: xs} nas listas, o resto \code{xs} precisa ser computado
antes de \code{::} ser chamado e a nova lista ser construída.
Isto não funciona para streams, onde queremos que o resto de um stream 
não seja computado até que seja demandado pela chamada ao método \code{tail}.
O argumento pelo qual a concatenação de listas \code{:::} não pode ser adaptado para streams
é análogo.

Ao inv\'{e}s de \code{x :: xs}, pode-se usar \code{Stream.cons(x, xs)} para
construir um stream com o primeiro elemento \code{x} e o resto (n\~{a}o computado).
Ao invés de \code{xs ::: ys}, pode-se usar \code{xs append ys}.  


\chapter{Iteradores}

Iteradores s\~{a}o uma vers\~{a}o imperativa dos streams. Assim como streams,
iteradores descrevem listas potencialmente infinitas. No entanto, não existe uma estrutura de dados
que contenha os elementos de um iterador. Ao invés disso, os iteradores permitem que se ande somente um passo
na sequ\^{e}ncia de cada vez, usando os métodos abstratos \code{next} e \code{hasNext}.
\begin{lstlisting}
trait Iterator[+A] {
  def hasNext: Boolean
  def next: A
\end{lstlisting}
O método \code{next} retorna sucessivos elementos.  O método \code{hasNext}
indica se existem mais elementos a serem retornados por
\code{next}. Iteradores também possuem outros métodos que serão explicados posteriormente.

Como exemplo, esta é uma aplicação que imprime os quadrados de todos os números de 1 à 100.
\begin{lstlisting}
val it: Iterator[Int] = Iterator.range(1, 100)
while (it.hasNext) {
  val x = it.next
  println(x * x)
}
\end{lstlisting}

\section{Métodos dos Iteradores}

Os iteradores possuem um conjunto de métodos além de \code{next} e
\code{hasNext}, que são descritos a seguir. Muitos destes métodos
oferecem uma funcionalidade correspondente à do método equivalente em uma lista.

\paragraph{Append}
O método \code{append} constrói uma iterador que começa com o código dado de iteração ~\code{it}~ depois 
que o iterador atual tem terminado.
\begin{lstlisting}
  def append[B >: A](that: Iterator[B]): Iterator[B] = new Iterator[B] {
    def hasNext = Iterator.this.hasNext || that.hasNext
    def next = if (Iterator.this.hasNext) Iterator.this.next else that.next
  }    
\end{lstlisting}
Os termos \code{Iterator.this.next} e \code{Iterator.this.hasNext}
na definição de \code{append} chamam os métodos correspondentes definidos na classe \code{Iterator} 
que contém o método \code{append}. Se o prefixo
\code{Iterator} não fosse adicionado ao \code{this},
\code{hasNext} e \code{next} chamariam recursivamente os métodos definidos no resultado de \code{append},
o que não era o efeito desejado.

\paragraph{Map, FlatMap, Foreach} O método \code{map} 
constrói um iterador que retorna todos os elementos do iterador original transformados por uma dada função \code{f}.
\begin{lstlisting}
  def map[B](f: A => B): Iterator[B] = new Iterator[B] {
    def hasNext = Iterator.this.hasNext
    def next = f(Iterator.this.next)
  }
\end{lstlisting}
O método \code{flatMap} é similar ao método \code{map}, exceto que a função de transformação \code{f} retorna um iterador 
ao invés de um elemento. O resultado de \code{flatMap} é um iterador resultante da anexação (\code{append}) de todos os iteradores resultantes
das sucessivas chamadas de \code{f}.
\begin{lstlisting}
  def flatMap[B](f: A => Iterator[B]): Iterator[B] = new Iterator[B] {
    private var cur: Iterator[B] = Iterator.empty
    def hasNext: Boolean =
      if (cur.hasNext) true
      else if (Iterator.this.hasNext) { cur = f(Iterator.this.next); hasNext }
      else false
    def next: B =
      if (cur.hasNext) cur.next
      else if (Iterator.this.hasNext) { cur = f(Iterator.this.next); next }
      else error("next on empty iterator")
  }
\end{lstlisting}
Também relacionado à \code{map}, temos o método \code{foreach} que aplica uma
dada função a todos elementos de um iterador, mas não constrói uma lista de resultados
\begin{lstlisting}
  def foreach(f: A => Unit): Unit =
    while (hasNext) { f(next) }
\end{lstlisting}

\paragraph{Filter} O método \code{filter} constrói um iterador que retorna
todos os elementos do iterador original que satisfazem um dado critério \code{p}.
\begin{lstlisting}
  def filter(p: A => Boolean) = new BufferedIterator[A] {
    private val source =
      Iterator.this.buffered
    private def skip =
      { while (source.hasNext && !p(source.head)) { source.next } }
    def hasNext: Boolean =
      { skip; source.hasNext }
    def next: A =
      { skip; source.next }
    def head: A =
      { skip; source.head }
  }
\end{lstlisting}
Na prática, \code{filter} retorna uma instância de uma sub-classe dos iteradores que trabalha com um
 ``buffer''.  Um objeto do tipo \code{BufferedIterator} é um iterador que tem adicionalmente um método
 \code{head}. Este método retorna um elemento que seria retornado pelo método \code{next}, porém
não avança além daquele elemento. Com isso, o elemento retornado por \code{head} é retornado novamente
pela próxima chamada de \code{head} ou \code{next}. Esta é a definição do trait 
\code{BufferedIterator}:
\begin{lstlisting}
trait BufferedIterator[+A] extends Iterator[A] {
  def head: A
}
\end{lstlisting}
Como \code{map}, \code{flatMap}, \code{filter} e \code{foreach}
existem para iteradores, como consequência for-comprehensions e loops de for também podem ser usados em iteradores.
Por exemplo, a aplicação que imprime os quadrados dos números entre 1 e 100 poderia ter sido expressada da seguinte forma:
\begin{lstlisting}
for (i <- Iterator.range(1, 100))
  println(i * i)
\end{lstlisting}

\paragraph{Zip} O método \code{zip} recebe um outro iterador e retorna um iterador que consiste
de pares dos respectivos elementos retornados pelos dois iteradores.
\begin{lstlisting}
  def zip[B](that: Iterator[B]) = new Iterator[(A, B)] {
    def hasNext = Iterator.this.hasNext && that.hasNext
    def next = (Iterator.this.next, that.next)
  }
}
\end{lstlisting}

\section{Construindo Iteradores}

As classes concretas de iteradores precisam implementar os dois métodos abstratos
 \code{next} e \code{hasNext} definidos na classe
\code{Iterator}. O iterador mais simples é \code{Iterator.empty} que sempre retorna uma
sequência vazia:
\begin{lstlisting}
object Iterator {
  object empty extends Iterator[Nothing] {
    def hasNext = false
    def next = error("next on empty iterator")
  }
\end{lstlisting}
Um iterador um pouco mais interessante enumera todos os elementos de um vetor. Este iterador
é construído a partir do método \code{fromArray}, que também foi definido no objeto \code{Iterator}
\begin{lstlisting}
  def fromArray[A](xs: Array[A]) = new Iterator[A] {
    private var i = 0
    def hasNext: Boolean =
      i < xs.length
    def next: A =
      if (i < xs.length) { val x = xs(i); i += 1; x }
      else error("next on empty iterator")
  }
\end{lstlisting}
Um outro iterador enumera um intervalo de inteiros. A função
\code{Iterator.range} retorna o iterador que caminha em um intervalo dado de valores inteiros.
Sua definição é a seguinte:
\begin{lstlisting}
object Iterator {
  def range(start: Int, end: Int) = new Iterator[Int] {
    private var current = start
    def hasNext = current < end
    def next = {
      val r = current
      if (current < end) current += 1
      else error("end of iterator")
      r
    }
  }
}
\end{lstlisting}
Todos os iteradores mostrados até agora tem um fim. Também é possível
definir iteradores que nunca terminam. Por exemplo, o iterador a seguir
retorna inteiros sucessivos a partir de um valor inicial. 
\footnote{Como a representação do tipo \prog{int} é finita, os números acabaram em $2^{31}$.}.
\begin{lstlisting}
def from(start: Int) = new Iterator[Int] {
  private var last = start - 1
  def hasNext = true
  def next = { last += 1; last }
}
\end{lstlisting}

\section{Usando Iteradores}

Existem mais 2 exemplos de como os iteradores são usados. Primeiro, para imprimir todos
os elementos de um vetor \code{xs: Array[Int]}, uma pessoa pode escrever:
\begin{lstlisting}
  Iterator.fromArray(xs) foreach (x => println(x))
\end{lstlisting}
Ou, usando for-comprehension:
\begin{lstlisting}
  for (x <- Iterator.fromArray(xs))
    println(x)
\end{lstlisting}
Como um segundo exemplo, considere o problema de encontrar os índices de todos os elementos de um vetor de \code{double}s maiores que um dado \code{limit}. Os índices devem ser retornado na forma de um iterador.
Isto pode ser obtido pela expressão:
\begin{lstlisting}
import Iterator._
fromArray(xs)
.zip(from(0))
.filter(case (x, i) => x > limit)
.map(case (x, i) => i)
\end{lstlisting}
Ou usando for-comprehension:
\begin{lstlisting}
import Iterator._
for ((x, i) <- fromArray(xs) zip from(0); x > limit)
yield i
\end{lstlisting}

\chapter{Valores Preguiçosos (Lazy)}

Valores preguiçosos oferecem uma maneira de postergar a inicialização de um valor até o primeiro 
momento em que seja acessado. Isto pode ser útil quando estiver lidando com valores que podem não ser
necessários durante a execução e cujo custo computacional seja significativo. Como primeiro exemplo,
vamos considerar um banco de dados de empregados contendo cada empregado e seu gestor e sua equipe.
\begin{lstlisting}
case class Employee(id: Int, 
                    name: String, 
                    managerId: Int) {
  val manager: Employee = Db.get(managerId)
  val team: List[Employee] = Db.team(id)
}
\end{lstlisting}

A classe \lstinline@Employee@ dada anteriormente irá tentar inicializar todos os seus campos, carregando todoa a tabela
de empregados na memória. Isto certamente não é o ideal e pode ser melhorado como facilidade tornando os campos
preguiçosos. Desta forma, atrasamos o acesso ao banco de dados até o momento em que ele seja realmente necessário, se isto ocorrer.
\begin{lstlisting}
case class Employee(id: Int, 
                    name: String, 
                    managerId: Int) {
  lazy val manager: Employee = Db.get(managerId)
  lazy val team: List[Employee] = Db.team(id)
}
\end{lstlisting}
Para ver o que realmente está acontecendo, podemos usar este banco de dados mock
que mostra quando os registros são acessados:
\begin{lstlisting}
object Db {
  val table = Map(1 -> (1, "Haruki Murakami", -1),
                  2 -> (2, "Milan Kundera", 1),
                  3 -> (3, "Jeffrey Eugenides", 1),
                  4 -> (4, "Mario Vargas Llosa", 1),
                  5 -> (5, "Julian Barnes", 2))

  def team(id: Int) = {
    for (rec <- table.values.toList; if rec._3 == id)
      yield recToEmployee(rec)
  }

  def get(id: Int) = recToEmployee(table(id))

  private def recToEmployee(rec: (Int, String, Int)) = {
    println("[db] fetching " + rec._1)
    Employee(rec._1, rec._2, rec._3)
  }
}
\end{lstlisting}
Ao rodar o programa, a saída confirma que ele retorna um empregado e que
o banco somente é acessado quando é feita uma referência ao valor preguiçoso.

Um outro uso dos valores preguiçosos é para resolver a ordem de inicialização
de aplicações compostas de muitos módulos. Antes dos valores preguiçosos serem
criados, o mesmo efeito era conquistado usando definições do tipo \lstinline@object@. 
Como um segundo exemplo considere um compilador composto de diversos módulos. Olhamos
primeiro para uma tabela de símbolos que definie uma classe para símbolos e duas funções pré-definidas.
\begin{lstlisting}
class Symbols(val compiler: Compiler) {
  import compiler.types._

  val Add = new Symbol("+", FunType(List(IntType, IntType), IntType))
  val Sub = new Symbol("-", FunType(List(IntType, IntType), IntType))

  class Symbol(name: String, tpe: Type) {
    override def toString = name + ": " + tpe
  }
}
\end{lstlisting}
O módulo  \lstinline@Symbols@ é parametrizado com uma instância de  \lstinline@Compiler@
que permite o acesso a outros serviços, tais como o módulo de tipos. Em nosso exemplo, há somente
duas funções pré-definidas, adição e subtração e suas definições dependem do módulo \lstinline@types@.
\begin{lstlisting}
class Types(val compiler: Compiler) {
  import compiler.symtab._

  abstract class Type
  case class FunType(args: List[Type], res: Type) extends Type
  case class NamedType(sym: Symbol) extends Type
  case object IntType extends Type
}
\end{lstlisting}
Para conectar os dois componentes, um objeto do tipo compilador é criado e passado com parâmetro para os
dois componentes.
\begin{lstlisting}
class Compiler {
  val symtab = new Symbols(this)
  val types  = new Types(this)
}
\end{lstlisting}
Infelizmente, esta abordagem falha em tempo de execução, pois o módulo 
\lstinline@symtab@ depende do módulo  \lstinline@types@. De maneira geral,
a dependência entre os módulos pode ficar complicada e conseguir a ordem correta
de inicialização é difícil ou, até mesmo, impossível, quando existem dependências cíclicas.
A maneira mais simples de corrigir este erro é tornar estes campos 
\lstinline@lazy@ e deixar o compilador descobrir qual é a ordem correta de inicialização.
\begin{lstlisting}
class Compiler {
  lazy val symtab = new Symbols(this)
  lazy val types  = new Types(this)
}
\end{lstlisting}
Aogra os dois módulos são inicializados no primeiro acesso e o compilador pode executar da forma
esperada.

\subsection*{Sintaxe}
O modificador \lstinline@lazy@ é permitido apenas na definição de valores concretos.
Todas as regras válidas para definição de valores se aplicam também para valores do tipo 
\lstinline@lazy@, com uma restrição a menos: valores locais recursivos são permitidos.

\chapter{Parâmetros Implícitos e Conversões}\label{sec:implicits}

Parâmetros implícitos e conversões são ferramentas poderosas para
personalizar bibliotecas existentes e para criar abstrações de
alto-nível.  Como exemplo, vamos começar com uma classe
abstrata \lstinline@SemiGroup@ que contém uma operação não
especificada chamada \lstinline@add@.
\begin{lstlisting}
abstract class SemiGroup[A] {
  def add(x: A, y: A): A
}
\end{lstlisting}
Aqui está a sub-classe abstrata \lstinline@Monoid@ que herda de  \lstinline@SemiGroup@ e inclui um novo elemento
\lstinline@unit@.
\begin{lstlisting}
abstract class Monoid[A] extends SemiGroup[A] {
  def unit: A
}
\end{lstlisting}
Aqui estão duas implementações de \lstinline@Monoid@:
\begin{lstlisting}
object stringMonoid extends Monoid[String] {
  def add(x: String, y: String): String = x.concat(y)
  def unit: String = ""
}

object intMonoid extends Monoid[Int] {
  def add(x: Int, y: Int): Int = x + y
  def unit: Int = 0
}
\end{lstlisting}
O método \lstinline@sum@, que funciona com monoids arbitrários pode ser escrito em Scala da seguinte forma:
\begin{lstlisting}
def sum[A](xs: List[A])(m: Monoid[A]): A =
  if (xs.isEmpty) m.unit
  else m.add(xs.head, sum(m)(xs.tail)
\end{lstlisting}
O método \lstinline@sum@ pode ser chamado da seguinte forma:
\begin{lstlisting}
sum(List("a", "bc", "def"))(stringMonoid)
sum(List(1, 2, 3))(intMonoid)
\end{lstlisting}
Embora tudo isso funcione, o código não fica muito limpo. O problema
é que as implementações de monoid tem que ser passada para todo o código que as usa.
Nós gostaríamos que o sistema conseguisse descobrir os argumentos de forma correta e automática, semelhante
ao que é feito quando o tipo de parâmetros é inferido. Isto é o que os parâmetros implícitos permite.

\subsection*{Noções Básicas sobre Parâmetros Implícitos}

Na versão 2 de Scala, há uma nova palavra-chave (\lstinline@implicit@) que pode ser usada no início de uma lista de parâmetros. Sintaxe:
\begin{lstlisting}
ParamClauses ::= {`(' [Param {`,' Param}] ')'} 
                 [`(' implicit Param {`,' Param} `)']
\end{lstlisting}
Se esta palavra chave estiver presente, todos os parâmetros da lista serão implícitos.
Por exemplo, a versão de \lstinline@sum@ a seguir tem 
\lstinline@m@ como um parâmetro implícito.
\begin{lstlisting}
def sum[A](xs: List[A])(implicit m: Monoid[A]): A =
  if (xs.isEmpty) m.unit
  else m.add(xs.head, sum(xs.tail))
\end{lstlisting}
Como pode ser visto no exemplo, é possível combinar parâmetros normais e implícitos. No entanto,
pode haver apenas uma lista de parâmetros implícitos e ela deve vir por último.

\lstinline@implicit@ também pode ser usado como um modificador de declarações e definições. Exemplos:

\begin{lstlisting}
implicit object stringMonoid extends Monoid[String] {
  def add(x: String, y: String): String = x.concat(y)
  def unit: String = ""
}
implicit object intMonoid extends Monoid[Int] {
  def add(x: Int, y: Int): Int = x + y
  def unit: Int = 0
}
\end{lstlisting}

A principal ideia por trás de parâmetros implícitos é que argumentos para eles
podem ser omitidos em uma chamada de método. Se os argumentos estiverem ausentes,
eles serão inferidos pelo compilador de Scala.

Os argumento atuais que são elegíveis a serem passados implicitamente por parâmetro são
todos os identificadores X que puderem ser acessado no ponto em que o método é chamado sem
o uso de prefixo e que denotem uma definição implícita ou parâmetro.

Se existem mais do que um argumento elegíveis que casam com o tipo do parâmetro, o compilador Scala vai
escolher o mais específico usando as regras padrâo para resolução de sobrecarga.
Por exemplo, dada a chamada
\begin{lstlisting}
  sum(List(1, 2, 3))
\end{lstlisting}
está em um contexto onde \lstinline@stringMonoid@ e \lstinline@intMonoid@
estão visíveis. Nós sabemos que o tipo genérico \lstinline@A@ do método
\lstinline@sum@ precisa ser instanciado usando \lstinline@int@. O único valor elegível que casa com
o parâmetro implícito \lstinline@Monoid[Int]@ é o \lstinline@intMonoid@ e por isso este objeto será passado
como parâmetro implícito.

A discussão mostra também que parâmetros implícitos são inferidos depois que o tipo dos outros parâmetros
são inferidos.

\subsection*{Conversões Implícitas}

Digamos que você tenha uma expressão $E$ do tipo $T$ onde é esperado um tipo
$S$. $T$ não é um sub-tipo de $S$ e nem é conversível para $S$ por alguma conversão pré-definida. 
Nesse caso, o compilador Scala irá tentar como um último recurso uma conversão implícita  $I(E)$. 
Onde, $I$ é um identificador que denota a definição implícita ou parâmetro que seja acessível sem prefixo
no ponto da conversão e que contenha uma função ao qual podem ser usados como argumentos valores do tipo  $T$ 
e cujo resultado seja do tipo $S$ ou sub-tipo do mesmo.

Conversões Implícitas podem também ser usadas na seleção de membros.
Dada a chamada $E.x$ onde $x$ não é um membro do tipo $E$, o compilador
Scala irá tentar inserir uma conversão implícita $I(E).x$, de maneira que $x$ seja um membro de $I(E)$.

Aqui está um exemplo de uma função de conversão implícita que converte 
inteiros em instâncias da classe \lstinline@scala.Ordered@:
\begin{lstlisting}
implicit def int2ordered(x: Int): Ordered[Int] = new Ordered[Int] {
  def compare(y: Int): Int =
    if (x < y) -1
    else if (x > y) 1
    else 0
}
\end{lstlisting}

\subsection*{Parâmetros de Tipos Delimitados}

Parâmetros de Tipos Delimitados\footnote{View bounds} são uma sintaxe simplificada\footnote{Syntactic sugar}
 e conveniente para parâmetros implícitos. 
Considere por exemplo, um método de ordenação genérico:
\begin{lstlisting}
def sort[A <$\mbox{\%}$ Ordered[A]](xs: List[A]): List[A] =
  if (xs.isEmpty || xs.tail.isEmpty) xs
  else {
    val {ys, zs} = xs.splitAt(xs.length / 2)
    merge(ys, zs)
  }
\end{lstlisting}
O parâmetros de tipo delimitado \lstinline@[A <$\mbox{\%}$ Ordered[A]]@
expressa que  \lstinline@sort@ pode ser usado com listas do tipo 
\lstinline@A@ onde exista uma conversão implícita de 
\lstinline@A@ para \lstinline@Ordered[A]@. A definição é tratada como um atalho para a seguinte
assinatura de método com parâmetro implícito:
\begin{lstlisting}
def sort[A](xs: List[A])(implicit $c$: A => Ordered[A]): List[A] = ...
\end{lstlisting}
(Aqui o nome do parâmetro $c$ foi escolhido arbitrariamente, garantindo-se que 
não era um nome já usado no programa.)

Como um exemplo mais detalhado, considere o método \lstinline@merge@ que vêm com
o método \lstinline@sort@ citado anteriormente:
\begin{lstlisting}
def merge[A <$\mbox{\%}$ Ordered[A]](xs: List[A], ys: List[A]): List[A] =
  if (xs.isEmpty) ys
  else if (ys.isEmpty) xs
  else if (xs.head < ys.head) xs.head :: merge(xs.tail, ys)
  else if ys.head :: merge(xs, ys.tail)
\end{lstlisting}
Depois de expandir os parâmetros de tipo delimitado e inserir as conversões implícitas
a implementação deste método ficaria assim:
\begin{lstlisting}
def merge[A](xs: List[A], ys: List[A])
            (implicit $c$: A => Ordered[A]): List[A] =
  if (xs.isEmpty) ys
  else if (ys.isEmpty) xs
  else if (c(xs.head) < ys.head) xs.head :: merge(xs.tail, ys)
  else if ys.head :: merge(xs, ys.tail)(c)
\end{lstlisting}

As duas últimas linhas da definição do método ilustram dois diferentes usos
do parâmetro implícito $c$. Ele é usado na conversão da condição na penúltima linha e passado
como parãmetro implícito na chamada recursiva de \lstinline@merge@ na última linha.

\comment{
\chapter{Combinator Parsing}\label{sec:combinator-parsing}

In this chapter we describe how to write combinator parsers in
Scala. Such parsers are constructed from predefined higher-order
functions, so called {\em parser combinators}, that closely model the
constructions of an EBNF grammar \cite{wirth:ebnf}.

As running example, we consider parsers for possibly nested
lists of identifiers and numbers, which
are described by the following context-free grammar.
\bda{p{3cm}cp{10cm}}
letter &::=& /* all letters */ \\
digit  &::=& /* all digits */ \\[0.5em]
ident  &::=& letter \{letter $|$ digit \}\\
number &::=& digit \{digit\}\\[0.5em]
list   &::=& `(' [listElems] `)' \\
listElems &::=& expr [`,' listElems] \\
expr   &::=& ident | number | list

\eda

\section{Simple Combinator Parsing}

In this section we will only be concerned with the task of recognizing
input strings, not with processing them. So we can describe parsers
by the sets of input strings they accept.  There are two
fundamental operators over parsers:
\code{&} expresses the sequential composition of a parser with
another, while \code{|} expresses an alternative. These operations
will both be defined as methods of a \code{Parser} class.  We will
also define constructors for the following primitive parsers:

\begin{tabular}{ll}
\code{empty}    & The parser that accepts the empty string
\\
\code{failure(msg: String)}  & The parser that accepts no string (\verb@msg@ 
                               stands for an error message)

\\
\code{chr(c: char)}
                & The parser that accepts the single-character string ``$c$''.
\\
\code{chrSuchThat(p: Char => Boolean)}
                & The parser that accepts single-character strings
                  ``$c$'' \\
                & for which $p(c)$ is true.
\end{tabular}

There are also the two higher-order parser combinators \code{opt},
expressing optionality and \code{rep}, expressing repetition.
For any parser $p$, \code{opt(}$p$\code{)} yields a parser that
accepts the strings accepted by $p$ or else the empty string, while
\code{rep(}$p$\code{)} accepts arbitrary sequences of the strings accepted by
$p$. In EBNF, \code{opt(}$p$\code{)} corresponds to $[p]$ and
\code{rep(}$p$\code{)} corresponds to $\{p\}$.

The central idea of parser combinators is that parsers can be produced
by a straightforward rewrite of the grammar, replacing \code{::=} with
\code{=}, sequencing with
\code{&}, repetition \code{\{...\}} with
\code{rep(...)} and optional occurrence \code{[...]} with \code{opt(...)}.
Applying this process to the grammar of lists
yields the following trait.
\begin{lstlisting}
trait ListParsers extends Parsers {
  def chrSuchThat(p: Char => Boolean): Parser
  def chr(c: Char): Parser = chrSuchThat(d ==)

  def letter    : Parser = chr(Character.isLetter)
  def digit     : Parser = chr(Character.isDigit)

  def ident     : Parser = letter &&& rep(letter ||| digit)
  def number    : Parser = digit &&& rep(digit)
  def list      : Parser = chr('(') &&& opt(listElems) &&& chr(')')
  def listElems : Parser = expr &&& (chr(',') &&& listElems ||| empty)
  def expr      : Parser = ident ||| number ||| list
}
\end{lstlisting}
This class isolates the grammar from other aspects of parsing. It
abstracts over the type of input 
and over the method used to parse a single character
(represented by the abstract method \code{chr(p: char =>
boolean))}. The missing bits of information need to be supplied by code
applying the parser class.

It remains to explain how to implement a library with the combinators
described above. We will pack combinators and their underlying
implementation in a base class \code{Parsers}, which is inherited by
\code{ListParsers}.  The first question to decide is which underlying
representation type to use for a parser. We treat parsers here
essentially as functions that take a datum of the input type
\code{InType} and that yield a parse result of type
\code{Option[InType]}.  The \code{Option} type is predefined as
follows.
\begin{lstlisting}
abstract class Option[+a]
case object None extends Option[Nothing]
case class Some[a](x: a) extends Option[a]
\end{lstlisting}
A parser applied to some input either succeeds or fails. If it fails,
it returns the constant \code{None}. If it succeeds, it returns a
value of the form \code{Some(in1)} where \code{in1} represents the
input that remains to be parsed.
\begin{lstlisting}
trait Parsers {
  type InType
  abstract class Parser {
    type Result = Option[InType]
    def apply(in: InType): Result
\end{lstlisting}
A parser also implements the combinators
for sequence and alternative:
\begin{lstlisting}
  /*** p &&& q applies first p, and if that succeeds, then q
   */
  def &&& (q: => Parser) = new Parser {
    def apply(in: InType): Result = Parser.this.apply(in) match {
      case None => None
      case Some(in1)  => q(in1)
    }
  }

  /*** p ||| q applies first p, and, if that fails, then q.
   */
  def ||| (q: => Parser) = new Parser {
    def apply(in: InType): Result = Parser.this.apply(in) match {
      case None => q(in)
      case s => s
    }
  }
\end{lstlisting}
The implementations of the primitive parsers \code{empty} and \code{fail}
are trivial:
\begin{lstlisting}
  val empty = new Parser { def apply(in: InType): Result = Some(in) }
  val fail  = new Parser { def apply(in: InType): Result = None }
\end{lstlisting}
The higher-order parser combinators \code{opt} and \code{rep} can be
defined in terms of the combinators for sequence and alternative:
\begin{lstlisting}
  def opt(p: Parser): Parser = p ||| empty;    // p? = (p | <empty>)
  def rep(p: Parser): Parser = opt(rep1(p));   // p* = [p+]
  def rep1(p: Parser): Parser = p &&& rep(p);  // p+ = p p*
} // end Parser
\end{lstlisting}
To run combinator parsers, we still need to decide on a way to handle
parser input. Several possibilities exist: The input could be
represented as a list, as an array, or as a random access file.  Note
that the presented combinator parsers use backtracking to change from
one alternative to another.  Therefore, it must be possible to reset
input to a point that was previously parsed. If one restricted the
focus to LL(1) grammars, a non-backtracking implementation of the
parser combinators in class \code{Parsers} would also be possible. In
that case sequential input methods based on (say) iterators or
sequential files would also be possible.

In our example, we represent the input by a pair of a string, which
contains the input phrase as a whole, and an index, which represents
the portion of the input which has not yet been parsed. Since the
input string does not change, just the index needs to be passed around
as a result of individual parse steps.  This leads to the following
class of parsers that read strings:
\begin{lstlisting}
class ParseString(s: String) extends Parsers {
  type InType = Int
  def chrSuchThat(p: Char => Boolean) = new Parser {
    def apply(in: Int): Parser#Result =
      if (in < s.length() && p(s charAt in)) Some(in + 1)
      else None
  }
  val input = 0
}
\end{lstlisting}
This class implements a method \code{chr(p: Char => Boolean)} and a
value \code{input}. The \code{chr} method builds a parser that either
reads a single character satisfying the given predicate \code{p} or
fails.  All other parsers over strings are ultimately implemented in
terms of that method. The \code{input} value represents the input as a
whole. In out case, it is simply value \code{0}, the start index of
the string to be read.

Note \code{apply}'s result type, \code{Parser#Result}. This syntax
selects the type element \code{Result} of the type \code{Parser}. It
thus corresponds roughly to selecting a static inner class from some
outer class in Java. Note that we could {\em not} have written
\code{Parser.Result}, as the latter would express selection of the
\code{Result} element from a {\em value} named \code{Parser}.

We have now extended the root class \code{Parsers} in two different
directions: Class \code{ListParsers} defines a grammar of phrases to
be parsed, whereas class \code{ParseString} defines a method by which
such phrases are input. To write a concrete parsing application, we
need to define both grammar and input method. We do this by combining
two extensions of \code{Parsers} using a {\em mixin composition}.
Here is the start of a sample application:
\begin{lstlisting}
object Test {
  def main(args: Array[String]) {
    val ps = new ParseString(args(0)) with ListParsers
  }
\end{lstlisting}
The last line above creates a new family of parsers by composing class
\code{ListParsers} with class \code{ParseString}. The two classes
share the common superclass \code{Parsers}. The abstract method
\code{chr} in \code{ListParsers} is implemented by class \code{ParseString}.

To run the parser, we apply the start symbol of the grammar
\code{expr} the argument code{input} and observe the result:
\begin{lstlisting}
    ps.expr(ps.input) match {
      case Some(n) =>
        println("parsed: " + args(0).substring(0, n))
      case None =>
        println("nothing parsed")
    }
  }
}// end Test
\end{lstlisting}
Note the syntax ~\code{ps.expr(input)}, which treats the \code{expr}
parser as if it was a function. In Scala, objects with \code{apply}
methods can be applied directly to arguments as if they were functions.

Here is an example run of the program above:
\begin{lstlisting}
> java examples.Test "(x,1,(y,z))"
parsed: (x,1,(y,z))
> java examples.Test "(x,,1,(y,z))"
nothing parsed
\end{lstlisting}

\section{\label{sec:parsers-results}Parsers that Produce Results}

The combinator library of the previous section does not support the
generation of output from parsing. But usually one does not just want
to check whether a given string belongs to the defined language, one
also wants to convert the input string into some internal
representation such as an abstract syntax tree.

In this section, we modify our parser library to build parsers that
produce results. We will make use of the for-comprehensions introduced
in Chapter~\ref{sec:for-notation}.  The basic combinator of sequential
composition, formerly ~\code{p &&& q}, now becomes
\begin{lstlisting}
for (x <- p; y <- q) yield e .
\end{lstlisting}
Here, the names \code{x} and \code{y} are bound to the results of
executing the parsers \code{p} and \code{q}. \code{e} is an expression
that uses these results to build the tree returned by the composed
parser.

Before describing the implementation of the new parser combinators, we
explain how the new building blocks are used. Say we want to modify
our list parser so that it returns an abstract syntax tree of the
parsed expression. Syntax trees are given by the following class hierarchy:
\begin{lstlisting}
abstract class Tree
case class Id (s: String)         extends Tree
case class Num(n: Int)            extends Tree
case class Lst(elems: List[Tree]) extends Tree
\end{lstlisting}
That is, a syntax tree is an identifier, an integer number, or a
\code{Lst} node with a list of trees as descendants.

As a first step towards parsers that produce results we define three
little parsers that return a single read character as result.
\begin{lstlisting}
trait CharParsers extends Parsers {
  def any: Parser[Char]
  def chr(ch: Char): Parser[Char] =
    for (c <- any if c == ch) yield c
  def chrSuchThat(p: Char => Boolean): Parser[Char] =
    for (c <- any if p(c)) yield c
}
\end{lstlisting}
The \code{any} parser succeeds with the first character of remaining
input as long as input is nonempty. It is abstract in class
\code{ListParsers} since we want to abstract in this class from the
concrete input method used.  The two \code{chr} parsers return as before
the first input character if it equals a given character or matches a
given predicate. They are now implemented in terms of \code{any}.

The next level is represented by parsers reading identifiers, numbers
and lists. Here is a parser for identifiers.
\begin{lstlisting}
trait ListParsers extends CharParsers {
  def ident: Parser[Tree] = 
    for {
      c: Char <- chrSuchThat(Character.isLetter)
      cs: List[Char] <- rep(chrSuchThat(Character.isLetterOrDigit))
    } yield Id((c :: cs).mkString("", "", ""))
\end{lstlisting}
Remark: Because \code{chrSuchThat(...)} returns a single character, its
repetition \code{rep(chrSuchThat(...))} returns a list of characters. The
\code{yield} part of the for-comprehension converts all intermediate
results into an \code{Id} node with a string as element.  To convert
the read characters into a string, it conses them into a single list,
and invokes the \code{mkString} method on the result.

Here is a parser for numbers:
\begin{lstlisting}
  def number: Parser[Tree] =
    for {
      d: Char <- chrSuchThat(Character.isDigit)
      ds: List[Char] <- rep(chrSuchThat(Character.isDigit))
    } yield Num(((d - '0') /: ds) ((x, digit) => x * 10 + digit - '0'))
\end{lstlisting}
Intermediate results are in this case the leading digit of
the read number, followed by a list of remaining digits.  The
\code{yield} part of the for-comprehension reduces these to a number
by a fold-left operation.

Here is a parser for lists:
\begin{lstlisting}
  def list: Parser[Tree] = 
    for {
      _ <- chr('(')
      es <- listElems ||| succeed(List())
      _ <- chr(')')
    } yield Lst(es)

  def listElems: Parser[List[Tree]] = 
    for {
      x <- expr
      xs <- chr(',') &&& listElems ||| succeed(List())
    } yield x :: xs
\end{lstlisting}
The \code{list} parser returns a \code{Lst} node with a list of trees
as elements.  That list is either the result of \code{listElems}, or,
if that fails, the empty list (expressed here as: the result of a
parser which always succeeds with the empty list as result).

The highest level of our grammar is represented by function
\code{expr}:
\begin{lstlisting}
  def expr: Parser[Tree] = 
    ident ||| number ||| list
}// end ListParsers.
\end{lstlisting}
We now present the parser combinators that support the new
scheme. Parsers that succeed now return a parse result besides the
un-consumed input.
\begin{lstlisting}
trait Parsers {
  type InType
  abstract class Parser[A] {
    type Result = Option[(A, InType)]
    def apply(in: InType): Result
\end{lstlisting}
Parsers are parameterized with the type of their result. The class
\code{Parser[a]} now defines new methods \code{map}, \code{flatMap}
and \code{filter}. The \code{for} expressions are mapped by the
compiler to calls of these functions using the scheme described in
Chapter~\ref{sec:for-notation}. For parsers, these methods are
implemented as follows.
\begin{lstlisting}
    def filter(pred: A => Boolean) = new Parser[A] {
      def apply(in: InType): Result = Parser.this.apply(in) match {
        case None => None
        case Some(x, in1) => if (pred(x)) Some(x, in1) else None
      }
    }
    def map[B](f: A => B) = new Parser[B] {
      def apply(in: InType): Result = Parser.this.apply(in) match {
        case None => None
        case Some(x, in1) => Some(f(x), in1)
      }
    }
    def flatMap[b](f: A => Parser[B]) = new Parser[B] {
      def apply(in: InType): Result = Parser.this.apply(in) match {
        case None => None
        case Some(x, in1) => f(x).apply(in1)
      }
    }
\end{lstlisting}
The \code{filter} method takes as parameter a predicate $p$ which it
applies to the results of the current parser. If the predicate is
false, the parser fails by returning \code{None}; otherwise it returns
the result of the current parser.  The \code{map} method takes as
parameter a function $f$ which it applies to the results of the
current parser. The \code{flatMap} takes as parameter a function
\code{f} which returns a parser.  It applies \code{f} to the result of
the current parser and then continues with the resulting parser.  The
\code{|||} method is essentially defined as before.  The
\code{&&&} method can now be defined in terms of \code{for}.
\begin{lstlisting}
    def ||| (p: => Parser[A]) = new Parser[A] {
      def apply(in: InType): Result = Parser.this.apply(in) match {
        case None => p(in)
        case s => s
      }
    }

    def &&& [B](p: => Parser[B]): Parser[B] =
      for (_ <- this; x <- p) yield x
  }// end Parser
\end{lstlisting}

The primitive parser \code{succeed} replaces \code{empty}. It consumes
no input and returns its parameter as result.
\begin{lstlisting}
  def succeed[A](x: A) = new Parser[A] {
    def apply(in: InType) = Some(x, in)
  }
\end{lstlisting}

The parser combinators \code{rep} and \code{opt} now also return
results. \code{rep} returns a list which contains as elements the
results of each iteration of its sub-parser. \code{opt} returns a list
which is either empty or returns as single element the result of the
optional parser.
\begin{lstlisting}
  def rep[A](p: Parser[A]): Parser[List[A]] =
    rep1(p) ||| succeed(List())

  def rep1[A](p: Parser[A]): Parser[List[A]] =
    for (x <- p; xs <- rep(p)) yield x :: xs

  def opt[A](p: Parser[A]): Parser[List[A]] =
    (for (x <- p) yield List(x)) ||| succeed(List())
} // end Parsers
\end{lstlisting}
The root class \code{Parsers} abstracts over which kind of
input is parsed.  As before, we determine the input method by a separate class.
Here is \code{ParseString}, this time adapted to parsers that return results.
It defines now the method \code{any}, which returns the first input character.
\begin{lstlisting}
class ParseString(s: String) extends Parsers {
  type InType = Int
  val input = 0
  def any = new Parser[Char] {
    def apply(in: Int): Parser[Char]#Result =
      if (in < s.length()) Some(s charAt in, in + 1) else None
  }
}
\end{lstlisting}
The rest of the application is as before. Here is a test program which
constructs a list parser over strings and prints out the result of
applying it to the command line argument.
\begin{lstlisting}
object Test {
  def main(args: Array[String]) {
    val ps = new ParseString(args(0)) with ListParsers
    ps.expr(ps.input) match {
      case Some(list, _) => println("parsed: " + list)
      case None => println("nothing parsed")
    }
  }
}
\end{lstlisting}

\begin{exercise}\label{exercise:end-marker} The parsers we have defined so
far can succeed even if there is some input beyond the parsed text. To
prevent this, one needs a parser which recognizes the end of input.
Redesign the parser library so that such a parser can be introduced.
Which classes need to be modified?
\end{exercise}
}

\chapter{\label{sec:hm}Inferência de Tipos de Hindley/Milner}

Este capítulo demonstra os tipos de dados Scala e o casamento de padrôes através
do desenvolvimento de um sistema de inferência de tipos no estilo de Hindley/Milner
\cite{milner:polymorphism}. 
A linguagem fonte para a inferência de tipos é o cálculo lambda com uma construção
chamada Mini-ML. As árvoes de sintaxe abstrata para o Mini-ML 
são representadas através do tipo de dados \code{Terms}.
\begin{lstlisting}
abstract class Term {}
case class Var(x: String) extends Term {
  override def toString = x
}
case class Lam(x: String, e: Term) extends Term {
  override def toString = "(\\" + x + "." + e + ")"
}
case class App(f: Term, e: Term) extends Term {
  override def toString = "(" + f + " " + e + ")"
}
case class Let(x: String, e: Term, f: Term) extends Term {
  override def toString = "let " + x + " = " + e + " in " + f
}
\end{lstlisting}
Há quatro construtores de termos: \code{Var} para variáveis, \code{Lam}
para abstrações lambda, \code{App} para aplicação e
\code{Let} para expressões de atribuição. Cada uma destas classes sobrescreve o método
\code{toString} da classe \code{Any}, de forma que os termos podem ser impressos
de forma legível.

A seguir, definimos os tipos que serão computados pelo sistema de inferência.
\begin{lstlisting}
sealed abstract class Type {}
case class Tyvar(a: String) extends Type {
  override def toString = a
}
case class Arrow(t1: Type, t2: Type) extends Type {
  override def toString = "(" + t1 + "->" + t2 + ")"
}
case class Tycon(k: String, ts: List[Type]) extends Type {
  override def toString = 
    k + (if (ts.isEmpty) "" else ts.mkString("[", ",", "]"))
}
\end{lstlisting}
Há três construtores de tipos: \code{Tyvar} para o tipo variável,
\code{Arrow}  para o tipo função e  \code{Tycon}  para o tipo construtor como,
por exemplo, \code{Boolean} ou \code{List}. O tipo construtor tem como
componente uma lista de tipos que contem seus parâmetros. Esta lista é
vaiz para tipos constantes como \code{Boolean}. Assim como nos construtores
de termos, implementamos o método \code{toString} para mostrar os tipos de forma legível.

Note que \code{Type} foi declarada com o modificador \code{sealed}. Isto significa que
nenhuma sub-classe ou construtores de dados que extendam \code{Type} podem ser declarados fora
da sequência de definições em que \code{Type} foi definida.
Isto torna \code{Type} um tipo algébrico {\em fechado}  com exatas três alternativas. 
Em contraste, o tipo \code{Term} is um tipo algébrico {\em aberto} onde mais alternativas
poderâo ser definidas.

As principais partes da inferência de tipos estão contidas no objeto
\code{typeInfer}. Começamos com uma função utilitária que cria novos tipos variáveis:
\begin{lstlisting}
object typeInfer {
  private var n: Int = 0
  def newTyvar(): Type = { n += 1; Tyvar("a" + n) }
\end{lstlisting}
Em seguinda, definimos uma classe para substituições.
A substituição é uma função idempotente de tipos variáveis para tipos.
Ela mapeia um número finito de tipos variáveis para alguns tipos e não modifica todos 
os outros tipos.
O significado de uma substituição é extendido a partir de um mapeamento de tipos para tipos.
Também extendemos o significado da substituição para ambientes que serão definidos posteriormente.
\begin{lstlisting}
  abstract class Subst extends Function1[Type,Type] {

    def lookup(x: Tyvar): Type

    def apply(t: Type): Type = t match {
      case tv @ Tyvar(a) => val u = lookup(tv); if (t == u) t else apply(u)
      case Arrow(t1, t2) => Arrow(apply(t1), apply(t2))
      case Tycon(k, ts) => Tycon(k, ts map apply)
    }

    def apply(env: Env): Env = env.map({ case (x, TypeScheme(tyvars, tpe)) =>
      // assume que tyvars nao ocorre nesta substituicao
      (x, TypeScheme(tyvars, apply(tpe)))
    })

    def extend(x: Tyvar, t: Type) = new Subst {
      def lookup(y: Tyvar): Type = if (x == y) t else Subst.this.lookup(y)
    }
  }
  val emptySubst = new Subst { def lookup(t: Tyvar): Type = t }
\end{lstlisting}
Representamos substituições como funções do tipo \code{Type =>
Type}. Isto pode ser obtido fazendo com que a classe  \code{Subst} herde da tipo função unária  
\code{Function1[Type, Type]}\footnote{
A classe herda do tipo função como um mixin, ao invés de uma super-classe direta.
Isto ocorre porque na implementação atual de Scala, o tipo \code{Function1} é uma interface Java que
não pode ser uma super-classe de uma outra classe.}.
Para ser uma instância de \code{Subst}, uma substituição \code{s} tem que implementar o método \code{apply}
que recebe como argumento um \code{Type} e retorna um outro 
\code{Type} como resultado. A função aplicação \code{s(t)} é interpretada como \code{s.apply(t)}.

O método \code{lookup} é abstrato na classe \code{Subst}.  Existem duas formas concretas de substituição
que diferem em como elas implementam este método. Uma forma é definida pelo valor \code{emptySubst} e a outra
é definida pelo método \code{extend} na classe \code{Subst}.

O próximo tipo de dado descreve esquemas de tipos, que consistem de um tipo
e uma lista de nomes de tipos variáveis que aparecem universalmente quantificados
no esquema de tipos.
Por exemplo o esquema de tipos $\forall a\forall b.a \!\arrow\! b$ seria representado no checador de tipos como:
\begin{lstlisting}
TypeScheme(List(Tyvar("a"), Tyvar("b")), Arrow(Tyvar("a"), Tyvar("b"))) .
\end{lstlisting}
A definição da classe esquema de tipos não contém uma cláusula extends;
isso quer dizer que um esquema de tipos herda diretamente da classe
\code{AnyRef}.  Embora exista apenas uma única maneira de construir um
esquema de tipos, uma representação usando classe case foi escolhida, pois
oferece formas convenientes de acessar as partes de uma instância deste tipo.

\begin{lstlisting}
  case class TypeScheme(tyvars: List[Tyvar], tpe: Type) {
    def newInstance: Type = {
      (emptySubst /: tyvars) ((s, tv) => s.extend(tv, newTyvar())) (tpe)
    }
  }
\end{lstlisting}

Os objetos de esquemas de tipos vem com o método \code{newInstance}, que retorna o
tipo contido no esquema depois de todos os tipos variáveis tiverem sido renomeados
para novas variáveis. A implementação deste método reduz (com \code{/:}) 
os tipos variáveis do esquema de tipos  com uma função que extende uma dada substituição 
\code{s} renomeando um dado tipo variável \code{tv} em um novo tipo variável.
A substituição resultante renomeia todos os tipos variáveis do esquema em novos.
Esta substituição é então aplicada o tipo do esquema de tipos.

O último tipo que necessitamos no sistema de inferência de tipos é 
\code{Env}, um tipo para os ambientes, que associa nomes de variáveis à esquema de tipos. 
Eles são representados pelo tipo \code{Env} no módulo \code{typeInfer}:
\begin{lstlisting}
  type Env = List[(String, TypeScheme)]
\end{lstlisting}
Existem duas operações nos ambientes. A função  \code{lookup} 
retorna o esquema de tipos associado com um dado nome ou \code{null}
se o nome não foi registrado no ambiente.
\begin{lstlisting}
  def lookup(env: Env, x: String): TypeScheme = env match {
    case List() => null
    case (y, t) :: env1 => if (x == y) t else lookup(env1, x)
  }
\end{lstlisting}
A função \code{gen} retorna um esquema de tipos dado um tipo,
quantificando todos os tipos variáveis que estão livres no tipo, mas
não no ambiente.
\begin{lstlisting}
  def gen(env: Env, t: Type): TypeScheme = 
    TypeScheme(tyvars(t) diff tyvars(env), t)
\end{lstlisting}
o conjunto de tipos variáveis livres é simplesmente o conjunto de todos
os tipos variáveis que ocorrem no tipo. É representado por uma lista de tipos
variáveis construído da seguinte maneira.
\begin{lstlisting}
  def tyvars(t: Type): List[Tyvar] = t match {
    case tv @ Tyvar(a) => 
      List(tv)
    case Arrow(t1, t2) => 
      tyvars(t1) union tyvars(t2)
    case Tycon(k, ts) => 
      (List[Tyvar]() /: ts) ((tvs, t) => tvs union tyvars(t))
  }
\end{lstlisting}
Note que a sintaxe \code{tv @ ...} no primeiro padrão introduz a variável 
que está ligada ao padrão seguinte. 
Note também que o tipo parâmetro \code{[Tyvar]} explícito na expressão da terceita cláusula é necessário para
que a inferência de tipos locais funcione.

O conjunto de tipos variáveis livres de um esquema de tipos é o conjunto de tipos variáveis livre do seu tipo componente,
excluíndo-se quaisquer tipos variáveis quantificáveis.
\begin{lstlisting}
  def tyvars(ts: TypeScheme): List[Tyvar] = 
    tyvars(ts.tpe) diff ts.tyvars
\end{lstlisting}
Finalmente, o conjunto  tipos variáveis livres de um ambiente é a união
de todos os  tipos variáveis livres de todos os esquemas de tipos registrados neste ambiente.
\begin{lstlisting}
  def tyvars(env: Env): List[Tyvar] =
    (List[Tyvar]() /: env) ((tvs, nt) => tvs union tyvars(nt._2))
\end{lstlisting}
A principal operação da checagem de tipos de Hindley/Milner é a unificação,
que computa a substituição para fazer que dois tipos dados se tornem iguais
 (esta subsituição é chamada um {\em unificador}\footnote{unifier}).  A função \code{mgu} computa
o unificador mais geral de dois tipos dados $t$ e $u$ sob um substituição pre-existente $s$.  
Isto é, ele retorna a substituição mais geral $s'$ que herda de $s$, e que faz com que $s'(t)$ e
$s'(u)$ retornem tipos iguais. 
\begin{lstlisting}
  def mgu(t: Type, u: Type, s: Subst): Subst = (s(t), s(u)) match {
    case (Tyvar(a), Tyvar(b)) if (a == b) =>
      s
    case (st @ Tyvar(a), su) if !(tyvars(su) contains st) =>
      s.extend(st, su)
    case (_, Tyvar(a)) =>
      mgu(u, t, s)
    case (Arrow(t1, t2), Arrow(u1, u2)) =>
      mgu(t1, u1, mgu(t2, u2, s))
    case (Tycon(k1, ts), Tycon(k2, us)) if (k1 == k2) =>
      (s /: (ts zip us)) ((s, tu) => mgu(tu._1, tu._2, s))
    case _ => 
      throw new TypeError("cannot unify " + s(t) + " with " + s(u))
  }
\end{lstlisting}
A função \code{mgu} lança uma exceção do tipo \code{TypeError} se não existir uma
substituição unificadora. Isto pode ocorrer quando os dois tipos tem diferentes
tipos construtores em seus lugares correspondentes ou quando um tipo variável é 
unificado com um tipo que contém um tipo variável dele mesmo.
Estas exceções foram modeladas como instâncias de classe case que herdam um classe
 \code{Exception} pré-definida.
\begin{lstlisting}
  case class TypeError(s: String) extends Exception(s) {}
\end{lstlisting}
A principal tarefa do checador de tipos é implementada pela função
\code{tp}. Esta função recebe como parâmetro um ambiente $env$,  um termo $e$, um tipo $t$, e
uma substituição pre-existente $s$.  A função retorna uma substituição
$s'$ que herda de  $s$ e que torna $s'(env) \ts e: s'(t)$ num julgamento de tipos derivável de acordo
com as regras de derivação do sistema de tipos de Hindley/Milner\cite{milner:polymorphism}.  Uma exceção do tipo
\code{TypeError} é lançada se não existe uma substituição com estas características.
\begin{lstlisting}
  def tp(env: Env, e: Term, t: Type, s: Subst): Subst = {
    current = e
    e match {
      case Var(x) =>
        val u = lookup(env, x)
        if (u == null) throw new TypeError("undefined: " + x)
        else mgu(u.newInstance, t, s)

      case Lam(x, e1) =>
        val a, b = newTyvar()
        val s1 = mgu(t, Arrow(a, b), s)
        val env1 = {x, TypeScheme(List(), a)} :: env
        tp(env1, e1, b, s1)

      case App(e1, e2) =>
        val a = newTyvar()
        val s1 = tp(env, e1, Arrow(a, t), s)
        tp(env, e2, a, s1)

      case Let(x, e1, e2) =>
        val a = newTyvar()
        val s1 = tp(env, e1, a, s)
        tp({x, gen(s1(env), s1(a))} :: env, e2, t, s1)
    }
  } 
  var current: Term = null
\end{lstlisting}
Para auxiliar no diagnóstico de erros, a função \code{tp} guarda o sub-termo que
está sendo analisado na variável \code{current}. Com isso, se a checagem de tipos
for iterrompido por uma exceção do tipo \code{TypeError}, esta variável conterá o
sub-termo que causou o problema.

A última função do módulo de inferência de tipos , \code{typeOf}, é uma façade simplificada
para \code{tp}. Ela computa o tipo de um dado termo
$e$ em um dado ambiente $env$. Ela o faz através da criação de um novo tipo variável $a$, 
e da computação da substituição de tipos que faz $env \ts e: a$  se tornar um tipo derivado 
e retorna o resultado da aplicação da subsituição em $a$.
\begin{lstlisting}
  def typeOf(env: Env, e: Term): Type = {
    val a = newTyvar()
    tp(env, e, a, emptySubst)(a)
  }
}// fim typeInfer
\end{lstlisting}
Para usar o sistema de inferência de tipos, é conveniente ter um ambiente
pré-definido que contém as definições das constantes mais comumente usadas.
O módulo \code{predefined} define um ambiente \code{env} que contém as definições dos tipos 
booleanos, números e listas assim como algumas operações primitivas sobre eles.
Também define um operador de ponto fixo \code{fix}, que pode ser usado para representar uma
recursão.
\begin{lstlisting}
object predefined {
  val booleanType = Tycon("Boolean", List())
  val intType = Tycon("Int", List())
  def listType(t: Type) = Tycon("List", List(t))

  private def gen(t: Type): typeInfer.TypeScheme = typeInfer.gen(List(), t)
  private val a = typeInfer.newTyvar()
  val env = List(
    {"true", gen(booleanType)},
    {"false", gen(booleanType)},
    {"if", gen(Arrow(booleanType, Arrow(a, Arrow(a, a))))},
    {"zero", gen(intType)},
    {"succ", gen(Arrow(intType, intType))},
    {"nil", gen(listType(a))},
    {"cons", gen(Arrow(a, Arrow(listType(a), listType(a))))},
    {"isEmpty", gen(Arrow(listType(a), booleanType))},
    {"head", gen(Arrow(listType(a), a))},
    {"tail", gen(Arrow(listType(a), listType(a)))},
    {"fix", gen(Arrow(Arrow(a, a), a))}
  )
}
\end{lstlisting}
Aqui está um exemplo de como o sistema de inferência de tipos pode ser
usado. Vamos definir a função \code{showType} que retorna os tipos de um dado
termo computado em um dado ambiente
\code{Predefined.env}:
\begin{lstlisting}
object testInfer {
  def showType(e: Term): String =
    try {
      typeInfer.typeOf(predefined.env, e).toString
    } catch {
      case typeInfer.TypeError(msg) => 
        "\n cannot type: " + typeInfer.current +
        "\n reason: " + msg
    }
\end{lstlisting}
Então a aplicação
\begin{lstlisting}
> testInfer.showType(Lam("x", App(App(Var("cons"), Var("x")), Var("nil"))))
\end{lstlisting}
retornará a resposta
\begin{lstlisting}
> (a6->List[a6])
\end{lstlisting}
\comment{
To make the type inferencer more useful, we complete it with a
parser. 
Function \code{main} of module \code{testInfer}
parses and typechecks a Mini-ML expression which is given as the first
command line argument.
\begin{lstlisting}
  def main(args: Array[String]) {
    val ps = new ParseString(args(0)) with MiniMLParsers
    ps.all(ps.input) match {
      case Some(term, _) =>
        println("" + term + ": " + showType(term))
      case None =>
        println("syntax error")
    }
  }
%}// testInfer
\end{lstlisting}
To do the parsing, method \code{main} uses the combinator parser
scheme of Chapter~\ref{sec:combinator-parsing}. It creates a parser
family \code{ps} as a mixin composition of parsers
that understand MiniML (but do not know where input comes from) and
parsers that read input from a given string.  The \code{MiniMLParsers}
object implements parsers for the following grammar.
\begin{lstlisting}
term  ::= "\" ident "." term
       |  term1 {term1}
       |  "let" ident "=" term "in" term
term1 ::= ident
       |  "(" term ")"
all   ::= term ";"
\end{lstlisting}
Input as a whole is described by the production \code{all}; it
consists of a term followed by a semicolon. We allow ``whitespace''
consisting of one or more space, tabulator or newline characters
between any two lexemes (this is not reflected in the grammar
above). Identifiers are defined as in
Chapter~\ref{sec:combinator-parsing} except that an identifier cannot
be one of the two reserved words "let" and "in".
\begin{lstlisting}
trait MiniMLParsers extends CharParsers {

  /** whitespace */
  def whitespace = rep{chr(' ') ||| chr('\t') ||| chr('\n')}

  /** A given character, possible preceded by whitespace */
  def wschr(ch: Char) = whitespace &&& chr(ch)

  /** identifiers or keywords */
  def id: Parser[String] = 
    for {
      c: Char <- whitespace &&& chrSuchThat(Character.isLetter)
      cs: List[Char] <- rep(chrSuchThat(Character.isLetterOrDigit))
    } yield (c :: cs).mkString("", "", "")

  /** Non-keyword identifiers */
  def ident: Parser[String] =
    for { s <- id if s != "let" && s != "in" } yield s

  /** term = '\' ident '.' term | term1 {term1} | let ident "=" term in term */
  def term: Parser[Term] = (
    ( for {
        _ <- wschr('\\')
        x <- ident
        _ <- wschr('.')
        t <- term
      } yield Lam(x, t): Term )
    |||
    ( for {
        letid <- id if letid == "let"
        x <- ident
        _ <- wschr('=')
        t <- term; 
        inid <- id; inid == "in"
        c <- term
      } yield Let(x, t, c) )
    |||
    ( for {
        t <- term1
        ts <- rep(term1)
      } yield (t /: ts)((f, arg) => App(f, arg)) )
  )     

  /** term1 = ident | '(' term ')' */
  def term1: Parser[Term] = (
    ( for { s <- ident }
      yield Var(s): Term )
    |||
    ( for {
        _ <- wschr('(')
        t <- term
        _ <- wschr(')')
      } yield t )
  )

  /** all = term ';' */
  def all: Parser[Term] = 
    for {
      t <- term
      _ <- wschr(';')
    } yield t
}
\end{lstlisting}
Aqui estão alguns exemplos de programas MiniML e a saída que o sistema de inferência de tipos retorna para cada um deles:
\begin{lstlisting}
> java testInfer
| "\x.\f.f(f x);"
(\x.(\f.(f (f x)))): (a8->((a8->a8)->a8))

> java testInfer 
| "let id = \x.x  
|  in if (id true) (id nil) (id (cons zero nil));"
let id = (\x.x) in (((if (id true)) (id nil)) (id ((cons zero) nil))): List[Int]

> java testInfer
| "let id = \x.x 
|  in if (id true) (id nil);"
let id = (\x.x) in ((if (id true)) (id nil)): (List[a13]->List[a13])

> java testInfer
| "let length = fix (\len.\xs.
|    if (isEmpty xs) 
|      zero 
|      (succ (len (tail xs))))
|  in (length nil);"
let length = (fix (\len.(\xs.(((if (isEmpty xs)) zero) 
(succ (len (tail xs))))))) in (length nil): Int

> java testInfer 
| "let id = \x.x 
|  in if (id true) (id nil) zero;"
let id = (\x.x) in (((if (id true)) (id nil)) zero): 
 cannot type: zero
 reason: cannot unify Int with List[a14]
\end{lstlisting}

\begin{exercise}\label{exercise:hm-parse} Usando a biblioteca de parser cria no
Exercise~\ref{exercise:end-marker}, modifique a biblioteca de parser MiniML de tal forma
que o marcador ``;'' não seja necessária para indicar o fim de uma entrada.
\end{exercise}
}

\begin{exercise}\label{execcise:hm-extend} Extenda o \comment{parser} Mini-ML e o sistema de inferência de tipos
com uma construção \code{letrec} que permita a definição recursiva de funções. 
Sintaxe:
\begin{lstlisting}
letrec ident "=" term in term .
\end{lstlisting}
Os tipos de \code{letrec} devem ser como os de \code{let}, 
exceto que os identificadores definidos são visíveis na expressão que está sendo definida. Usando \code{letrec}, a função \code{length} 
para listas seria definida da seguinte maneira.
\begin{lstlisting}
letrec length = \xs.
  if (isEmpty xs)
    zero
    (succ (length (tail xs)))
in ...
\end{lstlisting}
\end{exercise}

\chapter{Abstracões para Concorrência}\label{sec:ex-concurrency}

Esta seção revisa padrôes comuns de concorrência e mostra como eles
podem ser implementados em Scala.

\section{Sinais e Monitores}

\example
Um {\em monitor} provê mecanismos básicos para processos mutuamente exclusivos
em Scala. Toda instância de \code{AnyRef} pode ser usada como um monitor através
da chamada de um ou mais dos métodos apresentados a seguir.
\begin{lstlisting}
  def synchronized[A] (e: => A): A
  def wait()
  def wait(msec: Long)
  def notify()
  def notifyAll()
\end{lstlisting}
O método \code{synchronized} computa \code{e} em modo mutuamente exclusivo --
em um dado momento qualquer, somente uma thread pode executar um argumento
\code{synchronized} em um dado monitor.

Threads podem ser paradas dentro de um monitor e esperar por um sinal.  
Threads podem chamar o método \code{wait} e esperar até que o método \code{notify} do mesmo
objeto seja chamado por alguma outra thread. Chamadas ao método
\code{notify} quando não existam threads esperando por um sinal são ignoradas.

Existe também uma forma do método \code{wait} baseada em tempo em que a
execução é bloqueada enquanto nenhum sinal seja recebido ou um dado espaço de tempo (dado em
milisegundos) tenha passado. Além disso, há o método \code{notifyAll} que desbloqueia todas
as threads que estejam esperando por um sinal. Estes métodos, assim como a classe \code{Monitor} 
são primitivos em Scala, ou seja, eles são implementados usando os mecanismos internos do sistema de execução
dos programas.

Tipicamente, uma thread espera até que um certa condição ocorra. 
Se esta condição não ocorrer até o tempo definido na chamada do método \code{wait}, 
a thread fica com execução suspensa até que alguma outra thread estabeleça tal condição
ou que o tempo definido tenha passado. É responsabilidade desta outra thread reiniciar
os processos que estavam esperando através da chamada dos métodos \code{notify} ou \code{notifyAll}. 
Note que não existe garantia de que um processo em espera execute imediatamente após a chamada do método
\code{notify}. Pode ocorrer de outros processos que executem antes invalidem novamente esta condição,
deixando as threads suspensas.  Portanto, a forma correta de esperar uma condição $C$ usa um laço do tipo while:
\begin{lstlisting}
while (!$C$) wait()
\end{lstlisting}

Como um exemplo de como os monitores são usados, aqui está uma implementação de uma classe de buffer com limites.
\begin{lstlisting}
class BoundedBuffer[A](N: Int) {
  var in = 0, out = 0, n = 0
  val elems = new Array[A](N)

  def put(x: A) = synchronized {
    while (n >= N) wait()
    elems(in) = x ; in = (in + 1) % N ; n = n + 1
    if (n == 1) notifyAll()
  }

  def get: A = synchronized {
    while (n == 0) wait()
    val x = elems(out) ; out = (out + 1) % N ; n = n - 1
    if (n == N - 1) notifyAll()
    x
  }
}
\end{lstlisting}
E aqui está um programa usando esta classe para comunicar entre processos
consumidores e produtores.
\begin{lstlisting}
import scala.concurrent.ops._
...
val buf = new BoundedBuffer[String](10)
spawn { while (true) { val s = produceString ; buf.put(s) } }
spawn { while (true) { val s = buf.get ; consumeString(s) } }
}
\end{lstlisting}
O método \code{spawn} dispara uma nova thread que executa a expressão passada como
parâmetro. Foi definida no objeto \code{concurrent.ops} da seguinte maneira:
\begin{lstlisting}
def spawn(p: => Unit) {
  val t = new Thread() { override def run() = p }
  t.start()
}
\end{lstlisting}

\comment{
\section{Logic Variable}

A logic variable (or lvar for short) offers operations \code{:=}
and \code{value} to define the variable and to retrieve its value.
Variables can be \code{define}d only once. A call to \code{value}
blocks until the variable has been defined.

Logic variables can be implemented as follows.

\begin{lstlisting}
class LVar[A] {
  private val defined = new Signal
  private var isDefined: Boolean = false
  private var v: A
  def value = synchronized {
    if (!isDefined) defined.wait
    v
  }
  def :=(x: A) = synchronized {
    v = x; isDefined = true; defined.send
  }
}
\end{lstlisting}
}

\section{SyncVars}

Uma variável sincronizada (ou syncvar) oferece as operações \code{get} e 
\code{put} para ler e escrever na variável. As operações \code{get} bloqueiam
a execução até que o valor da variável tenha sido definido. Um operação \code{unset}
coloca o valor da variável em um valor indefinido.

Aqui segue uma implementação padrão de variáveis sincronizadas:
\begin{lstlisting}
package scala.concurrent
class SyncVar[A] {
  private var isDefined: Boolean = false
  private var value: A = _
  def get = synchronized {
    while (!isDefined) wait()
    value
  }
  def set(x: A) = synchronized {
    value = x; isDefined = true; notifyAll()
  }
  def isSet: Boolean = synchronized {
    isDefined
  }
  def unset = synchronized {
    isDefined = false
  }
}
\end{lstlisting}

\section{Futuros}
\label{sec:futures}

Um futuro ({\em future}) é um valor que será computado em paralelo com alguma outra thread do cliente e
que será usado pelo cliente em algum momento no futuro. 
Futuros são usados para utilizar melhor os recursos de processamento paralelo.
O uso típico é:

\begin{lstlisting}
import scala.concurrent.ops._
...
val x = future(someLengthyComputation)
anotherLengthyComputation
val y = f(x()) + g(x())
\end{lstlisting}

O método \code{future} é definido no objeto
\code{scala.concurrent.ops} da seguinte maneira.
\begin{lstlisting}
def future[A](p: => A): Unit => A = {
  val result = new SyncVar[A]
  fork { result.set(p) }
  (() => result.get)
}
\end{lstlisting}

O método \code{future} recebe como parâmetro uma computação \code{p} que precisa ser 
calculado. O tipo da computação é arbitrário e é representando pelo tipo genérico \code{A}. 
O método \code{future} define um guarda \code{result}, que recebe o parâmetro que representa
o resultado da computação.  
Ao chegar neste ponto, ele abre uma nova thread que computa o resultado e invoca o guarda \code{result} 
quanto o processo terminar. Em paralelo à esta thread, a função retorna uma função anônima do
tipo \code{A}. Quando chamada, esta função espera que o guarda resultado tenha sido chamada, e, quando isso
ocoore, retorna o resultado.
Ao mesmo tempo, a função re-invoca o guarda \code{result} com o mesmo argumento, de forma que, futuras chamadas
à função possam retornar o resultado imediatamente.

\section{Computação Paralela}

O próximo exemplo apresenta a função \code{par} que recebe um par de computaçoes como prarâmetros
e retorna o resultado destas computações em um outro par. As duas computações são executadas
paralelamente.

A função estã definida no objeto
\code{scala.concurrent.ops} da seguinte forma:
\begin{lstlisting}
  def par[A, B](xp: => A, yp: => B): (A, B) = {
    val y = new SyncVar[B]
    spawn { y set yp }
    (xp, y.get)
  }
\end{lstlisting}
Definida no mesmo objeto está a função \code{replicate} que executa um número de réplicas
de uma computação em paralelo. Cada instância replicada é passada como um número inteiro
que a identifica.
\begin{lstlisting}
  def replicate(start: Int, end: Int)(p: Int => Unit) {
    if (start == end)
      ()
    else if (start + 1 == end)
      p(start)
    else {
      val mid = (start + end) / 2
      spawn { replicate(start, mid)(p) }
      replicate(mid, end)(p)
    }
  }
\end{lstlisting}

A função a seguir usa \code{replicate} para realizar uma computação paralela
em todos os elementos de um vetor.

\begin{lstlisting}
def parMap[A,B](f: A => B, xs: Array[A]): Array[B] = {
  val results = new Array[B](xs.length)
  replicate(0, xs.length) { i => results(i) = f(xs(i)) }
  results
}
\end{lstlisting}

\section{Semáforos}

Um mecanismo comum para sincronização de processos é o uso de travas ({\em lock}) ou
{\em semáforo}. Uma trava oferece duas operações atômicas: \prog{acquire} e \prog{release}. Aqui está a implementação de uma trava en Scala:

\begin{lstlisting}
package scala.concurrent

class Lock {
  var available = true
  def acquire = synchronized {
    while (!available) wait()
    available = false
  }
  def release = synchronized {
    available = true
    notify()
  }
}
\end{lstlisting}

\section{Leitores/Escritores}

Uma forma mais complexa de sincronização distingue leitores ({\em
readers}) que acessam um recurso comum sem modificá-lo e escritores ({\em
writers}) que podem acessar e modificar esse recurso. Para sincronizar leitores e escritores, precisamos implementar as operações \prog{startRead}, \prog{startWrite},
\prog{endRead}, \prog{endWrite}, de tal forma que:
\begin{itemize}
\item podem haver múltiplos leitores concorrentemente;
\item só pode haver um único escritor em um dado instante;
\item solicitações de escrita pendentes tem prioridade sobre solicitações de leitura pendentes, mas não interrompem operações de
leitura que estejam ocorrendo.
\end{itemize}
A implementação de travas para leitores/escritores a seguir é baseada no conceito de caixa postal ({\em mailbox}) (ver Seção~\ref{sec:mailbox}).

\begin{lstlisting}
import scala.concurrent._

class ReadersWriters {
  val m = new MailBox
  private case class Writers(n: Int), Readers(n: Int) { m send this }
  Writers(0); Readers(0)
  def startRead = m receive {
    case Writers(n) if n == 0 => m receive {
      case Readers(n) => Writers(0); Readers(n+1)
    }
  }
  def startWrite = m receive {
    case Writers(n) =>
      Writers(n+1)
      m receive { case Readers(n) if n == 0 => }
  }
  def endRead = m receive {
    case Readers(n) => Readers(n-1)
  }
  def endWrite = m receive {
    case Writers(n) => Writers(n-1); if (n == 0) Readers(0)
  }
}
\end{lstlisting}

\section{Canais Assíncronos}

Um modo fundamental de comunicação entre processos é o canal assíncrono.
Sua implementação faz usa da seguinte classe para listas-ligadas:
\begin{lstlisting}
class LinkedList[A] {
  var elem: A = _
  var next: LinkedList[A] = null
}
\end{lstlisting}
Para facilitar a inserção e remoção de elementos nas listas ligadas,
cada referência na lista ligada aponta para o nó que precede o nó que conceitualmente forma o topo da lista.
Listas ligadas vazias começam com um nó fantasma, cujo o sucessor é 
\code{null}.

A classe canal usa a lista ligada para armazenar dados que foram enviados, mas ainda não foram lidos. No lado oposto, threads que 
necessitam ler de um canal vazio, registram sua presença incrementando
o campo  \code{nreaders} e esperando serem notificadas.
\begin{lstlisting}
package scala.concurrent

class Channel[A] {
  class LinkedList[A] {
    var elem: A = _
    var next: LinkedList[A] = null
  }
  private var written = new LinkedList[A]
  private var lastWritten = written
  private var nreaders = 0

  def write(x: A) = synchronized {
    lastWritten.elem = x
    lastWritten.next = new LinkedList[A]
    lastWritten = lastWritten.next
    if (nreaders > 0) notify()
  }

  def read: A = synchronized {
    if (written.next == null) {
      nreaders = nreaders + 1; wait(); nreaders = nreaders - 1
    }
    val x = written.elem
    written = written.next
    x
  }
}
\end{lstlisting}

\section{Canais Síncronos}

Aqui está uma implementação de canais síncronos, onde quem envia uma mensagem tem sua execução bloqueada até que esta mensagem seja recebida.
Canais síncronos precisam apenas de uma única variável para armazenar as mensagens em trânsito, mas de três sinais para coordenar os processos de leitura e escrita.
\begin{lstlisting}
package scala.concurrent

class SyncChannel[A] {
  private var data: A = _
  private var reading = false
  private var writing = false

  def write(x: A) = synchronized {
    while (writing) wait()
    data = x
    writing = true
    if (reading) notifyAll()
    else while (!reading) wait()
  }

  def read: A = synchronized {
    while (reading) wait()
    reading = true
    while (!writing) wait()
    val x = data
    writing = false
    reading = false
    notifyAll()
    x
  }
}
\end{lstlisting}

\section{Trabalhadores}

Aqui está uma implementação de um {\em servidor de computação} em Scala. O servidor implementa um método \code{future} que computa uma dada expressão paralelamente com quem chamou o método. Diferenmente da implementação de futuros da seção ~\ref{sec:futures} o servidor computa os futuros somente com um número pré-definido de threads. Uma possível implementação do servidor poderia executar cada thread em um processador separado, e com isso evitar o custo inerente à mudança de contexto entre muitas threads em um único processo.

\begin{lstlisting}
import scala.concurrent._, scala.concurrent.ops._

class ComputeServer(n: Int) {

  private abstract class Job {
    type T
    def task: T
    def ret(x: T)
  }

  private val openJobs = new Channel[Job]()

  private def processor(i: Int) {
    while (true) {
      val job = openJobs.read
      job.ret(job.task)
    }
  }

  def future[A](p: => A): () => A = {
    val reply = new SyncVar[A]()
    openJobs.write{
      new Job {
        type T = A
        def task = p
        def ret(x: A) = reply.set(x)
      }
    }
    () => reply.get
  }

  spawn(replicate(0, n) { processor })
}
\end{lstlisting}
Expressões a serem computadas (ex.: parâmetros da chamada de um \code{future}) são escritos no canal  \code{openJobs}
. Um {\em job} é um objeto em que:
\begin{itemize}
\item
Um tipo abstrato \code{T} descreve o resultado de sua computação.
\item
Um método sem parâmetros (\code{task}) do tipo \code{t} representa a expressão a ser computada.
\item
Um método \code{ret} consome o resultado, quando este tiver sido computado.
\end{itemize}
O servidor de computação cria $n$ processos no \code{processador} como parte de sua inicialização.  Cada um destes processos repetidamente consome um trabalho em aberto no canal \code{openJobs}, computa o método\code{task} e passa o resultado para o método \code{ret}. 
O método polimórfico \code{future} cria um novo job quando o método \code{ret} é implementado por um guarda chamado \code{reply} e insere este job no conjunto de trabalhos em aberto. Este espera até que o método guarda 
\code{reply} correspondente for chamado.

O exemplo mostra o uso de tipos abstratos. Um tipo abstrato
\code{t} mantém controle do tipo do resultado de um job que pode variar
entre diferentes jobs. Sem os tipos abstratos seria impossível implementar
a mesma classe para o usuário de uma forma que garantisse a segurança do sistemas de tipos estaticamente. Seriam necessários testes de tipos dinâmicos e o uso de casts.


Aqui um trecho de código que usa o servidor de computação para calcular
a expressão \code{41 + 1}.
\begin{lstlisting}
object Test with Executable {
  val server = new ComputeServer(1)
  val f = server.future(41 + 1)
  println(f())
}
\end{lstlisting}

\section{Caixas Postais}
\label{sec:mailbox}

Caixas postais são construções flexíveis de alto nível para comunicação e sincronização de processos. Elas permitem enviar e receber mensagens. 
Um {\em mensagem} neste contexto é um objeto arbitrário.
Há uma mensagem especial, chamada \code{TIMEOUT} que é usada para sinalizar um time-out.
\begin{lstlisting}
case object TIMEOUT
\end{lstlisting}
Caixas postais implentam os seguintes métodos
\begin{lstlisting}
class MailBox {
  def send(msg: Any)
  def receive[A](f: PartialFunction[Any, A]): A
  def receiveWithin[A](msec: Long)(f: PartialFunction[Any, A]): A
}
\end{lstlisting}
O estado de uma caixa postal consiste de vários conjuntos de mensagens.
As mensagens são adicionadas à caix postal através do método \code{send}.
As mensagens são removidas usando o método \code{receive}, que passa um processador de mensagens \code{f} como parâmetro. O processador de mensagens é uma função parcial que tenha como resultado um tipo arbitrário. Normalmente, esta função é implementada usando uma expressão de casamento de padrôes. O método \code{receive} suspende sua execução até que exista uma mensagem na caixa postal para o qual o seu processador de mensagens foi definido. A mensagem que casa com um processador é então removida da caixa postal e a thread suspensa é reiniciada aplicando o processador de mensagens à mensagem. Tanto mensagens enviadas e receptores são ordenados cronologicamente.  Um receptor $r$ é aplicado à uma mensagem $m$ se for capaz de recebê-la (tipo) e somente se não existe um outro par $\{$message, receiver$\}$ que preceda ${m,
r}$ no ordenamento cronológico parcial destes pares.

Como um simples exemplo de como caixas postais são usadas, considere o buffer de uma posição:
\begin{lstlisting}
class OnePlaceBuffer {
  private val m = new MailBox             // Caixa postal interna
  private case class Empty, Full(x: Int)  // Tipo das mensagens que pode tratar
  m send Empty                            // Inicializa\c{c}\~{a}o
  def write(x: Int)
    { m receive { case Empty => m send Full(x) } }
  def read: Int =
    m receive { case Full(x) => m send Empty; x }
}
\end{lstlisting}
Aqui como uma classe caixa postal pode ser implementada:
\begin{lstlisting}
class MailBox {
  private abstract class Receiver extends Signal {
    def isDefined(msg: Any): Boolean
    var msg = null
  }
\end{lstlisting}
Definimos um classe interna para receptores com um método de teste
\code{isDefined}, que indica se o receptor pode tratar uma dada mensagem. 
O receptor herda da classe \code{Signal} o método \code{notify} que serve 
para "acordar" a thread para receptora. Quanto a thread receptora é reiniciada, 
a mensagem que precisa ser aplicada é armazenada na variável \code{msg} 
do \code{Receiver}.
\begin{lstlisting}
  private val sent = new LinkedList[Any]
  private var lastSent = sent
  private val receivers = new LinkedList[Receiver]
  private var lastReceiver = receivers
\end{lstlisting}
Um classe caixa postal mantém duas lista ligadas,
uma para mensagens enviadas e não consumidas e outra
para mensagens esperando receptores.
\begin{lstlisting}
  def send(msg: Any) = synchronized {
    var r = receivers, r1 = r.next
    while (r1 != null && !r1.elem.isDefined(msg)) {
      r = r1; r1 = r1.next
    }
    if (r1 != null) {
      r.next = r1.next; r1.elem.msg = msg; r1.elem.notify
    } else {
      lastSent = insert(lastSent, msg)
    }
  }
\end{lstlisting}
Inicialmente, o método \code{send} verifica se há um receptor que
pode ser aplicado à mensagem enviada. Se sim, o receptor é notificado.
Se não, a mensagem é anexada à lista ligada de mensagens enviadas.
\begin{lstlisting}
  def receive[A](f: PartialFunction[Any, A]): A = {
    val msg: Any = synchronized {
      var s = sent, s1 = s.next
      while (s1 != null && !f.isDefinedAt(s1.elem)) {
        s = s1; s1 = s1.next
      }
      if (s1 != null) {
        s.next = s1.next; s1.elem
      } else {
        val r = insert(lastReceiver, new Receiver {
          def isDefined(msg: Any) = f.isDefinedAt(msg)
        })
        lastReceiver = r
        r.elem.wait()
        r.elem.msg
      }
    }
    f(msg)
  }
\end{lstlisting}
Inicialmente, o método \code{receive} verifica se existe uma função 
processadora de mensagens \code{f} que pode ser aplicada à mensagem que 
já foi enviada, mas ainda não foi consumida. Se sim, a thread continua
imediatamente aplicando a função \code{f} à mensagem. Se não, um novo 
receptor é criado adicionado à lista \code{receivers} e a thread esperará
por uma notificação neste receptor. Uma vez que a thread seja reiniciada,
ela continua aplicando a função \code{f} que foi armazenado no receptor à mensagem.
O método insert na lista ligada é definido da seguinte maneira:
\begin{lstlisting}
  def insert(l: LinkedList[A], x: A): LinkedList[A] = {
    l.next = new LinkedList[A]
    l.next.elem = x
    l.next.next = l.next
    l
  }
\end{lstlisting}
A classe caixa postal também oferece o método \code{receiveWithin}
que suspende a execução por um tempo máximo especificado. Se nenhuma
mensagem for recebida no intervalo de tempo especificado (dado em 
milissegundos), o parâmetro do processador de mensagens $f$ será desbloqueado
com a mensagem especial \code{TIMEOUT}. A implementação de
\code{receiveWithin} é bastante parecida com a de \code{receive}:
%% A parte a ser traduzida termina aqui!!!
\begin{lstlisting}
  def receiveWithin[A](msec: Long)(f: PartialFunction[Any, A]): A = {
    val msg: Any = synchronized {
      var s = sent, s1 = s.next
      while (s1 != null && !f.isDefinedAt(s1.elem)) {
        s = s1; s1 = s1.next 
      }
      if (s1 != null) {
        s.next = s1.next; s1.elem
      } else {
        val r = insert(lastReceiver, new Receiver {
            def isDefined(msg: Any) = f.isDefinedAt(msg)
        })
        lastReceiver = r
        r.elem.wait(msec)
        if (r.elem.msg == null) r.elem.msg = TIMEOUT
        r.elem.msg
      }
    }
    f(msg)
  }
} // fim MailBox
\end{lstlisting}
A única diferença é a chamada ao método \code{wait} que recebe o tempo de espera 
e a linha de código que vem em seguida, onde a mensagem \code{TIMEOUT} é aplicada.

\section{Actors}
\label{sec:actors}

O capítulo~\ref{chap:example-auction} apresentou um programa como exemplo de implementação
de um serviço de leilão eletrônico. Este serviço foi baseado em atores quue representam processos 
de alto nível e trabalham inspecionando as mensagens em sua caixa-postal usando casamento de padrões.
Uma implementação mais refinada e otimizada de atores pode ser encontrada no pacote \lstinline@scala.actors@.
Agora mostraremos um rascunho de uma versão simplificada da biblioteca de atores.

O código apresentado a seguir é diferente da implementação presente no pacote \lstinline@scala.actors@ e, 
portanto, deve ser vista como um exemplo de como uma versão simplificada dos atores poderia ser implementada.
Ela não descreve como os atores foram definidos e implementados na biblioteca padrão de Scala. Caso deseje
essa informação, por favor consulte a documentação da API de Scala.

Um ator simplificado é apenas uma thread cujas primitivas de comunicação são aquelas de uma caixa postal.
Tal ator pode ser definido como uma composição mixin da extensão da classe Java padrão 
\code{Thread} com a classe \code{MailBox}. Nós também sobre-escrevemos o método \code{run} da classe \code{Thread}, de 
tal forma que ele execute o comportamento de um ator que é definido pelo método \code{act}.
O método \code{!} simplesmente chama o método \code{send} da classe 
\code{MailBox}:
\begin{lstlisting}
abstract class Actor extends Thread with MailBox {
  def act(): Unit
  override def run(): Unit = act()
  def !(msg: Any) = send(msg)
}
\end{lstlisting}



\comment{
As an extended example of an application that uses actors, we come
back to the auction server example of Section~\ref{sec:ex-auction}.
The following code implements:

\begin{figure}[thb]
\begin{lstlisting}
class AuctionMessage
case class
  Offer(bid: Int, client: Process),                  // make a bid
  Inquire(client: Process) extends AuctionMessage    // inquire status

class AuctionReply
case class
  Status(asked: Int, expiration: Date),           // asked sum, expiration date
  BestOffer,                                         // yours is the best offer
  BeatenOffer(maxBid: Int),                          // offer beaten by maxBid
  AuctionConcluded(seller: Process, client: Process),// auction concluded
  AuctionFailed                                      // failed with no bids
  AuctionOver extends AuctionReply                   // bidding is closed
\end{lstlisting}
\end{figure}

\begin{lstlisting}
class Auction(seller: Process, minBid: Int, closing: Date)
 extends Process {

  val timeToShutdown = 36000000 // msec
  val delta = 10                // bid increment
\end{lstlisting}
\begin{lstlisting}
  override def run = {
    var askedBid = minBid
    var maxBidder: Process = null
    while (true) {
      receiveWithin ((closing - Date.currentDate).msec) {
        case Offer(bid, client) => {
          if (bid >= askedBid) {
            if (maxBidder != null && maxBidder != client) {
              maxBidder send BeatenOffer(bid)
            }
            maxBidder = client
            askedBid = bid + delta
            client send BestOffer
          } else client send BeatenOffer(maxBid)
        }
\end{lstlisting}
\begin{lstlisting}
        case Inquire(client) => {
          client send Status(askedBid, closing)
        }
\end{lstlisting}
\begin{lstlisting}
        case TIMEOUT => {
          if (maxBidder != null) {
            val reply = AuctionConcluded(seller, maxBidder)
            maxBidder send reply
            seller send reply
          } else seller send AuctionFailed
          receiveWithin (timeToShutdown) {
            case Offer(_, client) => client send AuctionOver; discardAndContinue
            case _ => discardAndContinue
            case TIMEOUT => stop
          }
        }
\end{lstlisting}
\begin{lstlisting}
        case _ => discardAndContinue
      }
    }
  }
\end{lstlisting}
\begin{lstlisting}
  def houseKeeping: Int = {
    val Limit = 100
    var nWaiting: Int = 0
    receiveWithin(0) {
      case _ =>
        nWaiting = nWaiting + 1
        if (nWaiting > Limit) {
          receiveWithin(0) {
            case Offer(_, _) => continue
            case TIMEOUT =>
            case _ => discardAndContinue
          }
        } else continue
      case TIMEOUT =>
    }
  }
}
\end{lstlisting}
\begin{lstlisting}
class Bidder (auction: Process, minBid: Int, maxBid: Int)
 extends Process {
  val MaxTries = 3
  val Unknown = -1

  var nextBid = Unknown
\end{lstlisting}
\begin{lstlisting}
  def getAuctionStatus = {
    var nTries = 0
    while (nextBid == Unknown && nTries < MaxTries) {
      auction send Inquiry(this)
      nTries = nTries + 1
      receiveWithin(waitTime) {
        case Status(bid, _) => bid match {
          case None => nextBid = minBid
          case Some(curBid) => nextBid = curBid + Delta
        }
        case TIMEOUT =>
        case _ => continue
      }
    }
    status
  }
\end{lstlisting}
\begin{lstlisting}
  def bid {
    if (nextBid < maxBid) {
      auction send Offer(nextBid, this)
      receive {
        case BestOffer =>
          receive {
            case BeatenOffer(bestBid) =>
              nextBid = bestBid + Delta
              bid
            case AuctionConcluded(seller, client) =>
                   transferPayment(seller, nextBid)
            case _ => continue
          }

        case BeatenOffer(bestBid) =>
          nextBid = nextBid + Delta
          bid

        case AuctionOver =>

        case _ => continue
      }
    }
  }
\end{lstlisting}
\begin{lstlisting}
  override def run = {
    getAuctionStatus
    if (nextBid != Unknown) bid
  }

  def transferPayment(seller: Process, amount: Int)
}
\end{lstlisting}
}
