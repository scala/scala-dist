\def\exercise{
   \def\theresult{Exercício~\thesection.\arabic{result}}
   \refstepcounter{result}
   \trivlist\item[\hskip
   \labelsep{\bf \theresult}]}
\def\endexercise{\endtrivlist}
 
\newcommand{\rewriteby}[1]{\mbox{\tab\tab\rm(#1)}}

\chapter{\label{chap:example-one}Um primeiro exemplo}

Para come\c{c}ar, apresentamos um primeiro exemplo, a implementa\c{c}\~{a}o de Quicksort em Scala.

\begin{lstlisting}
def sort(xs: Array[Int]) {
  def swap(i: Int, j: Int) {
    val t = xs(i); xs(i) = xs(j); xs(j) = t
  }
  def sort1(l: Int, r: Int) {
    val pivot = xs((l + r) / 2)
    var i = l; var j = r
    while (i <= j) {
      while (xs(i) < pivot) i += 1
      while (xs(j) > pivot) j -= 1
      if (i <= j) { 
        swap(i, j)
        i += 1
        j -= 1
      }
    } 
    if (l < j) sort1(l, j)
    if (j < r) sort1(i, r)
  }
  sort1(0, xs.length - 1)
}
\end{lstlisting}

A implementa\c{c}\~{a}o se parece muito com a que voc\^{e} faria em Java
ou C. N\'{o}s usamos os mesmos operadores e estruturas de controle.
Existem tamb\'{e}m algumas pequenas diferen\c{c}as sint\'{a}ticas, particularmente:
\begin{itemize}
\item
As declara\c{c}\~{o}es come\c{c}am usando palavras reservadas. Particularmente, declara\c{c}\~{o}es de fun\c{c}\~{o}es s\~{a}o iniciadas
com a palavra \code{def}, declara\c{c}\~{o}es de vari\'{a}veis s\~{a}o iniciadas com a palavra \code{var} e
declara\c{c}\~{a}o de constantes (chamadas de valores) s\~{a}o iniciadas com a palavra \code{val}.
\item
O tipo de um par\^{a}metro em uma fun\c{c}\~{a}o \'{e} declarado ap\'{o}s o nome do par\^{a}metro seguido de dois pontos(:).
O tipo pode ser omitido quando o compilador for capaz de inferi-lo pelo contexto.
\item
A  declara\c{c}\~{a}o de vetores do tipo \code{T} \'{e} feita usando a express\~{a}o \code{Array[T]} ao inv\'{e}s de \code{T[]}. 
O i-\'{e}simo elemento de um vetor \code{a} \'{e} acessado usando \code{a(i)} ao inv\'{e}s de \code{a[i]}.
\item
Fun\c{c}\~{o}es podem ser aninhadas umas dentro das outras. Fun\c{c}\~{o}es aninhadas podem
acessar par\^{a}metros e vari\'{a}veis locais de suas fun\c{c}\~{o}es externas. Por
exemplo, o nome do vetor \code{xs} \'{e} vis\'{i}vel nas fun\c{c}\~{o}es \code{swap} e 
\code{sort1}, e portanto n\~{a}o precisam ser passadas como um par\^{a}metro para elas.
%----------
\end{itemize}

Pelo que vimos, Scala se parece com uma linguagem bem convencional 
com algumas peculiaridades sint\'{a}ticas. De fato \'{e} poss\'{i}vel escrever
programas em estilo imperativo ou orientado a objetos. Isto \'{e} 
importante, porque \'{e} uma das coisas que facilitam combinar componentes
Scala com componentes escritos em linguagens convencionais, tais como Java,
C\# ou Visual Basic.
Entretanto, tamb\'{e}m \'{e} poss\'{i}vel escrever programas num estilo completamente
diferente. Aqui est\'{a} o Quicksort novamente, desta vez escrito em 
estilo funcional.
%----------
\begin{lstlisting}
def sort(xs: Array[Int]): Array[Int] = {
  if (xs.length <= 1) xs
  else {
    val pivot = xs(xs.length / 2)
    Array.concat(
      sort(xs filter (pivot >)),
           xs filter (pivot ==),
      sort(xs filter (pivot <)))
  }
}
\end{lstlisting}
%----------                
%% The functional program captures the essence of the quicksort algorithm
%% in a concise way:
%% \begin{itemize}
%% \item If the array is empty or consists of a single element, 
%%       it is already sorted, so return it immediately.
%% \item If the array is not empty, pick an an element in the middle of
%%       it as a pivot.
%% \item Partition the array into two sub-arrays containing elements that
%% are less than, respectively greater than the pivot element, and a
%% third array which contains elements equal to pivot.
%% \item Sort the first two sub-arrays by a recursive invocation of
%% the sort function.\footnote{This is not quite what the imperative algorithm does;
%% the latter partitions the array into two sub-arrays containing elements
%% less than or greater or equal to pivot.}
%% \item The result is obtained by appending the three sub-arrays together.
%% \end{itemize}
O programa funcional captura a ess\^{e}ncia do algoritmo quicksort de modo conciso:
\begin{itemize}
\item Se o vetor est\'{a} vazio ou consiste de um \'{u}nico elemento, j\'{a} est\'{a} ordenado,
      ent\~{a}o retorne imediatamente.
\item Se o vetor n\~{a}o est\'{a} vazio, escolha um elemento do meio do vetor como piv\^{o}.
\item Particione o vetor em dois subvetores contendo, respectivamente os elementos
 que s\~{a}o menores que o elemento piv\^{o}, maiores que, e um terceiro vetor que cont\'{e}m
 elementos iguais ao piv\^{o}.
\item Ordene os dois primeiros subvetores por uma chamada recursiva da fun\c{c}\~{a}o de 
ordena\c{c}\~{a}o.\footnote{Isso n\~{a}o \'{e} exatamente o que o algoritmo imperativo faz; este 
\'{u}ltimo particiona o vetor em dois subvetores contendo elementos menores que ou 
maiores ou iguais ao piv\^{o}.}
\item O resultado \'{e} obtido pela concatena\c{c}\~{a}o dos tr\^{e}s subvetores.
\end{itemize}
%----------

%----------
%% Both the imperative and the functional implementation have the same
%% asymptotic complexity -- $O(N;log(N))$ in the average case and
%% $O(N^2)$ in the worst case. But where the imperative implementation
%% operates in place by modifying the argument array, the functional
%% implementation returns a new sorted array and leaves the argument
%% array unchanged. The functional implementation thus requires more
%% transient memory than the imperative one.
Tanto a implementa\c{c}\~{a}o imperativa quanto a funcional tem mesma complexidade
assint\'{o}tica -- $O(N;log(N))$ no caso m\'{e}dio e $O(N^2)$ no pior caso. Mas onde
a implementa\c{c}\~{a}o imperativa opera localmente, modificando o vetor original,
a implementa\c{c}\~{a}o funcional retorna um novo vetor ordenado e deixa o vetor
original inalterado. A implementa\c{c}\~{a}o funcional, portanto, requer mais
mem\'{o}ria transiente que a imperativa.
%----------

%----------
%% The functional implementation makes it look like Scala is a language
%% that's specialized for functional operations on arrays. In fact, it is
%% not; all of the operations used in the example are simple library
%% methods of a {\em sequence} class \code{Seq[T]} which is part of the
%% standard Scala library, and which itself is implemented in
%% Scala. Because arrays are instances of \verb@Seq@ all sequence
%% methods are available for them.
A implementa\c{c}\~{a}o funcional faz parecer que Scala \'{e} uma linguagem
especializada para opera\c{c}\~{o}es funcionais sobre vetores. De fato, n\~{a}o \'{e};
todas as opera\c{c}\~{o}es usadas no exemplo s\~{a}o simples m\'{e}todos de biblioteca
de uma classe {\em sequ\^{e}ncia} \code{Seq[T]} que \'{e} parte da biblioteca
padr\~{a}o Scala, e onde ela mesma \'{e} implementada em Scala. Como vetores s\~{a}o 
inst\^{a}ncias de \verb@Seq@, todos os m\'{e}todos de sequ\^{e}ncia est\~{a}o dispon\'{i}veis
para eles.
%----------

%----------
%% In particular, there is the method \code{filter} which takes as
%% argument a {\em predicate function}. This predicate function must map
%% array elements to boolean values. The result of \code{filter} is an
%% array consisting of all the elements of the original array for which the
%% given predicate function is true. The \code{filter} method of an object
%% of type \code{Array[T]} thus has the signature
Em particular, h\'{a} o m\'{e}todo \code{filter} que recebe como argumento uma
{\em fun\c{c}\~{a}o predicado}. Esta fun\c{c}\~{a}o predicado deve mapear elementos do 
vetor para valores boleanos. O resultado de \code{filter} \'{e} um vetor
consistindo de todos os elementos do vetor original para o qual a fun\c{c}\~{a}o
predicado \'{e} verdadeira. O m\'{e}todo \code{filter} de um objeto tipo
\code{Array[T]} portanto tem a assinatura. 
%----------


\begin{lstlisting}
def filter(p: T => Boolean): Array[T]
\end{lstlisting}

%----------
%% Here, \code{T => Boolean} is the type of functions that take an element
%% of type \code{t} and return a \code{Boolean}.  Functions like
%% \code{filter} that take another function as argument or return one as
%% result are called {\em higher-order} functions.
Aqui, \code{T=>Boolean} \'{e} o tipo das fun\c{c}\~{o}es que recebem um elemento 
do tipo \code{T} e retornam um valor booleano do tipo \code{Boolean}. 
Fun\c{c}\~{o}es como \code{filter} 
que recebem uma outra fun\c{c}\~{a}o como argumento ou retornam uma fun\c{c}\~{a}o como
resultado s\~{a}o chamadas {\em fun\c{c}\~{o}es de alta ordem.}     
%----------

%----------
%% Scala does not distinguish between identifiers and operator names. An
%% identifier can be either a sequence of letters and digits which begins
%% with a letter, or it can be a sequence of special characters, such as
%% ``\code{+}'', ``\code{*}'', or ``\code{:}''.  Any identifier can
%% be used as an infix operator in Scala.  The binary operation $E;op;E'$
%% is always interpreted as the method call $E.op(E')$. This holds also
%% for binary infix operators which start with a letter. Hence, the
%% expression ~\lstinline@xs filter (pivot >)@~ is equivalent to the
%% method call ~\lstinline@xs.filter(pivot >)@.
Scala n\~{a}o faz distin\c{c}\~{a}o entre nomes de identificadores e nomes de operadores.
um identificador pode ser ou uma sequ\^{e}ncia de letras ou digitos que come\c{c}am
com uma letra, ou podem ser uma sequ\^{e}ncia de caracteres especiais, tais como 
``\code{+}'', ``\code{*}'', ou ``\code{:}''.  Qualquer identificador pode
ser usado como operador infixo em Scala. A opera\c{c}\~{a}o bin\'{a}ria $E;op;E'$ \'{e} sempre
interpretado como a chamada de m\'{e}todo $E.op(E')$. Isso vale tamb\'{e}m para 
operadores bin\'{a}rios infixos que iniciam com uma letra. Consequentemente,
a express\~{a}o  ~\lstinline@xs filter (pivot >)@~ \'{e} equivalente à chamada de
m\'{e}todo ~\lstinline@xs.filter(pivot >)@.
%----------



%----------
%% In the quicksort program, \code{filter} is applied three times to an
%% anonymous function argument.  The first argument, \code{pivot >},
%% represents a function that takes an argument $x$ and returns the value
%% ~\lstinline@pivot > $x$@. This is an example of a {\em partially applied
%% function}.  Another, equivalent way to write this function which makes
%% the missing argument explicit is ~\lstinline@x => pivot > x@.
%% The function is anonymous, i.e.\ it is not defined with a name. The
%% type of the \code{x} parameter is omitted because a Scala compiler can
%% infer it automatically from the context where the function is used. To
%% summarize, \code{xs.filter(pivot >)} returns a list consisting
%% of all elements of the list \code{xs} that are smaller than
%% \code{pivot}.
No programa quicksort, \code{filter} \'{e} aplicado tr\^{e}s vezes a um argumento 
de fun\c{c}\~{a}o an\^{o}nima. O primeiro argumento, \code{pivot >}, representa uma 
fun\c{c}\~{a}o que recebe um argumento $x$ e retorna o valor ~\lstinline@pivot > $x$@.
Este \'{e} um exemplo de uma {\em fun\c{c}\~{a}o parcialmente aplicada}. Um outro modo, 
equivalente de se escrever esta fun\c{c}\~{a}o, que torna o argumento oculto explicito
\'{e} ~\lstinline@x => pivot > x@. A fun\c{c}\~{a}o \'{e} an\^{o}nima, ou seja, n\~{a}o \'{e} definida
com um nome. O tipo do par\^{a}metro  \code{x} \'{e} omitido porque um compilador Scala 
pode infer\'{i}-lo autom\'{a}ticamente a partir do contexto onde a fun\c{c}\~{a}o \'{e} usada.
Resumindo, \code{xs.filter(pivot >)} retorna uma lista consistindo de todos os 
elementos da lista \code{xs} que s\~{a}o menores que \code{pivot}.  
%----------

%----------
%% Looking again in detail at the first, imperative implementation of
%% Quicksort, we find that many of the language constructs used in the
%% second solution are also present, albeit in a disguised form.
Olhando novamente em detalhes para a primeira, implementa\c{c}\~{a}o imperativa
do Quicksort, percebemos que muitos dos construtores da linguagem 
usados na segunda solu\c{c}\~{a}o est\~{a}o presentes, embora de modo distinto.
%----------



%----------
%% For instance, ``standard'' binary operators such as \code{+},
%% \code{-}, or \code{<} are not treated in any special way. Like
%% \code{append}, they are methods of their left operand. Consequently,
%% the expression \code{i + 1} is regarded as the invocation
%% \code{i.+(1)} of the \code{+} method of the integer value \code{x}.
%% Of course, a compiler is free (if it is moderately smart, even expected)
%% to recognize the special case of calling the \code{+} method over
%% integer arguments and to generate efficient inline code for it.
Por exemplo, operadores bin\'{a}rios padr\~{a}o, tais como \code{+}, \code{-},
ou \code{<} n\~{a}o s\~{a}o tratados de modo especial. Assim como \code{append}, 
s\~{a}o m\'{e}todos de seus operandos esquerdos. Consequentemente, a express\~{a}o 
\code{i+1} \'{e} vista como a invoca\c{c}\~{a}o de \code{i.+(1)} do m\'{e}todo \code{+}      
do valor inteiro de \code{i}. De fato, um compilador \'{e} livre (se 
moderadamente esperto, ainda que  esperado) para reconhecer o caso 
especial da chamada de m\'{e}todo \code{+} sobre argumentos inteiros e 
para gerar c\'{o}digo inline eficiente para isso.  
%----------

Por efici\^{e}ncia e melhor detec\c{c}\~{a}o de erros o la\c{c}o \code{while} \'{e} um construtor 
primitivo em Scala. Mas em princ\'{i}pio, poderia do mesmo modo ser uma fun\c{c}\~{a}o 
predefinida. Aqui est\'{a} uma poss\'{i}vel implementa\c{c}\~{a}o para ele: 
%----------
\begin{lstlisting}
def While (p: => Boolean) (s: => Unit) {
  if (p) { s ; While(p)(s) }
}
\end{lstlisting}


A fun\c{c}\~{a}o \code{While} recebe como primeiro par\^{a}metro uma fun\c{c}\~{a}o teste,
que n\~{a}o recebe par\^{a}metros e produz um valor boleano. Como segundo par\^{a}metro 
recebe uma fun\c{c}\~{a}o comando que tamb\'{e}m n\~{a}o recebe par\^{a}metros e produz como 
resultado o tipo  \lstinline@Unit@. \code{While} invoca a fun\c{c}\~{a}o comando
enquanto a fun\c{c}\~{a}o teste produzir verdadeiro.
%----------

O tipo Scala \lstinline@Unit@ corresponde grosseiramente ao \lstinline@void@
no Java; \'{e} usado sempre que uma fun\c{c}\~{a}o n\~{a}o retornar um resultado interessante.
De fato, porque Scala \'{e} uma linguagem orientada a express\~{o}es, cada fun\c{c}\~{a}o 
retorna algum resultado. Se nenhuma express\~{a}o de retorno \'{e}  explicitamente
fornecida, o valor \lstinline@()@, que \'{e} pronunciado ``unit'', \'{e} assumido.
Este valor \'{e} do tipo \lstinline@Unit@. Fun\c{c}\~{o}es que retornam ``unit'' s\~{a}o 
tamb\'{e}m chamadas {\em procedimentos}. Aqui est\'{a} uma formula\c{c}\~{a}o mais 
``orientada a express\~{a}o'' da fun\c{c}\~{a}o \lstinline@swap@ na primeira implementa\c{c}\~{a}o
do quicksort, que explicita isto:
%----------

\begin{lstlisting}
def swap(i: Int, j: Int) {
  val t = xs(i); xs(i) = xs(j); xs(j) = t
  ()
}
\end{lstlisting}

%----------
%% The result value of this function is simply its last expression -- a
%% \lstinline@return@ keyword is not necessary. Note that functions
%% returning an explicit value always need an ``='' before their
%% body or defining expression.  
O valor resultante desta fun\c{c}\~{a}o \'{e} simplesmente sua \'{u}ltima express\~{a}o---uma
palavra chave \lstinline@return@ n\~{a}o \'{e} necess\'{a}ria. Observe que fun\c{c}\~{o}es 
que retornam um valor expl\'{i}cito sempre precisam de um ``='' antes de
seus corpos ou express\~{o}es de defini\c{c}\~{a}o.
%----------

\chapter{Programando com Atores e Mensagens}
\label{chap:example-auction}
%----------
%% Here's an example that shows an application area for which Scala is
%% particularly well suited. Consider the task of implementing an
%% electronic auction service. We use an Erlang-style actor process
%% model to implement the participants of the auction. Actors are
%% objects to which messages are sent. Every actor has a ``mailbox'' of
%% its incoming messages which is represented as a queue. It can work
%% sequentially through the messages in its mailbox, or search for
%% messages matching some pattern.
Aqui est\'{a} um exemplo que mostra uma \'{a}rea de aplica\c{c}\~{a}o para a qual Scala 
\'{e} particularmente indicada. Considere a tarefa de implementar um servi\c{c}o
de leil\~{a}o eletr\^{o}nico. Podemos usar um modelo de processo no estilo 
actor do Erlang para implementar os participantes do leil\~{a}o. Actors s\~{a}o 
objetos para os quais as mensagens s\~{a}o enviadas. Cada actor tem uma caixa de correio 
para suas mensagens de entrada que \'{e} representada para uma fila. Pode
trabalhar sequencialmente nas mensagens da sua caixa de correio, ou buscar 
por mensagens que casam com algum padr\~{a}o. 
%----------
\begin{lstlisting}[style=floating,label=fig:simple-auction-msgs,caption=Message
    Classes for an Auction Service]
import scala.actors.Actor

abstract class AuctionMessage
case class Offer(bid: Int, client: Actor)  extends AuctionMessage
case class Inquire(client: Actor)          extends AuctionMessage

abstract class AuctionReply
case class  Status(asked: Int, expire: Date) extends AuctionReply
case object BestOffer                        extends AuctionReply
case class  BeatenOffer(maxBid: Int)         extends AuctionReply
case class  AuctionConcluded(seller: Actor, client: Actor) 
                                             extends AuctionReply
case object AuctionFailed                    extends AuctionReply
case object AuctionOver                      extends AuctionReply
\end{lstlisting}
%----------
%% For every traded item there is an auctioneer actor that publishes
%% information about the traded item, that accepts offers from clients
%% and that communicates with the seller and winning bidder to close the
%% transaction. We present an overview of a simple implementation
%% here.
Para cada item negociado h\'{a} um actor leiloeiro que publica a 
informa\c{c}\~{a}o sobre o item negociado, que aceita ofertas de clientes
e que se comunica com o vendedor e com o vencedor do leil\~{a}o 
para fechar a transa\c{c}\~{a}o. Apresentamos uma vis\~{a}o superficial de uma
 implementa\c{c}\~{a}o aqui.
%----------

%----------
%% As a first step, we define the messages that are exchanged during an
%% auction. There are two abstract base classes
%% \code{AuctionMessage} for messages from clients to the auction
%% service, and \code{AuctionReply} for replies from the service to the
%% clients.  For both base classes there exists a number of cases, which
%% are defined in Figure~\ref{fig:simple-auction-msgs}.
Como primeiro passo, definimos as mensagens que s\~{a}o trocadas durante um
leil\~{a}o. H\'{a} duas classes base abstratas \code{AuctionMessage} para mensagens 
de clientes do servi\c{c}o de leil\~{a}o, e \code{AuctionReply} para respostas 
do servi\c{c}o aos clientes. Para ambas as classes base h\'{a} um n\'{u}mero de casos 
definidos na Figura~\ref{fig:simple-auction-msgs}.
%----------

\begin{lstlisting}[style=floating,label=fig:simple-auction,caption=Implementation of an Auction Service]
class Auction(seller: Actor, minBid: Int, closing: Date) extends Actor {
  val timeToShutdown = 36000000  // msec
  val bidIncrement = 10
  def act() {
    var maxBid = minBid - bidIncrement
    var maxBidder: Actor = null
    var running = true
    while (running) {
      receiveWithin ((closing.getTime() - new Date().getTime())) {
        case Offer(bid, client) =>
          if (bid >= maxBid + bidIncrement) { 
            if (maxBid >= minBid) maxBidder ! BeatenOffer(bid)
            maxBid = bid; maxBidder = client; client ! BestOffer
          } else {
            client ! BeatenOffer(maxBid)
          }
        case Inquire(client) =>
          client ! Status(maxBid, closing)
        case TIMEOUT =>
          if (maxBid >= minBid) {
            val reply = AuctionConcluded(seller, maxBidder)
            maxBidder ! reply; seller ! reply
          } else {
            seller ! AuctionFailed
          }
          receiveWithin(timeToShutdown) {
            case Offer(_, client) => client ! AuctionOver
            case TIMEOUT => running = false
          }
      }
    }
  } 
}
\end{lstlisting}

%----------
%% For each base class, there are a number of {\em case classes} which
%% define the format of particular messages in the class. These messages
%% might well be ultimately mapped to small XML documents. We expect
%% automatic tools to exist that convert between XML documents and
%% internal data structures like the ones defined above.
Para cada classe base, h\'{a} um n\'{u}mero de {\em classes case} que definem
o formato de mensagens particulares dentro da classe. Estas mensagens
podem em \'{u}ltimo caso ser mapeadas a pequenos documentos XML. Esperamos
que hajam ferramentas autom\'{a}ticas que convertam entre documentos XML e 
estruturas de dados internas, tais como as definidas acima.
% Vinicius - Parei aqui. -> Basile, porque voce nao traduzi Ator?? 
%
% Resp: por que trata-se de um modelo de concorr\^{e}ncia (o nome do modelo) 
% usado por Scala que foi inspirado no modelo do Erlang:
%      http://ruben.savanne.be/articles/concurrency-in-erlang-scala
%----------

%----------
%% Figure~\ref{fig:simple-auction} presents a Scala implementation of a
%% class \code{Auction} for auction actors that coordinate the bidding
%% on one item. Objects of this class are created by indicating
%% \begin{itemize}
%% \item a seller actor which needs to be notified when the auction is over,
%% \item a minimal bid,
%% \item the date when the auction is to be closed.
%% \end{itemize}
%% The behavior of the actor is defined by its \code{act} method. That method
%% repeatedly selects (using \code{receiveWithin}) a message and reacts to it,
%% until the auction is closed, which is signaled by a \code{TIMEOUT}
%% message. Before finally stopping, it stays active for another period
%% determined by the \code{timeToShutdown} constant and replies to
%% further offers that the auction is closed.
A Figura~\ref{fig:simple-auction} apresenta uma implementa\c{c}\~{a}o Scala para a classe
\code{Auction} para actors do leil\~{a}o que coordenam os lances sobre um item. Objetos
para esta classe s\~{a}o criados pela indica\c{c}\~{a}o
\begin{itemize}
\item Um actor vendedor que precisa ser notificado quando o leil\~{a}o terminou,
\item o lance m\'{i}nimo,
\item a data de quando o leil\~{a}o foi fechado.
\end{itemize}  
O comportamento do actor \'{e} definido por seu m\'{e}todo \code{act}. Este m\'{e}todo seleciona
repetidamente (usando \code{receiveWithin}) uma mensagem e reage a ela, at\'{e} que o 
leil\~{a}o seja fechado, o que \'{e} sinalizado por uma mensagem \code{TIMEOUT}. Antes de 
finalmente parar, permanece ativo para um outro per\'{i}odo determinado pela constante 
\code{timeToShutdown} e replica para ofertas posteriores que o leil\~{a}o est\'{a} fechado.    

Aqui est\~{a}o algumas explica\c{c}\~{o}es extras sobre os construtores usados neste programa:
\begin{itemize}
\item
O m\'{e}todo \code{receiveWithin} da classe \code{Actor} recebe como par\^{a}metro um prazo dado
em milisegundos e uma fun\c{c}\~{a}o que processa mensagens na caixa de correio. A fun\c{c}\~{a}o \'{e} dada
por uma sequ\^{e}ncia de cases que especificam um padr\~{a}o e uma a\c{c}\~{a}o para mensagens que 
casam com o padr\~{a}o. O m\'{e}todo \code{receiveWithin} seleciona a primeira mensagem da 
caixa de correio que casa com um destes padr\~{o}es e aplica a a\c{c}\~{a}o correspondente a ele. 
%----------


%----------
%% \item
%% The last case of \code{receiveWithin} is guarded by a
%% \code{TIMEOUT} pattern. If no other messages are received in the meantime, this
%% pattern is triggered after the time span which is passed as argument
%% to the enclosing \code{receiveWithin} method. \code{TIMEOUT} is a
%% special message, which is triggered by the \code{Actor} implementation itself.
\item
O \'{u}ltimo case de \code{receiveWithin} \'{e} guardado por um padr\~{a}o \code{TIMEOUT}.  
Se nenhuma outra mensagem foi recebida nesse meio tempo, este padr\~{a}o \'{e} disparado
ap\'{o}s o prazo que foi passado como argumento para o m\'{e}todo envolvente \code{receiveWithin}.
\code{TIMEOUT} \'{e} uma mensagem especial, que \'{e} disparada pela pr\'{o}pria implementa\c{c}\~{a}o do 
\code{Actor}.    
%----------

%----------
%% \item
%% Reply messages are sent using syntax of the form
%% \code{destination ! SomeMessage}. \code{!} is used here as a
%% binary operator with an actor and a message as arguments. This is
%% equivalent in Scala to the method call
%% \code{destination.!(SomeMessage)}, i.e. the invocation of
%% the \code{!} method of the destination actor with the given message as
%% parameter.
%% \end{itemize}
\item
Mensagens de resposta s\~{a}o enviadas usando sintaxe da forma \code{destino ! AlgumaMensagem}.
\code{!} \'{e} usado aqui como um operador bin\'{a}rio com um actor e uma mensagem como argumentos.
Isto \'{e} equivalente em Scala ao chamado de m\'{e}todo \code{destino.!(AlgumaMensagem)}, ou seja, 
a invoca\c{c}\~{a}o do m\'{e}todo \code{!} do actor destino com a mensagem dada como par\^{a}metro.
\end{itemize}    
%----------

%----------
%% The preceding discussion gave a flavor of distributed programming in
%% Scala. It might seem that Scala has a rich set of language constructs
%% that support actor processes, message sending and receiving,
%% programming with timeouts, etc. In fact, the opposite is true. All the
%% constructs discussed above are offered as methods in the library class
%% \code{Actor}. That class is itself implemented in Scala, based on the underlying 
%% thread model of the host language (e.g. Java, or .NET).
%% The implementation of all features of class \code{Actor} used here is
%% given in Section~\ref{sec:actors}.
A discuss\~{a}o precedente deu uma id\'{e}ia de programa\c{c}\~{a}o distribu\'{i}da em Scala. Isso
d\'{a} a sensa\c{c}\~{a}o que Scala tem um rico conjunto de construtores que suportam
processos actor, envio e recebimento de mensagens, programa\c{c}\~{a}o com timeouts etc.
De fato, o oposto \'{e} verdadeiro. Todos os construtores discutidos acima s\~{a}o 
oferecidos como m\'{e}todos na classe biblioteca \code{Actor}. Aquela classe \'{e}
ele mesma implementada em Scala, baseado no modelo thread subjacente à linguagem 
hospedeira (Java ou .NET). A implementa\c{c}\~{a}o de todas as caracter\'{i}sticas da 
classe \code{Actor} usada aqui \'{e} dada na Se\c{c}\~{a}o~\ref{sec:actors}.     
%----------

%----------
%% The advantages of the library-based approach are relative simplicity
%% of the core language and flexibility for library designers. Because
%% the core language need not specify details of high-level process
%% communication, it can be kept simpler and more general. Because the
%% particular model of messages in a mailbox is a library module, it can
%% be freely modified if a different model is needed in some
%% applications.  The approach requires however that the core language is
%% expressive enough to provide the necessary language abstractions in a
%% convenient way. Scala has been designed with this in mind; one of its
%% major design goals was that it should be flexible enough to act as a
%% convenient host language for domain specific languages implemented by
%% library modules. For instance, the actor communication constructs
%% presented above can be regarded as one such domain specific language,
%% which conceptually extends the Scala core.
As vantagens da abordagem baseada em biblioteca s\~{a}o a relativa simplicidade
da linguagem n\'{u}cleo e a flexibilidade para os criadores de biblioteca. Como 
a linguagem n\'{u}cleo n\~{a}o precisa especificar detalhes da comunica\c{c}\~{a}o dos 
processos de alto n\'{i}vel, pode ser mantida mais simples e geral. Como
um modelo particular de mensagens numa caixa de correio \'{e} um m\'{o}dulo biblioteca, 
pode ser modificado livremente se um diferente modelo for necess\'{a}rio em algumas 
aplica\c{c}\~{o}es. A abordagem requer, entretanto, que a linguagem n\'{u}cleo seja expressiva
o suficiente para prover as abstra\c{c}\~{o}es lingu\'{i}sticas necess\'{a}rias de um modo 
conveniente. Scala foi criada com isto em mente; um de seus maiores objetivos de 
design foi deix\'{a}-la flex\'{i}vel o suficiente para atuar como uma conveniente linguagem
hospedeira para dom\'{i}nios de linguagens espec\'{i}ficos implementados por m\'{o}dulos de 
biblioteca. Por exemplo, a constru\c{c}\~{a}o de comunica\c{c}\~{a}o actor apresentada acima
pode ser vista como um desses dom\'{i}nios espec\'{i}ficos de linguagem, que conceitualmente
estendem o n\'{u}cleo Scala.  
%----------

%----------
% Vinicius - comecei traducao aqui.
%%\chapter{\label{chap:simple-funs}Expressions and Simple Functions}
\chapter{\label{chap:simple-funs}Express\~{o}es e Fun\c{c}\~{o}es Simples}

%% The previous examples gave an impression of what can be done with
%% Scala.  We now introduce its constructs one by one in a more
%% systematic fashion. We start with the smallest level, expressions and
%% functions.
Os exemplos anteriores deram uma ideia do que pode ser feito com Scala. Agora,
introduzimos as suas constru\c{c}\~{o}es de linguagem uma a uma de uma maneira mais sistem\'{a}tica.
Vamos come\c{c}ar com os menores elementos: express\~{o}es e fun\c{c}\~{o}es.


%%\section{Expressions And Simple Functions}
\section{Express\~{o}es e Fun\c{c}\~{o}es Simples}

%% A Scala system comes with an interpreter which can be seen as a fancy
%% calculator. A user interacts with the calculator by typing in
%% expressions. The calculator returns the evaluation results and their
%% types. For example:
%----------
Scala vem com um interpretador que pode ser visto como uma calculadora sofisticada.
O usu\'{a}rio interage com a calculadora digitando express\~{o}es. A calculadora retorna o
resultado do c\'{a}lculo e o seu tipo de dado. Por exemplo: 

\begin{lstlisting}
scala> 87 + 145
unnamed0: Int = 232

scala> 5 + 2 * 3
unnamed1: Int = 11

scala> "hello" + " world!"
unnamed2: java.lang.String = hello world!
\end{lstlisting}
%It is also possible to name a sub-expression and use the name instead
%of the expression afterwards:
Tamb\'{e}m \'{e} poss\'{i}vel dar nome a uma sub-express\~{a}o e usar o nome, ao inv\'{e}s da express\~{a}o, 
nas express\~{o}es seguintes:
\begin{lstlisting}
scala> def scale = 5
scale: Int

scala> 7 * scale
unnamed3: Int = 35
\end{lstlisting}
\begin{lstlisting}
scala> def pi = 3.141592653589793
pi: Double

scala> def radius = 10
radius: Int

scala> 2 * pi * radius
unnamed4: Double = 62.83185307179586
\end{lstlisting}



%% Definitions start with the reserved word \code{def}; they introduce a
%% name which stands for the expression following the \code{=} sign.  The
%% interpreter will answer with the introduced name and its type.
Defini\c{c}\~{o}es come\c{c}am com a palavra reservada \code{def}. Elas introduzem um nome
que representa a express\~{a}o que vem depois do s\'{i}mbolo \code{=}. O intepretrador
responde com o nome introduzido e o seu tipo de dado.
% Vinicius - parei traducao aqui.



%----------
%% Executing a definition such as \code{def x = e} will not evaluate the
%% expression \code{e}.  Instead \code{e} is evaluated whenever \code{x}
%% is used. Alternatively, Scala offers a value definition 
%% \code{val x = e}, which does evaluate the right-hand-side \code{e} as part of the
%% evaluation of the definition. If \code{x} is then used subsequently,
%% it is immediately replaced by the pre-computed value of
%% \code{e}, so that the expression need not be evaluated again.
Executando uma defini\c{c}\~{a}o tal como \code{def x = e} n\~{a}o avaliar\'{a} a express\~{a}o \code{e}. 
Ao inv\'{e}s \code{e} \'{e} avaliado sempre que \code{x} for usado. Alternativamente, Scala 
oferece um valor defini\c{c}\~{a}o \code{val x = e}, o qual avalia o lado direito de \code{e}
como parte da avalia\c{c}\~{a}o da defini\c{c}\~{a}o. Se \code{x} \'{e} ent\~{a}o usado subsequentemente, \'{e} 
imediatamente substitu\'{i}do pelo valor pr\'{e}-computado de \code{e}, logo a express\~{a}o n\~{a}o 
precisa ser avaliada novamente.
%----------

%---------- 
%% How are expressions evaluated? An expression consisting of operators
%% and operands is evaluated by repeatedly applying the following
%% simplification steps.
%% \begin{itemize}
%% \item pick the left-most operation
%% \item evaluate its operands
%% \item apply the operator to the operand values.
%% \end{itemize}
%% A name defined by \code{def}\ is evaluated by replacing the name by the
%% (unevaluated) definition's right hand side. A name defined by \code{val} is
%% evaluated by replacing the name by the value of the definitions's
%% right-hand side.  The evaluation process stops once we have reached a
%% value. A value is some data item such as a string, a number, an array,
%% or a list.
Como as express\~{o}es s\~{a}o avaliadas? Uma express\~{a}o consistindo de operadores e 
operandos \'{e} avaliada pela repetida aplica\c{c}\~{a}o dos seguintes passos de simplifica\c{c}\~{a}o:
\begin{itemize}
\item escolha a opera\c{c}\~{a}o mais a esquerda.
\item avalie seu operando
\item aplique o operador aos valores do operando.
\end{itemize}
Um nome definido por \code{def} \'{e} avaliado substituindo o nome pela defini\c{c}\~{a}o do lado
direito (n\~{a}o avaliada). Um nome definido por \code{val} \'{e} avaliado pela substitui\c{c}\~{a}o do 
nome pelo valor da defini\c{c}\~{a}o do lado direito. O processo de avalia\c{c}\~{a}o p\'{a}ra assim que 
encontrarmos um valor. Um valor \'{e} algum dado, tal como uma cadeia de caracteres, um n\'{u}mero, 
um vetor, ou uma lista.
%----------


%----------
%% \example
%% Here is an evaluation of an arithmetic expression.
%% \begin{lstlisting}
%% $\,\,\,$   (2 * pi) * radius
%% $\rightarrow$  (2 * 3.141592653589793) * radius
%% $\rightarrow$  6.283185307179586 * radius
%% $\rightarrow$  6.283185307179586 * 10
%% $\rightarrow$  62.83185307179586
%% \end{lstlisting}
%% The process of stepwise simplification of expressions to values is
%% called {\em reduction}.

\example
Aqui est\'{a} uma avalia\c{c}\~{a}o de uma express\~{a}o aritm\'{e}tica.

\begin{lstlisting}
$\,\,\,$   (2 * pi) * radius
$\rightarrow$  (2 * 3.141592653589793) * radius
$\rightarrow$  6.283185307179586 * radius
$\rightarrow$  6.283185307179586 * 10
$\rightarrow$  62.83185307179586
\end{lstlisting}
O processo de simplificar gradualmente express\~{o}es para valores \'{e} 
chamado {\em redu\c{c}\~{a}o}.
%----------


\section{Par\^{a}metros}

Usando \code{def}, pode-se tamb\'{e}m definir fun\c{c}\~{o}es com par\^{a}metros. Por exemplo:
\begin{lstlisting}
scala> def square(x: Double) = x * x
square: (Double)Double

scala> square(2)
unnamed0: Double = 4.0

scala> square(5 + 3)
unnamed1: Double = 64.0

scala> square(square(4))
unnamed2: Double = 256.0

scala> def sumOfSquares(x: Double, y: Double) = square(x) + square(y)
sumOfSquares: (Double,Double)Double

scala> sumOfSquares(3, 2 + 2)
unnamed3: Double = 25.0
\end{lstlisting}

%----------
%% Function parameters follow the function name and are always enclosed
%% in parentheses.  Every parameter comes with a type, which is indicated
%% following the parameter name and a colon.  At the present time, we
%% only need basic numeric types such as the type \code{scala.Double} of
%% double precision numbers. Scala defines {\em type aliases} for some
%% standard types, so we can write numeric types as in Java. For instance
%% \code{double} is a type alias of \code{scala.Double} and \code{int} is
%% a type alias for \code{scala.Int}.
Par\^{a}metros de fun\c{c}\~{o}es seguem o nome da fun\c{c}\~{a}o e sempre s\~{a}o envolvidos por
par\^{e}nteses. Cada par\^{a}metro vem com um tipo que segue o nome do par\^{a}metro
e dois pontos. At\'{e} aqui, s\'{o} precisamos de tipos num\'{e}ricos, tal como o tipo
\code{scala.Double} dos n\'{u}meros de precis\~{a}o dupla. Scala define {\em tipos
aliases} para alguns tipos b\'{a}sicos, logo podemos escrever tipos num\'{e}ricos 
como em Java. Por exemplo, \code{double} \'{e} um tipo alias de \code{scala.Double}
e \code{int} \'{e} um tipo alias para \code{scala.Int}.       
%----------

%----------
%% Functions with parameters are evaluated analogously to operators in
%% expressions. First, the arguments of the function are evaluated (in
%% left-to-right order). Then, the function application is replaced by
%% the function's right hand side, and at the same time all formal
%% parameters of the function are replaced by their corresponding actual
%% arguments.
Fun\c{c}\~{o}es com par\^{a}metros s\~{a}o avaliadas analogamente a operadores em express\~{o}es.
Primeiro, os argumentos da fun\c{c}\~{a}o s\~{a}o avaliados (da esquerda para direita). 
Ent\~{a}o, a aplica\c{c}\~{a}o da fun\c{c}\~{a}o \'{e} substitu\'{i}do pelo lado direito da fun\c{c}\~{a}o, e
ao mesmo tempo todos os par\^{a}metros formais s\~{a}o substitu\'{i}dos pelos seus 
argumentos atuais. 
%----------

\example\ 
 
\begin{lstlisting}
$\,\,\,$   sumOfSquares(3, 2+2)
$\rightarrow$  sumOfSquares(3, 4)
$\rightarrow$  square(3) + square(4)
$\rightarrow$  3 * 3 + square(4)
$\rightarrow$  9 + square(4)
$\rightarrow$  9 + 4 * 4
$\rightarrow$  9 + 16
$\rightarrow$  25
\end{lstlisting}

%----------
%% The example shows that the interpreter reduces function arguments to
%% values before rewriting the function application.  One could instead
%% have chosen to apply the function to unreduced arguments. This would
%% have yielded the following reduction sequence:
O exemplo mostra que o interpretador reduz argumentos de fun\c{c}\~{o}es a valores 
antes de reescrever a aplica\c{c}\~{a}o da fun\c{c}\~{a}o. Pode-se ao inv\'{e}s escolher aplicar
a fun\c{c}\~{a}o a argumentos n\~{a}o reduzidos. Isto levar\'{a} a seguinte sequ\^{e}ncia de 
redu\c{c}\~{a}o: 
%----------

\begin{lstlisting}
$\,\,\,$   sumOfSquares(3, 2+2)
$\rightarrow$  square(3) + square(2+2)
$\rightarrow$  3 * 3 + square(2+2)
$\rightarrow$  9 + square(2+2)
$\rightarrow$  9 + (2+2) * (2+2)
$\rightarrow$  9 + 4 * (2+2)
$\rightarrow$  9 + 4 * 4
$\rightarrow$  9 + 16
$\rightarrow$  25
\end{lstlisting}
%----------
%% The second evaluation order is known as \emph{call-by-name},
%% whereas the first one is known as \emph{call-by-value}.  For
%% expressions that use only pure functions and that therefore can be
%% reduced with the substitution model, both schemes yield the same final
%% values.  
A segunda ordem de avalia\c{c}\~{a}o \'{e} conhecida como \emph{chamada por nome},
e a primeira por \emph{chamada por valor}. Para express\~{o}es que se utilizam
apenas de fun\c{c}\~{o}es e que portanto podem ser reduzidas com o modelo de 
substitui\c{c}\~{a}o, ambos os esquemas levam ao mesmo valor final.
%----------

%----------
%% Call-by-value has the advantage that it avoids repeated evaluation of
%% arguments. Call-by-name has the advantage that it avoids evaluation of
%% arguments when the parameter is not used at all by the function.
%% Call-by-value is usually more efficient than call-by-name, but a
%% call-by-value evaluation might loop where a call-by-name evaluation
%% would terminate. Consider:
Chamada por valor tem a vantagem de evitar avalia\c{c}\~{o}es repetidas de argumentos.
Chamada por nome tem a vantagem de evitar avalia\c{c}\~{o}es de argumentos quando o 
par\^{a}metro n\~{a}o \'{e} usado pela fun\c{c}\~{a}o. Chamada por valor \'{e} geralmente mais 
eficiente que chamada por nome, mas uma avalia\c{c}\~{a}o de chamada por valor
pode entrar em la\c{c}o infinito, enquanto uma avalia\c{c}\~{a}o de chamada por nome 
termina. Considere: 
%----------
\begin{lstlisting}
scala> def loop: Int = loop
loop: Int

scala> def first(x: Int, y: Int) = x
first: (Int,Int)Int
\end{lstlisting}
%----------
%% Then \code{first(1, loop)} reduces with call-by-name to \code{1},
%% whereas the same term reduces with call-by-value repeatedly to itself,
%% hence evaluation does not terminate.
Ent\~{a}o \code{first(1, loop)} \'{e} reduzido com uma chamada por nome a \code{1},
enquanto o mesmo termo, atrav\'{e}s de uma chamada por valor reduz a si mesmo 
repetidamente, logo a avalia\c{c}\~{a}o n\~{a}o termina.  
%----------
\begin{lstlisting}
$\,\,\,$   first(1, loop)
$\rightarrow$  first(1, loop)
$\rightarrow$  first(1, loop)
$\rightarrow$  ...
\end{lstlisting}
%----------
%% Scala uses call-by-value by default, but it switches to call-by-name evaluation
%% if the parameter type is preceded by \code{=>}.
Scala usa chamada por valor por default, mas muda para avalia\c{c}\~{a}o de chamada por nome 
se o tipo do par\^{a}metro for precedido por \code{=>}. 
\example\ 
 
\begin{lstlisting}
scala> def constOne(x: Int, y: => Int) = 1
constOne: (Int,=> Int)Int

scala> constOne(1, loop)
unnamed0: Int = 1

scala> constOne(loop, 2)               // leva a la\c{c}o infinito
^C                                     // para a execu\c{c}\~{a}o com Ctrl-C
\end{lstlisting}

\section{Express\~{o}es Condicionais}
O \code{if-else} do Scala leva a uma escolha entre duas alternativas. Sua
sintaxe \'{e} a mesma do \code{if-else} do Java. Mas onde o \code{if-else} do 
Java pode ser usado somente como uma alternativa entre comandos, Scala 
permite a mesma sintaxe para escolher entre duas express\~{o}es. Isso porque o
\code{if-else} do Scala serve tamb\'{e}m como um substituto para a express\~{a}o 
condicional do Java \code{... ? ... : ...}.      

\example\
\begin{lstlisting}
scala> def abs(x: Double) = if (x >= 0) x else -x
abs: (Double)Double
\end{lstlisting}
Express\~{o}es boleanas em Scala s\~{a}o similares as em Java; s\~{a}o formadas
a partir de constantes.  
\code{true} e
\code{false}, operadores de compara\c{c}\~{a}o, nega\c{c}\~{a}o boleana \code{!} e os 
operadores boleanos  $\,$\code{&&}$\,$ and $\,$\code{||}. 

\section{\label{sec:sqrt}Exemplo: Raiz Quadrada pelo M\'{e}todo de Newton}
Agora ilustraremos elementos da linguagem intruduzidos at\'{e} aqui na
constru\c{c}\~{a}o de um programa mais interessante. A tarefa \'{e} escrever um fun\c{c}\~{a}o  
 \begin{lstlisting}
 def sqrt(x: Double): Double = ...
 \end{lstlisting}
que computa a raiz quadrada de \code{x}. 

Um modo comum de se computar raizes quadradas \'{e} pelo m\'{e}todo das aproxima\c{c}\~{o}es
sucessivas de Newton. Inicia-se com um palpite inicial \code{y} (digamos:
\code{y = 1}). Ent\~{a}o melhora-se repetidamente o atual palpite \code{y} 
tomando-se a m\'{e}dia de \code{y} e \code{x/y}. Como um exemplo, as pr\'{o}ximas
tr\^{e}s colunas indicam o palpite \code{y}, o quociente \code{x/y}, e suas
m\'{e}dias para as primeiras aproxima\c{c}\~{o}es para 
$\sqrt 2$.       

\begin{lstlisting}
1            2/1 = 2               1.5
1.5          2/1.5 = 1.3333        1.4167
1.4167       2/1.4167 = 1.4118     1.4142
1.4142       ...                   ...

$y$            $x/y$                   $(y + x/y)/2$
\end{lstlisting}
%----------

%----------
%% One can implement this algorithm in Scala by a set of small functions,
%% which each represent one of the elements of the algorithm.  

%% We first define a function for iterating from a guess to the result:

Este algoritmo pode ser implementado em Scala por um conjunto de pequenas fun\c{c}\~{o}es,
onde cada uma representa um dos elementos do algoritmo.

Primeiro definimos uma fun\c{c}\~{a}o para iterar do palpite para o resultado:
%-----------


\begin{lstlisting}
def sqrtIter(guess: Double, x: Double): Double =
  if (isGoodEnough(guess, x)) guess
  else sqrtIter(improve(guess, x), x)
\end{lstlisting}

%-----------
%% Note that \code{sqrtIter} calls itself recursively.  Loops in
%% imperative programs can always be modeled by recursion in functional
%% programs.
 
Observe que \code{sqrtIter} chama a si mesmo recursivamente. La\c{c}os em 
programas imperativos podem sempre ser modelados por recurs\~{a}o em 
programas funcionais. 
%----------

%----------
%% Note also that the definition of \code{sqrtIter} contains a return
%% type, which follows the parameter section. Such return types are
%% mandatory for recursive functions. For a non-recursive function, the
%% return type is optional; if it is missing the type checker will
%% compute it from the type of the function's right-hand side. However,
%% even for non-recursive functions it is often a good idea to include a
%% return type for better documentation.
Observe tamb\'{e}m que a defini\c{c}\~{a}o de \code{sqrtIter} cont\'{e}m um tipo retorno,
que segue o se\c{c}\~{a}o de par\^{a}metros. Tais tipos de retorno s\~{a}o mandat\'{o}rios para 
fun\c{c}\~{o}es recursivas. Para uma fun\c{c}\~{a}o n\~{a}o recursiva, o tipo de retorno \'{e} opcional;
se estiver faltando o verificador de tipos o computar\'{a} a partir do tipo do lado
direito da fun\c{c}\~{a}o. Entretanto, mesmo para fun\c{c}\~{o}es n\~{a}o recursivas \'{e} sempre boa id\'{e}ia 
incluir um tipo de retorno para melhor documenta\c{c}\~{a}o.  
%----------

%----------
%% As a second step, we define the two functions called by
%% \code{sqrtIter}: a function to \code{improve} the guess and a
%% termination test \code{isGoodEnough}. Here is their definition.

Como segundo passo, definimos as duas fun\c{c}\~{o}es chamadas por:
\code{sqrtIter}: uma fun\c{c}\~{a}o para melhorar (\code{improve}) o palpite e um
teste de termina\c{c}\~{a}o \code{isGoodEnough}. Aqui est\~{a}o suas defini\c{c}\~{o}es.
\begin{lstlisting}
def improve(guess: Double, x: Double) =
  (guess + x / guess) / 2    

def isGoodEnough(guess: Double, x: Double) =
  abs(square(guess) - x) < 0.001
\end{lstlisting}

%% Finally, the \code{sqrt} function itself is defined by an application
%% of \code{sqrtIter}.
Finalmente, a pr\'{o}pria fun\c{c}\~{a}o \code{sqrt} \'{e} definida como uma aplica\c{c}\~{a}o de
\code{sqrtIter}.
  
\begin{lstlisting}
def sqrt(x: Double) = sqrtIter(1.0, x)
\end{lstlisting}
%----------

%----------
%% \begin{exercise} The \code{isGoodEnough} test is not very precise for small
%% numbers and might lead to non-termination for very large ones (why?).
%% Design a different version of \code{isGoodEnough} which does not have
%% these problems.
%% \end{exercise}

%% \begin{exercise} Trace the execution of the \code{sqrt(4)} expression.
%% \end{exercise}
\begin{exercise} O teste \code{isGoodEnough} n\~{a}o \'{e} muito preciso para pequenos 
n\'{u}meros e podem levar a n\~{a}o termina\c{c}\~{a}o para n\'{u}meros muito grandes (por que?).
Crie uma vers\~{a}o diferente para \code{isGoodEnough} que n\~{a}o tenham esses problemas.
\end{exercise}

\begin{exercise} Simule a execu\c{c}\~{a}o da express\~{a}o \code{sqrt(4)}.
\end{exercise}
%----------

%----------
%% \section{Nested Functions}

%% The functional programming style encourages the construction of many
%% small helper functions. In the last example, the implementation
%% of \code{sqrt} made use of the helper functions \code{sqrtIter},
%% \code{improve} and \code{isGoodEnough}. The names of these functions
%% are relevant only for the implementation of \code{sqrt}. We normally
%% do not want users of \code{sqrt} to access these functions directly.
\section{Aninhamento de Fun\c{c}\~{o}es}

A programa\c{c}\~{a}o funcional encoraja a constru\c{c}\~{a}o de muitas pequenas fun\c{c}\~{o}es
auxiliares. Nos \'{u}ltimos exemplos, a implementa\c{c}\~{a}o de \code{sqrt} faz uso da
fun\c{c}\~{o}es auxiliares \code{sqrtIter}, \code{improve} e \code{isGoodEnough}.
Os nomes destas fun\c{c}\~{o}es s\~{a}o relevantes somente para a implementa\c{c}\~{a}o de 
\code{sqrt}. Normalmente n\~{a}o queremos que os usu\'{a}rios de \code{sqrt} acessem
estas fun\c{c}\~{o}es diretamente.  
%----------

%----------
%% We can enforce this (and avoid name-space pollution) by including
%% the helper functions within the calling function itself:
N\'{o}s podemos refor\c{c}ar isto (e evitar polui\c{c}\~{a}o de nomes) incluindo
fun\c{c}\~{o}es auxiliares dentro das pr\'{o}prias fun\c{c}\~{o}es: 
\begin{lstlisting}
def sqrt(x: Double) = {
  def sqrtIter(guess: Double, x: Double): Double =
    if (isGoodEnough(guess, x)) guess
    else sqrtIter(improve(guess, x), x)
  def improve(guess: Double, x: Double) =
    (guess + x / guess) / 2
  def isGoodEnough(guess: Double, x: Double) =
    abs(square(guess) - x) < 0.001
  sqrtIter(1.0, x)
}
\end{lstlisting}
%----------

%----------
%% In this program, the braces \code{\{ ... \}} enclose a {\em block}.
%% Blocks in Scala are themselves expressions.  Every block ends in a
%% result expression which defines its value.  The result expression may
%% be preceded by auxiliary definitions, which are visible only in the
%% block itself.
Neste programa, as chaves \code{\{ ... \}} envolvem um {\em bloco}. 
Blocos em Scala s\~{a}o eles mesmos express\~{o}es. Cada bloco termina com um
express\~{a}o resultado o qual define seu valor. A express\~{a}o  resultado pode 
ser precedida por defini\c{c}\~{o}es auxiliares, as quais s\~{a}o vis\'{i}veis somente no
pr\'{o}prio bloco. 
%----------

%----------
%% Every definition in a block must be followed by a semicolon, 
%% which separates this definition from subsequent definitions or the result
%% expression. However, a semicolon is inserted implicitly at the end of
%% each line, unless one of the following conditions is
%% true.
Cada defini\c{c}\~{a}o no bloco pode ser seguida para um ponto e v\'{i}rgula, o qual 
separa esta defini\c{c}\~{a}o das defini\c{c}\~{o}es subsequentes ou a express\~{a}o  resultado.
Entretanto, um ponto e v\'{i}rgula \'{e} inserido implicitamente ao final de cada linha,
a n\~{a}o ser que uma das condi\c{c}\~{o}es a seguir seja verdadeira.
%----------

%----------
%% \begin{enumerate}
%% \item
%% Either the line in question ends in a word such as a period 
%% or an infix-operator which would not be legal as the end of an expression.
%% \item
%% Or the next line begins with a word that cannot start a expression.
%% \item
%% Or we are inside parentheses \prog{$($...$)$} or brackets \prog{}, 
%% because these cannot contain multiple statements anyway.
%% \end{enumerate}
\begin{enumerate}
\item 
Ou a linha em quest\~{a}o termina com uma palavra tal que um ponto ou um 
operador infixo n\~{a}o s\~{a}o legais ao final da express\~{a}o.
\item 
Ou a pr\'{o}xima linha inicia com uma palavra que n\~{a}o pode iniciar uma express\~{a}o.
\item
Ou estamos dentro de par\^{e}nteses \prog{$($...$)$} ou chaves \prog{}, porque 
estes n\~{a}o podem conter multiplos comandos de qualquer modo.
\end{enumerate}
%----------

%----------
%% Therefore, the following are all legal:
Entretanto, os seguintes s\~{a}o legais:

\begin{lstlisting}
def f(x: Int) = x + 1;
f(1) + f(2)

def g1(x: Int) = x + 1
g(1) + g(2)

def g2(x: Int) = {x + 1};  /* `;' mandat\'{o}rio */ g2(1) + g2(2)

def h1(x) = 
  x + 
  y
h1(1) * h1(2)

def h2(x: Int) = (
  x     // par\^{e}nteses mandat\'{o}rio, sen\~{a}o um ponto e v\'{i}rgula
  + y   // ser\'{a} inserido ap\'{o}s o `x'.
)
h2(1) / h2(2)
\end{lstlisting}
%----------

%----------
%% Scala uses the usual block-structured scoping rules. A name defined in
%% some outer block is visible also in some inner block, provided it is
%% not redefined there. This rule permits us to simplify our
%% \code{sqrt} example. We need not pass \code{x} around as an additional parameter of
%% the nested functions, since it is always visible in them as a
%% parameter of the outer function \code{sqrt}. Here is the simplified code:
Scala usa as regras usuais de escopo de bloco estruturado. Um nome definido em
algum outro bloco \'{e} tamb\'{e}m vis\'{i}vel em algum bloco interno, desde que n\~{a}o tenha
sido redefinido l\'{a}. Esta regra nos permite simplificar nosso exemplo \code{sqrt}.
N\~{a}o precisamos passar \code{x} como par\^{a}metro adicional de fun\c{c}\~{o}es aninhadas, dado
que est\'{a} sempre vis\'{i}vel nelas como um par\^{a}metro da fun\c{c}\~{a}o externa \code{sqrt}.
Aqui est\'{a} o c\'{o}digo simplificado:
   
\begin{lstlisting}
def sqrt(x: Double) = {
  def sqrtIter(guess: Double): Double =
    if (isGoodEnough(guess)) guess
    else sqrtIter(improve(guess))
  def improve(guess: Double) =
    (guess + x / guess) / 2
  def isGoodEnough(guess: Double) =
    abs(square(guess) - x) < 0.001
  sqrtIter(1.0)
}
\end{lstlisting}
%----------


\section{Recurs\~{a}o de Cauda}

%%Consider the following function to compute the greatest common divisor
%%of two given numbers.
Considere a seguinte fun\c{c}\~{a}o para calcular o maior divisor comum entre
dois n\'{u}meros dados.

\begin{lstlisting}
def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)
\end{lstlisting}

%%Using our substitution model of function evaluation, 
Usando nosso modelo de substitui\c{c}\~{a}o da fun\c{c}\~{a}o de avalia\c{c}\~{a}o,
\code{gcd(14, 21)} evaluates as follows:

\begin{lstlisting}
$\,\,$      gcd(14, 21)  
$\rightarrow\!$     if (21 == 0) 14 else gcd(21, 14 % 21)
$\rightarrow\!$     if (false) 14 else gcd(21, 14 % 21)
$\rightarrow\!$     gcd(21, 14 % 21)
$\rightarrow\!$     gcd(21, 14)
$\rightarrow\!$     if (14 == 0) 21 else gcd(14, 21 % 14)
$\rightarrow$ $\rightarrow$  gcd(14, 21 % 14)
$\rightarrow\!$     gcd(14, 7)
$\rightarrow\!$     if (7 == 0) 14 else gcd(7, 14 % 7)
$\rightarrow$ $\rightarrow$  gcd(7, 14 % 7)
$\rightarrow\!$     gcd(7, 0)
$\rightarrow\!$     if (0 == 0) 7 else gcd(0, 7 % 0)
$\rightarrow$ $\rightarrow$  7
\end{lstlisting}

%%Contrast this with the evaluation of another recursive function, 
Contraste isto com a avalia\c{c}\~{a}o de uma outra fun\c{c}\~{a}o recursiva,
\code{factorial}:

\begin{lstlisting}
def factorial(n: Int): Int = if (n == 0) 1 else n * factorial(n - 1)
\end{lstlisting}

%%The application \code{factorial(5)} rewrites as follows:
A aplica\c{c}\~{a}o de \code{factorial(5)} \'{e} reescrita como segue: 

\begin{lstlisting}
$\,\,\,$       factorial(5)
$\rightarrow$      if (5 == 0) 1 else 5 * factorial(5 - 1)
$\rightarrow$      5 * factorial(5 - 1)
$\rightarrow$      5 * factorial(4)
$\rightarrow\ldots\rightarrow$  5 * (4 * factorial(3))
$\rightarrow\ldots\rightarrow$  5 * (4 * (3 * factorial(2)))
$\rightarrow\ldots\rightarrow$  5 * (4 * (3 * (2 * factorial(1))))
$\rightarrow\ldots\rightarrow$  5 * (4 * (3 * (2 * (1 * factorial(0))))
$\rightarrow\ldots\rightarrow$  5 * (4 * (3 * (2 * (1 * 1))))
$\rightarrow\ldots\rightarrow$  120
\end{lstlisting}

%----------
%% There is an important difference between the two rewrite sequences:
%% The terms in the rewrite sequence of \code{gcd} have again and again
%% the same form. As evaluation proceeds, their size is bounded by a
%% constant. By contrast, in the evaluation of factorial we get longer
%% and longer chains of operands which are then multiplied in the last
%% part of the evaluation sequence.
H\'{a} uma importante diferen\c{c}a entre as duas senten\c{c}as reescritas:
Os termos na sequ\^{e}ncia reescrita de \code{gcd} tem repetidamente a
mesma forma. Conforme a avalia\c{c}\~{a}o prossegue, seu tamanho \'{e} limitado por
uma constante. Diferentemente, na avalia\c{c}\~{a}o do fatorial obtemos cadeias
cada vez mais longas de operandos que s\~{a}o ent\~{a}o multiplicados na \'{u}ltima
parte da sequ\^{e}ncia de avalia\c{c}\~{a}o. 
%----------


%----------
%% Even though actual implementations of Scala do not work by rewriting
%% terms, they nevertheless should have the same space behavior as in the
%% rewrite sequences. In the implementation of \code{gcd}, one notes that
%% the recursive call to \code{gcd} is the last action performed in the
%% evaluation of its body. One also says that \code{gcd} is
%% ``tail-recursive''. The final call in a tail-recursive function can be
%% implemented by a jump back to the beginning of that function. The
%% arguments of that call can overwrite the parameters of the current
%% instantiation of \code{gcd}, so that no new stack space is needed.
%% Hence, tail recursive functions are iterative processes, which can be
%% executed in constant space.
Ainda que as atuais implementa\c{c}\~{o}es de Scala n\~{a}o trabalhem reescrevendo
termos, elas contudo devem ter o mesmo comportamento de espa\c{c}o que nas
sequ\^{e}ncias reescritas. Na implementa\c{c}\~{a}o de \code{gcd}, nota-se que  a 
chamada recursiva para \code{gcd} \'{e} a \'{u}ltima a\c{c}\~{a}o realizada na avalia\c{c}\~{a}o 
do seu corpo. Pode-se tamb\'{e}m dizer que \code{gcd} \'{e} uma recurs\~{a}o de cauda
(tail-recursive). A \'{u}ltima chamada numa fun\c{c}\~{a}o recursiva de cauda pode ser
implementada por um salto ao in\'{i}cio da fun\c{c}\~{a}o. Os argumentos dessa chamada 
pode sobrescrever os par\^{a}metros da atual instancia\c{c}\~{a}o de \code{gcd}, portanto 
nenhum espa\c{c}o na pilha \'{e} necess\'{a}rio. Consequentemente, fun\c{c}\~{o}es recursivas de 
cauda s\~{a}o processos iterativos, que podem ser executados em espa\c{c}o constante.     
%----------

%----------
%% By contrast, the recursive call in \code{factorial} is followed by a
%% multiplication.  Hence, a new stack frame is allocated for the
%% recursive instance of factorial, and is deallocated after that
%% instance has finished. The given formulation of the factorial function
%% is not tail-recursive; it needs space proportional to its input
%% parameter for its execution.
Em contraste, a chamada recursiva em \code{factorial} \'{e} seguida por uma 
multiplica\c{c}\~{a}o. consequentemente, um novo espa\c{c}o na pilha \'{e} alocado para a 
inst\^{a}ncia recursiva de fatorial, e \'{e} desalocada ap\'{o}s o t\'{e}rmino daquela 
inst\^{a}ncia. A formula\c{c}\~{a}o dada para a fun\c{c}\~{a}o fatorial n\~{a}o \'{e} recursiva de cauda;
 precisa de espa\c{c}o proporcional aos seus par\^{a}metros de entrada para sua
execu\c{c}\~{a}o. 
%----------

%----------
%% More generally, if the last action of a function is a call to another
%% (possibly the same) function, only a single stack frame is needed for
%% both functions. Such calls are called ``tail calls''. In principle,
%% tail calls can always re-use the stack frame of the calling function.
%% However, some run-time environments (such as the Java VM) lack the
%% primitives to make stack frame re-use for tail calls efficient.  A
%% production quality Scala implementation is therefore only required to
%% re-use the stack frame of a directly tail-recursive function whose
%% last action is a call to itself.  Other tail calls might be optimized
%% also, but one should not rely on this across implementations.
Genericamente, se a \'{u}ltima a\c{c}\~{a}o da fun\c{c}\~{a}o \'{e} uma chamada a outra fun\c{c}\~{a}o
(possivelmente a mesma), apenas um \'{u}nico espa\c{c}o na pilha \'{e} requerido para 
ambas fun\c{c}\~{o}es. Tais chamadas s\~{a}o denominadas ``tail call''. Em 
princ\'{i}pio, tail calls sempre podem reutilizar o espa\c{c}o da pilha da fun\c{c}\~{a}o 
de chamada. Entretanto, alguns ambientes de execu\c{c}\~{a}o (tais como Java VM) 
carecem das primitivas para fazer um espa\c{c}o de pilha reutiliz\'{a}vel para 
tail calls eficientes. A produ\c{c}\~{a}o de uma implementa\c{c}\~{a}o Scala de qualidade \'{e},
portanto, requerida somente para reutilizar o espa\c{c}o de pilha de uma fun\c{c}\~{a}o 
recursiva de cauda cuja \'{u}ltima a\c{c}\~{a}o \'{e} chamar a si mesma. Outras chamadas de 
cauda podem ser otimizadas tamb\'{e}m, mas n\~{a}o deve-se confiar nisso ao longo das
implementa\c{c}\~{o}es. 
%----------

\begin{exercise} Escreva uma implementa\c{c}\~{a}o recursiva de cauda de 
\code{factorial}.
\end{exercise}


%----------
%% \chapter{\label{chap:first-class-funs}First-Class Functions}

%% A function in Scala is a ``first-class value''. Like any other value,
%% it may be passed as a parameter or returned as a result.  Functions
%% which take other functions as parameters or return them as results are
%% called {\em higher-order} functions. This chapter introduces
%% higher-order functions and shows how they provide a flexible mechanism
%% for program composition.

 \chapter{\label{chap:first-class-funs}Fun\c{c}\~{o}es de Primeira Classe}
Uma fun\c{c}\~{a}o em Scala \'{e} um valor de primeira classe. Como qualquer outro valor, 
pode ser passado como um par\^{a}metro ou retornado como um resultado. Fun\c{c}\~{o}es que 
recebem outras fun\c{c}\~{o}es como par\^{a}metros ou as retornam como resultados s\~{a}o 
denominadas fun\c{c}\~{o}es de {\em alta ordem}. Este cap\'{i}tulo introduz fun\c{c}\~{o}es de alta ordem 
e mostra como elas fornecem um mecanismo flex\'{i}vel para a composi\c{c}\~{a}o de programas.
%----------

%----------
%% As a motivating example, consider the following three related tasks:
Como um exemplo de motiva\c{c}\~{a}o, considere as tr\^{e}s tarefas relacionadas a seguir:
\begin{enumerate}
\item
%%Write a function to sum all integers between two given numbers \code{a} and \code{b}:
Escreva uma fun\c{c}\~{a}o que some todos os inteiros entre dois dados n\'{u}meros, \code{a} e \code{b}:  
\begin{lstlisting}
def sumInts(a: Int, b: Int): Int =
  if (a > b) 0 else a + sumInts(a + 1, b)
\end{lstlisting}
%----------

%----------
 \item 
%% Write a function to sum the squares of all integers between two given numbers 
%% \code{a} and \code{b}:
Escreva uma fun\c{c}\~{a}o para somar os quadrados de todos os inteiros entre dois dados n\'{u}meros, 
 \code{a} e \code{b}:

\begin{lstlisting}
def square(x: Int): Int = x * x
def sumSquares(a: Int, b: Int): Int =
  if (a > b) 0 else square(a) + sumSquares(a + 1, b)
\end{lstlisting}
\item
%% Write a function to sum the powers $2^n$ of all integers $n$ between
%% two given numbers \code{a} and \code{b}:
Escreva uma fun\c{c}\~{a}o para somar as pot\^{e}ncias $2^n$ de todos os $n$ inteiros entre
dois dados n\'{u}meros \code{a} e \code{b}:  

\begin{lstlisting}
def powerOfTwo(x: Int): Int = if (x == 0) 1 else 2 * powerOfTwo(x - 1)
def sumPowersOfTwo(a: Int, b: Int): Int =
  if (a > b) 0 else powerOfTwo(a) + sumPowersOfTwo(a + 1, b)
\end{lstlisting}
\end{enumerate}
%----------

%----------
%% These functions are all instances of
%% \(\sum^b_a f(n)\) for different values of $f$. 
%% We can factor out the common pattern by defining a function \code{sum}:
Estas fun\c{c}\~{o}es s\~{a}o todas inst\^{a}ncias de \(\sum^b_a f(n)\) para diferentes valores de $x$.
Podemos obter o padr\~{a}o comum definindo uma fun\c{c}\~{a}o \code{sum}: 
\begin{lstlisting}
def sum(f: Int => Int, a: Int, b: Int): Int =
  if (a > b) 0 else f(a) + sum(f, a + 1, b)
\end{lstlisting}
%% The type \code{Int => Int} is the type of functions that
%% take arguments of type \code{Int} and return results of type
%% \code{Int}. So \code{sum} is a function which takes another function as
%% a parameter. In other words, \code{sum} is a {\em higher-order}
%% function.
O tipo \code{Int => Int} \'{e} o tipo de fun\c{c}\~{o}es que recebem argumentos do tipo
\code{Int} e retornam resultados do tipo \code{Int}. Ent\~{a}o \code{sum} \'{e} uma 
fun\c{c}\~{a}o que recebe uma outra fun\c{c}\~{a}o como par\^{a}metro. Em outras palavras, \code{sum}
\'{e} uma fun\c{c}\~{a}o de {\em alta ordem}.     
%----------

%----------
%% Using \code{sum}, we can formulate the three summing functions as
%% follows.
Usando \code{sum}, podemos formular as tr\^{e}s fun\c{c}\~{o}es de soma como segue: 
\begin{lstlisting}
def sumInts(a: Int, b: Int): Int = sum(id, a, b)
def sumSquares(a: Int, b: Int): Int = sum(square, a, b)
def sumPowersOfTwo(a: Int, b: Int): Int = sum(powerOfTwo, a, b)
\end{lstlisting}
%%where
onde 
\begin{lstlisting}
def id(x: Int): Int = x
def square(x: Int): Int = x * x
def powerOfTwo(x: Int): Int = if (x == 0) 1 else 2 * powerOfTwo(x - 1)
\end{lstlisting}
%----------

%----------
%% \section{Anonymous Functions}

%% Parameterization by functions tends to create many small functions. In
%% the previous example, we defined \code{id}, \code{square} and
%% \code{power} as separate functions, so that they could be 
%% passed as arguments to \code{sum}.
\section{Fun\c{c}\~{o}es An\^{o}nimas}
Parametriza\c{c}\~{a}o por fun\c{c}\~{o}es tende a criar v\'{a}rias pequenas fun\c{c}\~{o}es. No exemplo 
anterior, definimos \code{id}, \code{square} e \code{power} como fun\c{c}\~{o}es 
separadas, de tal modo que pudessem ser passadas como argumentos para \code{sum}.    
%----------

%----------
%% Instead of using named function definitions for these small argument
%% functions, we can formulate them in a shorter way as {\em anonymous
%% functions}. An anonymous function is an expression that evaluates to a
%% function; the function is defined without giving it a name. As an
%% example consider the anonymous square function:

Ao inv\'{e}s de usarmos defini\c{c}\~{o}es de fun\c{c}\~{o}es nomeadas para estas pequenas fun\c{c}\~{o}es 
argumentos, podemos formul\'{a}-las de um modo abreviado como {\em fun\c{c}\~{o}es an\^{o}nimas}.
Uma fun\c{c}\~{a}o an\^{o}nima \'{e} uma express\~{a}o que \'{e} avaliada para uma fun\c{c}\~{a}o; a fun\c{c}\~{a}o \'{e} 
definida sem receber um nome. Como exemplo considere a fun\c{c}\~{a}o an\^{o}nima quadrado:
\begin{lstlisting}
  (x: Int) => x * x
\end{lstlisting}
%----------
  
%----------
%% The part before the arrow `\code{=>}' are the parameters of the function,
%% whereas the part following the `\code{=>}' is its body. 
%% For instance, here is an anonymous function which multiples its two arguments.
A parte anterior a flecha `\code{=>}' s\~{a}o os par\^{a}metros da fun\c{c}\~{a}o, ao passo que a parte
seguinte a `\code{=>}' \'{e} o seu corpo.
Por exemplo, aqui est\'{a} uma fun\c{c}\~{a}o an\^{o}nima que multiplica seus dois argumentos.
\begin{lstlisting}
  (x: Int, y: Int) => x * y
\end{lstlisting}
%% Using anonymous functions, we can reformulate the first two summation
%% functions without named auxiliary functions:
Usando fun\c{c}\~{o}es an\^{o}nimas, podemos reformular as duas fun\c{c}\~{o}es soma sem
fun\c{c}\~{o}es auxiliares nomeadas:
\begin{lstlisting}
def sumInts(a: Int, b: Int): Int = sum((x: Int) => x, a, b)
def sumSquares(a: Int, b: Int): Int = sum((x: Int) => x * x, a, b)
\end{lstlisting}
%----------

%----------
%% Often, the Scala compiler can deduce the parameter type(s) from the
%% context of the anonymous function in which case they can be omitted.
%% For instance, in the case of \code{sumInts} or \code{sumSquares}, one
%% knows from the type of \code{sum} that the first parameter must be a
%% function of type \code{Int => Int}.  Hence, the parameter type
%% \code{Int} is redundant and may be omitted. If there is a single
%% parameter without a type, we may also omit the parentheses around it:
Frequentemente, o compilador Scala pode deduzir o tipo do par\^{a}metro a partir
do contexto da fun\c{c}\~{a}o an\^{o}nima nos casos em que foram omitidos.
Por exemplo, no caso de \code{sumInts} ou \code{sumSquares}, sabe-se a partir do 
tipo de \code{sum} que o primeiro par\^{a}metro deve ser uma fun\c{c}\~{a}o de tipo \code{Int => Int}.
Consequentemente, o tipo do par\^{a}metro \code{Int} \'{e} redundante e pode ser omitido. Se
houver um \'{u}nico par\^{a}metro sem um tipo, tamb\'{e}m podemos omitir os par\^{a}metros a sua volta. 
   
\begin{lstlisting}
def sumInts(a: Int, b: Int): Int = sum(x => x, a, b)
def sumSquares(a: Int, b: Int): Int = sum(x => x * x, a, b)
\end{lstlisting}
%----------

%----------
%% Generally, the Scala term
%% \code{(x}$_1$\code{: T}$_1$\code{, ..., x}$_n$\code{: T}$_n$\code{) => E} 
%% defines a function which maps its parameters
%% \code{x}$_1$\code{, ..., x}$_n$ to the result of the expression \code{E}
%% (where \code{E} may refer to \code{x}$_1$\code{, ..., x}$_n$).  Anonymous
%% functions are not essential language elements of Scala, as they can
%% always be expressed in terms of named functions. Indeed, the 
%% anonymous function
Em geral, o termo em Scala 
 \code{(x}$_1$\code{: T}$_1$\code{, ..., x}$_n$\code{: T}$_n$\code{) => E} 
define uma fun\c{c}\~{a}o que mapeia seus par\^{a}metros \code{x}$_1$\code{, ..., x}$_n$
ao resultado da express\~{a}o \code{E} (onde \code{E} pode referir-se a   
\code{x}$_1$\code{, ..., x}$_n$). Fun\c{c}\~{o}es an\^{o}nimas n\~{a}o s\~{a}o elementos essenciais
da linguagem Scala, dado que sempre podem ser expressos em termos de fun\c{c}\~{o}es
nomeadas. De fato, a fun\c{c}\~{a}o an\^{o}nima 

\begin{lstlisting}
(x$_1$: T$_1$, ..., x$_n$: T$_n$) => E
\end{lstlisting}
%% is equivalent to the block
\'{e} equivalente ao bloco
\begin{lstlisting}
{ def f (x$_1$: T$_1$, ..., x$_n$: T$_n$) = E ; f _ }
\end{lstlisting}
%% where \code{f} is fresh name which is used nowhere else in the program.
%% We also say, anonymous functions are ``syntactic sugar''.
onde \code{f} \'{e} um novo nome que n\~{a}o \'{e} utilizado em qualquer outro lugar do programa.
Tamb\'{e}m dizemos que fun\c{c}\~{o}es an\^{o}nimas s\~{a}o ``syntactic sugar''. 
%----------

%----------
 \section{Currying}

%% The latest formulation of the summing functions is already quite
%% compact. But we can do even better. Note that
%% \code{a} and \code{b} appear as parameters and arguments of every function
%% but they do not seem to take part in interesting combinations. Is
%% there a way to get rid of them?

%% Let's try to rewrite \code{sum} so that it does not take the bounds
%% \code{a} and \code{b} as parameters:

A \'{u}ltima formula\c{c}\~{a}o das fun\c{c}\~{o}es de soma j\'{a} s\~{a}o bem compactas. Mas 
podemos fazer ainda melhor. Observe que \code{a} e \code{b} aparecem como 
par\^{a}metros e argumentos de cada fun\c{c}\~{a}o, mas n\~{a}o parecem tomar parte de 
combina\c{c}\~{o}es interessantes. H\'{a} algum modo de nos livrarmos delas?

Vamos tentar reescrever \code{sum} de tal modo que n\~{a}o receba os limites
\code{a} e \code{b} como par\^{a}metros:     

\begin{lstlisting}
def sum(f: Int => Int): (Int, Int) => Int = {
  def sumF(a: Int, b: Int): Int =
    if (a > b) 0 else f(a) + sumF(a + 1, b)
  sumF
}
\end{lstlisting}
%----------

%----------
%% In this formulation, \code{sum} is a function which returns another
%% function, namely the specialized summing function \code{sumF}. This
%% latter function does all the work; it takes the bounds \code{a} and
%% \code{b} as parameters, applies \code{sum}'s function parameter \code{f} to all
%% integers between them, and sums up the results. 
Nessa formula\c{c}\~{a}o, \code{sum} \'{e} uma fun\c{c}\~{a}o que retorna uma outra fun\c{c}\~{a}o, especificamente
a fun\c{c}\~{a}o especializada soma \code{sumF}. Esta \'{u}ltima fun\c{c}\~{a}o realiza todo o trabalho; 
recebe os limites \code{a} e \code{b} como par\^{a}metros, aplica a fun\c{c}\~{a}o \code{f}, par\^{a}metro
de \code{sum}, a todos os inteiros entre eles, e soma os resultados.
      
%% Using this new formulation of \code{sum}, we can now define:
Usando esta nova formula\c{c}\~{a}o de \code{sum}, podemos agora definir:
\begin{lstlisting}
def sumInts  =  sum(x => x)
def sumSquares  =  sum(x => x * x)
def sumPowersOfTwo  =  sum(powerOfTwo)
\end{lstlisting}
%% Or, equivalently, with value definitions:
Ou, equivalentemente, com defini\c{c}\~{o}es de valores:
\begin{lstlisting}
val sumInts  =  sum(x => x)
val sumSquares  =  sum(x => x * x)
val sumPowersOfTwo  =  sum(powerOfTwo)
\end{lstlisting}
%----------

%----------
%% \code{sumInts}, \code{sumSquares}, and \code{sumPowersOfTwo} can be
%% applied like any other function. For instance,
 \code{sumInts}, \code{sumSquares}, e \code{sumPowersOfTwo} podem ser
aplicados como qualquer outra fun\c{c}\~{a}o. Por exemplo,
\begin{lstlisting}
scala> sumSquares(1, 10) + sumPowersOfTwo(10, 20)
unnamed0: Int = 2096513
\end{lstlisting}
%% How are function-returning functions applied? As an example, in the expression
Como fun\c{c}\~{o}es que retornam fun\c{c}\~{o}es s\~{a}o aplicadas? Como exemplo, na express\~{a}o 
\begin{lstlisting}
sum(x => x * x)(1, 10) ,
\end{lstlisting}
%% the function \code{sum} is applied to the squaring function 
%% \code{(x => x * x)}. The resulting function is then 
%% applied to the second argument list, \code{(1, 10)}.
a fun\c{c}\~{a}o \code{sum} \'{e} aplicada a fun\c{c}\~{a}o quadrada \code{(x => x * x)}. 
O fun\c{c}\~{a}o resultante \'{e} ent\~{a}o aplicada ao segunda lista de argumentos, \code{(1, 10)}.   
%----------

%----------
%% This notation is possible because function application associates to the left.
%% That is, if $\mbox{args}_1$ and $\mbox{args}_2$ are argument lists, then 
%% \bda{lcl}
%% f(\mbox{args}_1)(\mbox{args}_2) & \ \ \mbox{is equivalent to}\ \ & (f(\mbox{args}_1))(\mbox{args}_2)
%% \eda
%% In our example, \code{sum(x => x * x)(1, 10)} is equivalent to the
%% following expression:
%% \code{(sum(x => x * x))(1, 10)}.
Essa nota\c{c}\~{a}o \'{e} poss\'{i}vel porque aplica\c{c}\~{o}es de fun\c{c}\~{o}es s\~{a}o associativas à esquerda.
Ou seja, se $\mbox{args}_1$ e $\mbox{args}_2$ s\~{a}o listas de argumentos, ent\~{a}o 
\bda{lcl}
f(\mbox{args}_1)(\mbox{args}_2) & \ \ \mbox{\'{e} equivalente a}\ \ & (f(\mbox{args}_1))(\mbox{args}_2)
\eda
Em nosso exemplo, \code{sum(x => x * x)(1, 10)} \'{e} equivalente a seguinte express\~{a}o:
\code{(sum(x => x * x))(1, 10)}.
%----------

%----------
%% The style of function-returning functions is so useful that Scala has
%% special syntax for it. For instance, the next definition of \code{sum}
%% is equivalent to the previous one, but is shorter:
O estilo ``fun\c{c}\~{o}es que retornam fun\c{c}\~{o}es'' \'{e} t\~{a}o \'{u}til que Scala tem sintaxe
especial para ele. Por exemplo, a pr\'{o}xima defini\c{c}\~{a}o de \code{sum} \'{e} equivalente
a anterior, por\'{e}m mais curta: 
\begin{lstlisting}
def sum(f: Int => Int)(a: Int, b: Int): Int =
  if (a > b) 0 else f(a) + sum(f)(a + 1, b)
\end{lstlisting}
%% Generally, a curried function definition 
Genericamente, uma defini\c{c}\~{a}o de fun\c{c}\~{a}o currificada
\begin{lstlisting}
def f (args$_1$) ... (args$_n$) = E
\end{lstlisting}
%%where $n > 1$ expands to
onde $n > 1$ expande para 
\begin{lstlisting}
def f (args$_1$) ... (args$_{n-1}$) = { def g (args$_n$) = E ; g }
\end{lstlisting}
%%where \code{g} is a fresh identifier. Or, shorter, using an anonymous function:
onde \code{g} \'{e} um novo identificador. Ou, menor, usando uma fun\c{c}\~{a}o an\^{o}nima: 
\begin{lstlisting}
def f (args$_1$) ... (args$_{n-1}$) = ( args$_n$ ) => E .
\end{lstlisting}
%%Performing this step $n$ times yields that
Realizando este passo $n$ vezes d\'{a} aquela 
\begin{lstlisting}
def f (args$_1$) ... (args$_n$) = E
\end{lstlisting}
%%is equivalent to
\'{e} equivalente a 
\begin{lstlisting}
def f = (args$_1$) => ... => (args$_n$) => E .
\end{lstlisting}
%%Or, equivalently, using a value definition:
Ou, equivalentemente, usando uma defini\c{c}\~{a}o valor:
\begin{lstlisting}
val f = (args$_1$) => ... => (args$_n$) => E .
\end{lstlisting}
%% This style of function definition and application is called {\em
%% currying} after its promoter, Haskell B.\ Curry, a logician of the
%% 20th century, even though the idea goes back further to Moses
%% Sch\"onfinkel and Gottlob Frege.
Este estilo de defini\c{c}\~{a}o de fun\c{c}\~{a}o e aplica\c{c}\~{a}o \'{e} chamado {\em currificado}
depois que seu divulgador, Haskell B.\ Curry, um l\'{o}gico do s\'{e}culo $20$, mesmo 
que a id\'{e}ia nos leve de volta a Moses Sch\"onfinkel e Gottlob Frege.
%----------

%----------
%% The type of a function-returning function is expressed analogously to
%% its parameter list. Taking the last formulation of \code{sum} as an example,
%% the type of \code{sum} is \code{(Int => Int) => (Int, Int) => Int}.
%% This is possible because function types associate to the right. I.e.
O tipo de uma fun\c{c}\~{a}o que retorna fun\c{c}\~{a}o \'{e} expresso de modo an\'{a}logo a sua lista
de par\^{a}metros. Tomando a \'{u}ltima formula\c{c}\~{a}o de \code{sum} como exemplo, o tipo 
para \code{sum} \'{e} \code{(Int => Int) => (Int, Int) => Int}.
Isso \'{e} poss\'{i}vel porque tipos de fun\c{c}\~{o}es s\~{a}o associativos à direita. Ou seja, 
\begin{lstlisting}
T$_1$ => T$_2$ => T$_3$       $\mbox{is equivalent to}$     T$_1$ => (T$_2$ => T$_3$)
\end{lstlisting}
%----------

%----------
\begin{exercise}
%% 1. The \code{sum} function uses a linear recursion. Can you write a
%% tail-recursive one by filling in the ??'s?
1. A fun\c{c}\~{a}o \code{sum} usa uma recursiva linear. Voc\^{e} poderia alter\'{a}-la
para uma fun\c{c}\~{a}o recursiva de cauda, preenchendo as ?? abaixo?  
\begin{lstlisting}
def sum(f: Int => Int)(a: Int, b: Int): Int = {
  def iter(a: Int, result: Int): Int = {
    if (??) ??
    else iter(??, ??)
  }
  iter(??, ??)
}
\end{lstlisting}
\end{exercise}
%----------

%----------
\begin{exercise}
%% Write a function \code{product} that computes the product of the
%% values of functions at points over a given range.
Escreva uma fun\c{c}\~{a}o \code{produto} que computa o produto de valores de
fun\c{c}\~{o}es em pontos sobre um dado intervalo.  
\end{exercise}

\begin{exercise}
%% Write \code{factorial} in terms of \code{product}.
Escreva \code{fatorial} em termos de \code{produto}.  
\end{exercise}

\begin{exercise}
%% Can you write an even more general function which generalizes both
%% \code{sum} and \code{product}?
Escreva uma fun\c{c}\~{a}o ainda mais gen\'{e}rica que generaliza ambos \code{sum} e \code{produto}.  
\end{exercise}
%----------

%----------
%% \section{Example: Finding Fixed Points of Functions}

%% A number \code{x} is called a {\em fixed point} of a function \code{f} if
\section{Exemplo: Encontrando Pontos Fixos de Fun\c{c}\~{o}es}

Um n\'{u}mero \code{x} \'{e} chamado um {\em ponto fixo} de uma fun\c{c}\~{a}o \code{f} se  
\begin{lstlisting}
f(x) = x .
\end{lstlisting}
%% For some functions \code{f} we can locate the fixed point by beginning
%% with an initial guess and then applying \code{f} repeatedly, until the
%% value does not change anymore (or the change is within a small
%% tolerance). This is possible if the sequence
Para algumas fun\c{c}\~{o}es \code{f} podemos encontrar os pontos fixos iniciando
com um palpite inicial e ent\~{a}o aplicando \code{f} repetidamente, at\'{e} que o valor 
n\~{a}o mude mais (ou a mudan\c{c}a seja toler\'{a}vel). Isso \'{e} poss\'{i}vel na sequ\^{e}ncia  
\begin{lstlisting}
x, f(x), f(f(x)), f(f(f(x))), ...
\end{lstlisting}
%%converges to fixed point of $f$. This idea is captured in
%%the following ``fixed-point finding function'':
converge para pontos fixos de $f$. Essa id\'{e}ia \'{e} captada na ``fun\c{c}\~{a}o achadora 
de pontos fixos'' a seguir:
\begin{lstlisting}
val tolerance = 0.0001
def isCloseEnough(x: Double, y: Double) = abs((x - y) / x) < tolerance
def fixedPoint(f: Double => Double)(firstGuess: Double) = {
  def iterate(guess: Double): Double = {
    val next = f(guess)
    if (isCloseEnough(guess, next)) next
    else iterate(next)
  }
  iterate(firstGuess)
}
\end{lstlisting}
%----------

%----------
%% We now apply this idea in a reformulation of the square root function.
%% Let's start with a specification of \code{sqrt}:
Agora aplicaremos esta id\'{e}ia na reformula\c{c}\~{a}o da fun\c{c}\~{a}o raiz quadrada.
Vamos come\c{c}ar pela especifica\c{c}\~{a}o de \code{sqrt}:  
\begin{lstlisting}
sqrt(x)  =  $\mbox{the {\sl y} such that}$  y * y = x
         =  $\mbox{the {\sl y} such that}$  y = x / y
\end{lstlisting}

%% Hence, \code{sqrt(x)} is a fixed point of the function \code{y => x / y}.
%% This suggests that \code{sqrt(x)} can be computed by fixed point iteration:
Consequentemente, \code{sqrt(x)} \'{e} um ponto fixo da fun\c{c}\~{a}o \code{y => x / y}.
Isso sugere que \code{sqrt(x)} pode ser computado por uma itera\c{c}\~{a}o de ponto fixo: 
\begin{lstlisting}
def sqrt(x: double) = fixedPoint(y => x / y)(1.0)
\end{lstlisting}
%% But if we try this, we find that the computation does not
%% converge. Let's instrument the fixed point function with a print
%% statement which keeps track of the current \code{guess} value:
Mas se tentarmos isso, percebemos que aquela computa\c{c}\~{a}o n\~{a}o converge. 
Vamos agregar à fun\c{c}\~{a}o de ponto fixo um comando print que mostra o 
valor corrente de \code{guess}: 
\begin{lstlisting}
def fixedPoint(f: Double => Double)(firstGuess: Double) = {
  def iterate(guess: Double): Double = {
    val next = f(guess)
    println(next)
    if (isCloseEnough(guess, next)) next
    else iterate(next)
  }
  iterate(firstGuess)
}
\end{lstlisting}
%% Then, \code{sqrt(2)} yields:
Ent\~{a}o, \code{sqrt(2)} d\'{a}: 
\begin{lstlisting}
  2.0
  1.0
  2.0
  1.0
  2.0
  ...
\end{lstlisting}
%----------

%----------
%% One way to control such oscillations is to prevent the guess from changing too much. 
%% This can be achieved by {\em averaging} successive values of the original sequence:
Um modo de controlar tais oscila\c{c}\~{o}es \'{e} prevenir guess de mudar muito.
Isso pode ser obtido pela m\'{e}dia (fun\c{c}\~{a}o {\em averaging}) de sucessivos valores da sequ\^{e}ncia 
original:
\begin{lstlisting}
scala> def sqrt(x: Double) = fixedPoint(y => (y + x/y) / 2)(1.0)
sqrt: (Double)Double

scala> sqrt(2.0)
  1.5
  1.4166666666666665
  1.4142156862745097
  1.4142135623746899
  1.4142135623746899
\end{lstlisting}
%% In fact, expanding the \code{fixedPoint} function yields exactly our 
%% previous definition of fixed point from Section~\ref{sec:sqrt}.
De fato, expandindo a fun\c{c}\~{a}o \code{fixedPoint} d\'{a} exatamente nossa pr\'{e}via
defini\c{c}\~{a}o de ponto fixo da Se\c{c}\~{a}o~\ref{sec:sqrt}.
%% The previous examples showed that the expressive power of a language
%% is considerably enhanced if functions can be passed as arguments.  The
%% next example shows that functions which return functions can also be
%% very useful.
Os exemplos anteriores mostraram que o poder de expressividade de uma linguagem 
\'{e} consideravelmente aumentado se fun\c{c}\~{o}es puderem ser passadas como argumentos.
O pr\'{o}ximo exemplo mostra que fun\c{c}\~{o}es que retornam fun\c{c}\~{o}es tamb\'{e}m podem ser
muito \'{u}teis.
%----------

%----------
%% Consider again fixed point iterations. We started with the observation
%% that $\sqrt(x)$ is a fixed point of the function \code{y => x / y}.
%% Then we made the iteration converge by averaging successive values.
%% This technique of {\em average damping} is so general that it
%% can be wrapped in another function.
Considere novamente itera\c{c}\~{o}es de ponto fixo. Come\c{c}amos observando que 
$\sqrt(x)$ \'{e} um ponto fixo da fun\c{c}\~{a}o \code{y => x / y}. Ent\~{a}o fazemos
a itera\c{c}\~{a}o convergir tirando a m\'{e}dia de sucessivos valores. Essa t\'{e}cnica
de {\em amortecimento da m\'{e}dia} \'{e} t\~{a}o gen\'{e}rica que pode ser denotada
em outra fun\c{c}\~{a}o.
\begin{lstlisting}
def averageDamp(f: Double => Double)(x: Double) = (x + f(x)) / 2
\end{lstlisting}
%% Using \code{averageDamp}, we can reformulate the square root function
%% as follows.
Usando \code{averageDamp}, podemos reformular a fun\c{c}\~{a}o da raiz quadrada
como segue. 
\begin{lstlisting}
def sqrt(x: Double) = fixedPoint(averageDamp(y => x/y))(1.0)
\end{lstlisting}

Isto expressa os elementos do algoritmo t\~{a}o claramente quanto poss\'{i}vel.
\begin{exercise} 
Escreva uma fun\c{c}\~{a}o para a raiz c\'{u}bica usando \code{fixedPoint} e \code{averageDamp}.  
\end{exercise}

\section{Summary}

Vimos no cap\'{i}tulo anterior que fun\c{c}\~{o}es s\~{a}o abstra\c{c}\~{o}es essenciais porque 
nos permitem introduzir m\'{e}todos gen\'{e}ricos de computa\c{c}\~{a}o como expl\'{i}citos,
elementos nomeados em nossa linguagem de programa\c{c}\~{a}o. O presente cap\'{i}tulo
mostrou que tais abstra\c{c}\~{o}es podem ser combinados por fun\c{c}\~{o}es de alta ordem
para criar mais abstra\c{c}\~{o}es. Como programadores, devemos procurar por oportunidades 
de reuso e abstra\c{c}\~{a}o. O mais alto n\'{i}vel poss\'{i}vel de abstra\c{c}\~{a}o nem sempre \'{e} 
o melhor, mas \'{e} importante saber t\'{e}cnicas de abstra\c{c}\~{a}o, de modo que possamos
us\'{a}-las quando apropriado. 

\section{Elementos da Linguagem Vistos At\'{e} Aqui}

 Os cap\'{i}tulos ~\ref{chap:simple-funs} e \ref{chap:first-class-funs} trataram
elementos da linguagem Scala para expressar tipos e express\~{o}es relacionados a
tipos primitivos e fun\c{c}\~{o}es. A sintaxe livre de contexto desses elementos da
linguagem s\~{a}o dados abaixo em formato Backus-Naur estendido, onde `\code{|}'
denotam alternativas, \code{[...]} denotam op\c{c}\~{a}o  (0 ou 1 ocorr\^{e}ncia), e  
\lstinline@{...}@ denotam (0 ou mais ocorr\^{e}ncias). 
\subsection*{Caracteres}
Programas em Scala s\~{a}o sequ\^{e}ncia de caracteres (Unicode). Distinguimos os
seguintes conjuntos de caracteres.
 \begin{itemize}
 \item
espa\c{c}o em branco, tal como `\code{ }', tabula\c{c}\~{a}o, ou caracter de mudan\c{c}a de linha (newline), 
 \item
letras `\code{a}' a `\code{z}', `\code{A}' a `\code{Z}',    
 \item
digitos `\code{0}' a `\code{9}',   
 \item
caracteres delimitadores
 \begin{lstlisting}
 .    ,    ;    (    )    {    }    [    ]    \    $\mbox{\tt "}$    '
 \end{lstlisting}
 \item
caracteres operadores, tal como `\code{#}', `\code{+}' e `\code{:}'.
Essencialmente, h\'{a} caracteres imprim\'{i}veis que n\~{a}o est\~{a}o em nenhum dos 
conjuntos de caracteres acima.   
 \end{itemize}

\subsection*{Lexemas:}

\begin{lstlisting}
ident    =  letter {letter | digit}
         |  operator { operator }
         |  ident '_' ident
literal  =  $\mbox{``como em Java''}$
\end{lstlisting}

%% Literals are as in Java. They define numbers, characters, strings, or
%% boolean values.  Examples of literals as \code{0}, \code{1.0e10}, \code{'x'},
%% \code{"he said \"hi!\""}, or \code{true}.
Literais s\~{a}o como em Java. Eles definem n\'{u}meros, caracteres, cadeias de caracteres, ou 
valores boleanos. Exemplos de literais tais como \code{0}, \code{1.0e10}, \code{'x'},
\code{"ele disse \"oi!\""}, ou \code{true}.
%% Identifiers can be of two forms. They either start with a letter,
%% which is followed by a (possibly empty) sequence of letters or
%% symbols, or they start with an operator character, which is followed
%% by a (possibly empty) sequence of operator characters.  Both forms of
%% identifiers may contain underscore characters `\code{_}'. Furthermore,
%% an underscore character may be followed by either sort of
%% identifier. Hence, the following are all legal identifiers:
Identificadores podem ter duas formas. Eles ou iniciam por uma letra, que \'{e} 
seguida por uma sequ\^{e}ncia (possivelmente vazia) de letras ou s\'{i}mbolos, ou podem 
iniciar com um caracter operador, seguido por uma sequ\^{e}ncia (possivelmente vazia) de
caracteres operadores. Ambas as formas podem conter caracteres ``underscore'' `\code{_}'.
Al\'{e}m disso, um caracter underscore pode ser seguido por quaisquer identificadores.
Consequentemente, todos a seguir s\~{a}o identificadores legais:  
 \begin{lstlisting}
 x     Room10a     +     --     foldl_:     +_vector
 \end{lstlisting}
%% It follows from this rule that subsequent operator-identifiers need to
%% be separated by whitespace. For instance, the input
%% \code{x+-y} is parsed as the three token sequence \code{x}, \code{+-},
%% \code{y}. If we want to express the sum of \code{x} with the
%% negated value of \code{y}, we need to add at least one space,
%% e.g. \code{x+ -y}.
Segue desta regra que identificadores operadores subsequentes precisam ser
separados por espa\c{c}o em branco. Por exemplo, a entrada \code{x+-y} \'{e} entendida 
como a sequ\^{e}ncia de tr\^{e}s ``tokens'' \code{x}, \code{+-} e \code{y}. Se
desejamos expressar a soma de \code{x} com o valor negativo de \code{y}, 
precisamos acrescentar no m\'{i}nimo um espa\c{c}o, ou seja, \code{x+ -y}.      
%----------

%----------
%% The \verb@$@ character is reserved for compiler-generated
%% identifiers; it should not be used in source programs. %$
O caracter \verb@$@ \'{e} reservado para identificadores gerados
pelo compilador; n\~{a}o devem ser usados em programas fontes. %$ 

%% The following are reserved words, they may not be used as identifiers:
Os seguintes s\~{a}o palavras reservadas, e n\~{a}o devem ser usadas como identificadores:
\begin{lstlisting}
abstract    case        catch       class       def    
do          else        extends     false       final    
finally     for         if          implicit    import      
match       new         null        object      override    
package     private     protected   requires    return      
sealed      super       this        throw       trait
try         true        type        val         var         
while       with        yield
_    :    =    =>    <-    <:    <%     >:    #    @
\end{lstlisting}
%----------

%----------
%% \subsection*{Types:}
\subsection*{Types:}

\begin{lstlisting}
Type          =  SimpleType | FunctionType
FunctionType  =  SimpleType '=>' Type | '(' [Types] ')' '=>' Type
SimpleType    =  Byte | Short | Char | Int | Long | Float | Double |
                 Boolean | Unit | String
Types         =  Type {`,' Type}
\end{lstlisting}

%% Types can be:
Tipos podem ser:
 \begin{itemize}
 \item tipos num\'{e}ricos \code{Byte}, \code{Short}, \code{Char}, \code{Int}, \code{Long}, \code{Float} and \code{Double} (com em Java),
 \item o tipo \code{Boolean} com valores  \code{true} e \code{false},
 \item o tipo \code{Unit} com o \'{u}nico valor  \lstinline@()@,
 \item o tipo \code{String},
 \item tipos fun\c{c}\~{a}o, tal como  \code{(Int, Int) => Int} ou \code{String => Int => String}.
 \end{itemize}
%----------

%----------
%% \subsection*{Expressions:}
 \subsection*{Express\~{o}es:}
\begin{lstlisting}
Expr         = InfixExpr | FunctionExpr | if '(' Expr ')' Expr else Expr
InfixExpr    = PrefixExpr | InfixExpr Operator InfixExpr
Operator     = ident
PrefixExpr   = ['+' | '-' | '!' | '~' ] SimpleExpr
SimpleExpr   = ident | literal | SimpleExpr '.' ident | Block
FunctionExpr = (Bindings | Id) '=>' Expr
Bindings     = `(' Binding {`,' Binding} `)'
Binding      = ident [':' Type]
Block        = '{' {Def ';'} Expr '}'
\end{lstlisting}

%% Expressions can be:
Express\~{o}es podem ser:
 \begin{itemize}
 \item
%% identifiers such as \code{x}, \code{isGoodEnough}, \code{*}, or \code{+-},
identificadores tais como \code{x}, \code{isGoodEnough}, \code{*}, ou \code{+-},
 \item
%% literals, such as \code{0}, \code{1.0}, or \code{"abc"},
literais, tais como \code{0}, \code{1.0}, ou \code{"abc"},
 \item
%% field and method selections, such as \code{System.out.println},
Sele\c{c}\~{o}es de campo e m\'{e}todo, tal como \code{System.out.println},
 \item
%% function applications, such as \code{sqrt(x)},
aplica\c{c}\~{o}es de fun\c{c}\~{a}o, tal como \code{sqrt(x)},
 \item
%% operator applications, such as \code{-x} or \code{y + x},
aplica\c{c}\~{o}es de operador, tais como \code{-x} ou \code{y + x},
 \item
%% conditionals, such as \code{if (x < 0) -x else x},
condicionais, tal como \code{if (x < 0) -x else x},
 \item
%% blocks, such as \lstinline@{ val x = abs(y) ; x * 2 }@,
blocos, tal como \lstinline@{ val x = abs(y) ; x * 2 }@,
 \item
%% anonymous functions, such as \code{x => x + 1} or \code{(x: Int, y: Int) => x + y}.
fun\c{c}\~{o}es an\^{o}nimas, tais como \code{x => x + 1} ou \code{(x: Int, y: Int) => x + y}.
 \end{itemize}
%----------

%----------
%% \subsection*{Definitions}:
\subsection*{Defini\c{c}\~{o}es:}
\begin{lstlisting}
Def          =  FunDef  |  ValDef
FunDef       =  'def' ident {'(' [Parameters] ')'} [':' Type] '=' Expr
ValDef       =  'val' ident [':' Type] '=' Expr
Parameters   =  Parameter {',' Parameter}
Parameter    =  ident ':' ['=>'] Type
\end{lstlisting}
%%Definitions can be:
Defini\c{c}\~{o}es podem ser:
\begin{itemize}
\item
%%function definitions such as \code{def square(x: Int): Int = x * x},
defini\c{c}\~{o}es de fun\c{c}\~{a}o tal como \code{def square(x: Int): Int = x * x},
\item
%%value definitions such as \code{val y = square(2)}.
defini\c{c}\~{o}es de valor tal como \code{val y = square(2)}.
\end{itemize}
%----------

%----------
\chapter{Classes e Objetos}
\label{chap:classes}

%% Scala does not have a built-in type of rational numbers, but it is
%% easy to define one, using a class. Here's a possible implementation.
Scala n\~{a}o tem um tipo primitivo para n\'{u}meros racionais, mas \'{e} f\'{a}cil 
definir um, usando uma classe. Aqui est\'{a} uma poss\'{i}vel implementa\c{c}\~{a}o.

\begin{lstlisting}
class Rational(n: Int, d: Int) {
  private def gcd(x: Int, y: Int): Int = {
    if (x == 0) y
    else if (x < 0) gcd(-x, y)
    else if (y < 0) -gcd(x, -y)
    else gcd(y % x, x)
  }
  private val g = gcd(n, d)

  val numer: Int = n/g
  val denom: Int = d/g
  def +(that: Rational) =
    new Rational(numer * that.denom + that.numer * denom,
                 denom * that.denom)
  def -(that: Rational) =
    new Rational(numer * that.denom - that.numer * denom, 
                 denom * that.denom)
  def *(that: Rational) =
    new Rational(numer * that.numer, denom * that.denom)
  def /(that: Rational) =
    new Rational(numer * that.denom, denom * that.numer)
}
\end{lstlisting}
%% This defines \code{Rational} as a class which takes two constructor
%% arguments \code{n} and \code{d}, containing the number's numerator and
%% denominator parts.  The class provides fields which return these parts
%% as well as methods for arithmetic over rational numbers.  Each
%% arithmetic method takes as parameter the right operand of the
%% operation. The left operand of the operation is always the rational
%% number of which the method is a member.

Isso define \code{Rational} como uma classe que recebe dois argumentos 
construtores \code{n} e \code{d}, contendo as partes num\'{e}ricas do numerador
e denominador. A classe prov\^{e} campos que retornam estas partes, bem como
m\'{e}todos para a aritm\'{e}tica sobre n\'{u}meros racionais. Cada m\'{e}todo aritm\'{e}tico 
recebe como par\^{a}metro o operando direito da opera\c{c}\~{a}o. O operando esquerdo
da opera\c{c}\~{a}o sempre \'{e} o n\'{u}mero racional do m\'{e}todo cujo \'{e} membro.   
%----------

%----------
%% \paragraph{Private members}
%% The implementation of rational numbers defines a private method
%% \code{gcd} which computes the greatest common denominator of two
%% integers, as well as a private field \code{g} which contains the
%% \code{gcd} of the constructor arguments. These members are inaccessible
%% outside class \code{Rational}. They are used in the implementation of
%% the class to eliminate common factors in the constructor arguments in
%% order to ensure that numerator and denominator are always in
%% normalized form.
\paragraph{Membros Privados}
A implementa\c{c}\~{a}o dos n\'{u}meros racionais define um m\'{e}todo privado \code{gcd} que 
computa o maior denominador comum de dois inteiros, bem como um campo
privado \code{g} que cont\'{e}m o \code{gcd} dos argumentos construtores. Esses
membros s\~{a}o inacess\'{i}veis de fora da classe \code{Rational}. S\~{a}o usados na 
implementa\c{c}\~{a}o da classe para eliminar fatores comuns nos argumentos construtores
para garantir que o numerador e o denominador estejam sempre em forma normalizada.    
%----------

%----------
%% \paragraph{Creating and Accessing Objects}
%% As an example of how rational numbers can be used, here's a program
%% that prints the sum of all numbers $1/i$ where $i$ ranges from 1 to 10.
\paragraph{Criando e Acessando Objetos}
Como um exemplo de como os n\'{u}meros racionais podem ser usados, aqui est\'{a} um programa 
que imprime a soma de todos os n\'{u}meros $1/i$ onde $i$ est\'{a} no intervalo de 1 a 10. 
\begin{lstlisting}
var i = 1
var x = new Rational(0, 1)
while (i <= 10) {
  x += new Rational(1, i)
  i += 1
}
println("" + x.numer + "/" + x.denom)
\end{lstlisting}
%% The \code{+} takes as left operand a string and as right operand a
%% value of arbitrary type. It returns the result of converting its right
%% operand to a string and appending it to its left operand. 
O \code{+} recebe como operando esquerdo uma cadeia de caracteres e como 
operando direito um valor de tipo arbitr\'{a}rio. Retorna o resultado de 
converter seu operando direito em uma cadeia de caracteres e concaten\'{a}-la 
a seu operando esquerdo.   
%----------

%----------
%% \paragraph{Inheritance and Overriding}
%% Every class in Scala has a superclass which it extends.  
%% \comment{Excepted is
%% only the root class \code{Object}, which does not have a superclass,
%% and which is indirectly extended by every other class.  }
%% If a class
%% does not mention a superclass in its definition, the root type
%% \code{scala.AnyRef} is implicitly assumed (for Java implementations,
%% this type is an alias for \code{java.lang.Object}. For instance, class
%% \code{Rational} could equivalently be defined as
\paragraph{Heran\c{c}a e Sobrecarga}
Cada classe em Scala tem uma superclasse que ela estende.
\comment{A exce\c{c}\~{a}o \'{e} a classe \code{Object}, que n\~{a}o possui superclasse, e
que \'{e} indiretamente estendida para cada outra classe.}
Se uma classe n\~{a}o menciona sua superclasse em sua defini\c{c}\~{a}o, o tipo b\'{a}sico 
\code{scala.AnyRef} \'{e} implicitamente assumido (para implementa\c{c}\~{o}es Java, este
tipo \'{e} um apelido (alias) para \code{java.lang.Object}. Por exemplo, a classe 
\code{Rational} pode ser equivalentemente definida como      
\begin{lstlisting}
class Rational(n: Int, d: Int) extends AnyRef {
  ... // como antes
}
\end{lstlisting}
%----------

%----------
%% A class inherits all members from its superclass. It may also redefine
%% (or: {\em override}) some inherited members. For instance, class
%% \code{java.lang.Object} defines
%% a method
%% \code{toString} which returns a representation of the object as a string:
Uma classe herda todos os membros de sua superclasse. Pode tamb\'{e}m redefinir
(ou: {\em sobrescrever}) alguns membros herdados. Por exemplo, a classe 
\code{java.lang.Object} define um m\'{e}todo \code{toString} que retorna uma 
representa\c{c}\~{a}o do objeto como cadeia de caracteres (string): 
\begin{lstlisting}
class Object {
  ...
  def toString: String = ...
}
\end{lstlisting}
%----------

%----------
%% The implementation of \code{toString} in \code{Object}
%% forms a string consisting of the object's class name and a number. It
%% makes sense to redefine this method for objects that are rational
%% numbers:
A implementa\c{c}\~{a}o de \code{toString} em \code{Object} forma uma string que 
consiste do nome da classe do objeto e um n\'{u}mero. Faz sentido redefinir este
m\'{e}todo para objetos que s\~{a}o n\'{u}meros racionais:  
\begin{lstlisting}
class Rational(n: Int, d: Int) extends AnyRef {
  ... // como antes
  override def toString = "" + numer + "/" + denom
}
\end{lstlisting}
%% Note that, unlike in Java, redefining definitions need to be preceded
%% by an \code{override} modifier.
Observe que, diferentemente de Java, defini\c{c}\~{o}es que redefinem precisam
ser precedidas por um modificador \code{override}.  
%----------

%----------
%% If class $A$ extends class $B$, then objects of type $A$ may be used
%% wherever objects of type $B$ are expected. We say in this case that
%% type $A$ {\em conforms} to type $B$.  For instance, \code{Rational}
%% conforms to \code{AnyRef}, so it is legal to assign a \code{Rational}
%% value to a variable of type \code{AnyRef}:
Se a classe $A$ estende a classe $B$, ent\~{a}o objetos do tipo $A$ podem ser
usados sempre que objetos do tipo $B$ s\~{a}o esperados. Nesse caso dizemos que o 
tipo $A$ est\'{a} em {\em conformidade} com o tipo $B$. Por exemplo, \code{Rational}
est\'{a} em conformidade com \code{AnyRef}, logo \'{e} legal atribuir um valor \code{Rational}
à vari\'{a}vel do tipo \code{AnyRef}:
 
 \begin{lstlisting}
 var x: AnyRef = new Rational(1, 2)
 \end{lstlisting}
%----------

%----------
%% \paragraph{Parameterless Methods}
%% %Also unlike in Java, methods in Scala do not necessarily take a
%% %parameter list. An example is \code{toString}; the method is invoked
%% %by simply mentioning its name. For instance:
\paragraph{M\'{e}todos sem Par\^{a}metros}

\begin{lstlisting}
val r = new Rational(1,2)
System.out.println(r.toString);      // prints``1/2''
\end{lstlisting}
%% Unlike in Java, methods in Scala do not necessarily take a
%% parameter list. An example is the \code{square} method below. This
%% method is invoked by simply mentioning its name. 
Distintamente de Java, m\'{e}todos em Scala n\~{a}o necessariamente precisam 
receber uma lista de par\^{a}metros. Um exemplo \'{e} o m\'{e}todo abaixo \code{square}.
Este m\'{e}todo \'{e} invocado simplesmente mencionando seu nome. 
\begin{lstlisting}
class Rational(n: Int, d: Int) extends AnyRef {
  ... // como antes
  def square = new Rational(numer*numer, denom*denom)
}
val r = new Rational(3, 4)
println(r.square)           // prints``9/16''*
\end{lstlisting}
%----------

%----------
%% That is, parameterless methods are accessed just as value fields such
%% as \code{numer} are. The difference between values and parameterless
%% methods lies in their definition. The right-hand side of a value is
%% evaluated when the object is created, and the value does not change
%% afterwards. A right-hand side of a parameterless method, on the other
%% hand, is evaluated each time the method is called.  The uniform access
%% of fields and parameterless methods gives increased flexibility for
%% the implementer of a class. Often, a field in one version of a class
%% becomes a computed value in the next version. Uniform access ensures
%% that clients do not have to be rewritten because of that change.
Ou seja, m\'{e}todos sem par\^{a}metros s\~{a}o acessados como campos valor, tais como 
\code{numer} s\~{a}o. A diferen\c{c}a entre valores e m\'{e}todos sem par\^{a}metros 
reside em suas defini\c{c}\~{o}es. O lado direito de um valor \'{e} avaliado quando o 
objeto \'{e} criado, e o valor n\~{a}o muda depois. Um lado direito de um m\'{e}todo sem
par\^{a}metros, por outro lado, \'{e} avaliado cada vez que o m\'{e}todo \'{e} chamado. O 
acesso uniforme dos campos de m\'{e}todos sem par\^{a}metros resulta em crescente
flexibilidade para o implementador de uma classe. Frequentemente, um campo
em uma vers\~{a}o da classe torna-se um valor computado na pr\'{o}xima vers\~{a}o. 
O acesso uniforme garante que clientes n\~{a}o tenham de ser reescritos 
por conta desta mudan\c{c}a.
%----------

%----------
%% \paragraph{Abstract Classes}
\paragraph{Classes Abstratas}

%% Consider the task of writing a class for sets of integer numbers with
%% two operations, \code{incl} and \code{contains}. \code{(s incl x)}
%% should return a new set which contains the element \code{x} together
%% with all the elements of set \code{s}. \code{(s contains x)} should
%% return true if the set \code{s} contains the element \code{x}, and
%% should return \code{false} otherwise. The interface of such sets is
%% given by:
Considere a tarefa de escrever uma classe para conjuntos de n\'{u}meros inteiros com 
duas opera\c{c}\~{o}es, \code{incl} e \code{contains}. \code{(s incl x)} deve retornar
um novo conjunto que cont\'{e}m o elemento \code{x} juntamente com todos os elementos 
do conjunto \code{s}. \code{(s contains x)} deve retornar \code{true} se o conjunto 
\code{s} contiver o elemento \code{x}, e deve retornar \code{false}, caso contr\'{a}rio.
A interface para tais conjuntos \'{e} dada por:
\begin{lstlisting}
abstract class IntSet {
  def incl(x: Int): IntSet
  def contains(x: Int): Boolean
}
\end{lstlisting}
%----------

%----------
%% \code{IntSet} is labeled as an \emph{abstract class}. This has two
%% consequences.  First, abstract classes may have {\em deferred} members
%% which are declared but which do not have an implementation. In our
%% case, both \code{incl} and \code{contains} are such members. Second,
%% because an abstract class might have unimplemented members, no objects
%% of that class may be created using \code{new}. By contrast, an
%% abstract class may be used as a base class of some other class, which
%% implements the deferred members.
\code{IntSet} \'{e} tido como uma {\em classe abstrata}. Isso tem duas consequ\^{e}ncias. 
Primeiro, classes abstratas podem ter membros {\em protelados (deferred)} que s\~{a}o 
declarados, mas que n\~{a}o tem uma implementa\c{c}\~{a}o. No nosso caso, ambos \code{incl} e 
\code{contains} s\~{a}o tais membros. Segundo, porque uma classe abstrata pode ter 
membros n\~{a}o implementados, nenhum objeto daquela classe pode ser criado usando \code{new}.
Em contraste, uma classe abstrata pode ser usada como uma classe base de alguma outra
classe, que implementa os membros que foram postergados. 
%----------

%----------
 \paragraph{Traits}

%% Instead of \code{abstract class} one also often uses the keyword
%% \code{trait} in Scala. Traits are abstract classes that are meant to
%% be added to some other class. This might be because a trait adds some
%% methods or fields to an unknown parent class.  For instance, a trait
%% \code{Bordered} might be used to add a border to a various graphical
%% components. Another usage scenario is where the trait collects
%% signatures of some functionality provided by different classes, much
%% in the way a Java interface would work.
Ao inv\'{e}s de \code{classe abstrata} frequentemente usa-se a palavra chave
\code{trait} em Scala. Traits s\~{a}o classes abstratas que desejamos adicionar
a alguma outra classe. Isso pode ser porque um trait adiciona alguns m\'{e}todos
ou campos para uma classe pai desconhecida. Por exemplo, um trait \code{Bordered} 
pode ser usado para adicionar uma borda a v\'{a}rios componentes gr\'{a}ficos. Um outro
cen\'{a}rio de uso ocorre quando o trait coleta assinaturas de alguma funcionalidade 
provida por diferentes classes, do mesmo modo que uma interface Java faria.

%% Since \code{IntSet} falls in this category, one can alternatively
%% define it as a trait:
Como \code{IntSet} pertence a esta categoria, pode-se alternativamente 
defin\'{i}-la como um trait:
\begin{lstlisting}
trait IntSet {
  def incl(x: Int): IntSet
  def contains(x: Int): Boolean
}
\end{lstlisting}
%----------

%----------
%% \paragraph{Implementing Abstract Classes}
\paragraph{Implementando Classes Abstratas}
%% Let's say, we plan to implement sets as binary trees.  There are two
%% possible forms of trees. A tree for the empty set, and a tree
%% consisting of an integer and two subtrees. Here are their
%% implementations.

Vamos dizer que planejamos implementar conjuntos como \'{a}rvores bin\'{a}rias. H\'{a} 
duas poss\'{i}veis formas de \'{a}rvores. Uma \'{a}rvore para o conjunto vazio, e uma 
\'{a}rvore consistindo de um inteiro e duas sub\'{a}rvores. Aqui est\~{a}o suas implementa\c{c}\~{o}es:
 
\begin{lstlisting}
class EmptySet extends IntSet {
  def contains(x: Int): Boolean = false
  def incl(x: Int): IntSet = new NonEmptySet(x, new EmptySet, new EmptySet)
}
\end{lstlisting}

\begin{lstlisting}
class NonEmptySet(elem: Int, left: IntSet, right: IntSet) extends IntSet {
  def contains(x: Int): Boolean =
    if (x < elem) left contains x
    else if (x > elem) right contains x
    else true
  def incl(x: Int): IntSet =
    if (x < elem) new NonEmptySet(elem, left incl x, right)
    else if (x > elem) new NonEmptySet(elem, left, right incl x)
    else this
}
\end{lstlisting}
%% Both \code{EmptySet} and \code{NonEmptySet} extend class
%% \code{IntSet}.  This implies that types \code{EmptySet} and
%% \code{NonEmptySet} conform to type \code{IntSet} -- a value of type \code{EmptySet} or \code{NonEmptySet} may be used wherever a value of type \code{IntSet} is required.
Ambos \code{EmptySet} e \code{NonEmptySet} estendem a classe \code{IntSet}. Isso implica
que tipos \code{EmptySet} e \code{NonEmptySet} est\~{a}o em conformidade com o tipo \code{IntSet} -- 
um valor do tipo \code{EmptySet} ou \code{NonEmptySet} pode ser usado sempre que um valor 
 do tipo \code{IntSet} \'{e} requerido.
%----------

%----------
%% \begin{exercise} Write methods \code{union} and \code{intersection} to form
%% the union and intersection between two sets.
%% \end{exercise}
\begin{exercise}
Escreva os m\'{e}todos \code{uniao} e \code{intersecao} para formar a uni\~{a}o e interse\c{c}\~{a}o entre
dois conjuntos.
\end{exercise}
 \begin{exercise} Adicione um m\'{e}todo  
 \begin{lstlisting}
 def excl(x: Int)
 \end{lstlisting}
%% to return the given set without the element \code{x}. To accomplish this,
%% it is useful to also implement a test method
para retornar um dado conjunto sem o elemento \code{x}. Para isso, \'{e} interessante tamb\'{e}m 
implementar um m\'{e}todo teste
 \begin{lstlisting}
 def isEmpty: Boolean
 \end{lstlisting}
%% for sets.
para conjuntos.
 \end{exercise}
%----------

%----------
%% \paragraph{Dynamic Binding}
\paragraph{Liga\c{c}\~{a}o Din\^{a}mica}
%% Object-oriented languages (Scala included) use \emph{dynamic dispatch}
%% for method invocations.  That is, the code invoked for a method call
%% depends on the run-time type of the object which contains the method.
%% For example, consider the expression \code{s contains 7} where
%% \code{s} is a value of declared type \code{s: IntSet}. Which code for
%% \code{contains} is executed depends on the type of value of \code{s} at run-time.
%% If it is an \code{EmptySet} value, it is the implementation of \code{contains} in class \code{EmptySet} that is executed, and analogously for \code{NonEmptySet} values. 
%% This behavior is a direct consequence of our substitution model of evaluation.
Linguagens orientadas a objetos (inclusive Scala) usam \emph{despacho din\^{a}mico} para 
invoca\c{c}\~{o}es de m\'{e}todos. Ou seja, o c\'{o}digo invocado por uma chamada de m\'{e}todo depende
do tipo em tempo de execu\c{c}\~{a}o do objeto que cont\'{e}m o m\'{e}todo. Por exemplo, considere
a express\~{a}o \code{s contains 7} onde \code{s} \'{e} um valor do tipo declarado \code{s: IntSet}. 
Qual c\'{o}digo para \code{contains} \'{e} executado depende do tipo do valor de \code{s} em 
tempo de execu\c{c}\~{a}o. Se for um valor \code{EmptySet}, \'{e} a implementa\c{c}\~{a}o de \code{contains} na 
classe \code{EmptySet} que \'{e} executada, e analogamente para valores \code{NonEmptySet}.
Este comportamento \'{e} consequ\^{e}ncia direta do nosso modelo de substitui\c{c}\~{a}o da avalia\c{c}\~{a}o.
%----------

%----------
%% For instance,
Por exemplo, 
\begin{lstlisting}
    (new EmptySet).contains(7) 

->  $\rewriteby{by replacing {\sl contains} by its body in class {\sl EmptySet}}$

    false
\end{lstlisting}
Ou,
\begin{lstlisting}
    new NonEmptySet(7, new EmptySet, new EmptySet).contains(1)

->  $\rewriteby{by replacing {\sl contains} by its body in class {\sl NonEmptySet}}$

    if (1 < 7) new EmptySet contains 1
    else if (1 > 7) new EmptySet contains 1
    else true

->  $\rewriteby{by rewriting the conditional}$

    new EmptySet contains 1

->  $\rewriteby{by replacing {\sl contains} by its body in class {\sl EmptySet}}$

    false .
\end{lstlisting}
%----------

%----------
%% Dynamic method dispatch is analogous to higher-order function
%% calls. In both cases, the identity of code to be executed is known
%% only at run-time. This similarity is not just superficial. Indeed,
%% Scala represents every function value as an object (see
%% Section~\ref{sec:functions}).
Envio din\^{a}mico de m\'{e}todos \'{e} an\'{a}logo a chamadas para fun\c{c}\~{o}es de alta ordem. 
Em ambos os casos, a identidade do c\'{o}digo  a ser executado \'{e} conhecida somente
em tempo de execu\c{c}\~{a}o. Essa similaridade n\~{a}o \'{e} apenas superficial. Na verdade, 
Scala representa cada valor de fun\c{c}\~{a}o como um objeto (veja Se\c{c}\~{a}o~\ref{sec:functions}).
%----------

%----------
%% \paragraph{Objects}
\paragraph{Objetos}
%% In the previous implementation of integer sets, empty sets were
%% expressed with \code{new EmptySet}; so a new object was created every time
%% an empty set value was required. We could have avoided unnecessary
%% object creations by defining a value \code{empty} once and then using
%% this value instead of every occurrence of \code{new EmptySet}. For example:
Na implementa\c{c}\~{a}o pr\'{e}via de conjuntos de inteiros, conjuntos vazios eram expressos
com \code{new EmptySet}; ent\~{a}o um novo objeto era criado a cada vez que um valor
conjunto vazio era requerido. Podemos evitar cria\c{c}\~{o}es desnecess\'{a}rias de objetos 
definindo um valor \code{empty} uma vez e ent\~{a}o, usando este valor ao inv\'{e}s de cada 
ocorr\^{e}ncia de \code{new EmptySet}. Por exemplo:
 \begin{lstlisting}
 val EmptySetVal = new EmptySet
 \end{lstlisting}
%% One problem with this approach is that a value definition such as the
%% one above is not a legal top-level definition in Scala; it has to be
%% part of another class or object. Also, the definition of class
%% \code{EmptySet} now seems a bit of an overkill -- why define a class of objects, 
%% if we are only interested in a single object of this class? A more
%% direct approach is to use an {\em object definition}. Here is
%% a more streamlined alternative definition of the empty set:
Um problema com esse tratamento \'{e} que uma defini\c{c}\~{a}o de valor tal como a anterior
n\~{a}o \'{e} uma defini\c{c}\~{a}o top-level legal em Scala; tem de ser parte de uma outra classe 
ou objeto. Ainda, a defini\c{c}\~{a}o de classe \code{EmptySet} agora parece um pouco exagerada -- 
por que definir uma classe de objetos, se somente estamos interessados em um \'{u}nico objeto 
dessa classe? Um tratamento mais direto \'{e} usar uma {\em defini\c{c}\~{a}o de objeto}. Aqui est\'{a} 
uma alternativa mais adequada para a defini\c{c}\~{a}o de conjunto vazio:
\begin{lstlisting}
object EmptySet extends IntSet {
  def contains(x: Int): Boolean = false
  def incl(x: Int): IntSet = new NonEmptySet(x, EmptySet, EmptySet)
}
\end{lstlisting}
%----------

%----------
%% The syntax of an object definition follows the syntax of a class
%% definition; it has an optional extends clause as well as an optional
%% body. As is the case for classes, the extends clause defines inherited
%% members of the object whereas the body defines overriding or new
%% members.  However, an object definition defines a single object only
%% it is not possible to create other objects with the same structure
%% using \code{new}.  Therefore, object definitions also lack constructor
%% parameters, which might be present in class definitions.
A sintaxe de uma defini\c{c}\~{a}o de objeto segue a sintaxe da defini\c{c}\~{a}o de uma 
classe; tem uma cl\'{a}usula opcional extends, bem como um corpo opcional. 
Assim como em classes, a cl\'{a}usula extends define membros herdados do objeto 
considerando que o corpo define novos membros ou sobrecarga. Entretanto, uma 
defini\c{c}\~{a}o de objeto denota um \'{u}nico objeto somente se n\~{a}o for poss\'{i}vel criar
outros objetos com a mesma estrutura usando \code{new}. Ent\~{a}o, defini\c{c}\~{o}es de
objeto tamb\'{e}m carecem de par\^{a}metros construtores, que podem estar presentes
nas defini\c{c}\~{o}es das classes.
%----------

%----------
%% Object definitions can appear anywhere in a Scala program; including
%% at top-level.  Since there is no fixed execution order of top-level
%% entities in Scala, one might ask exactly when the object defined by an
%% object definition is created and initialized. The answer is that the
%% object is created the first time one of its members is accessed. This
%% strategy is called {\em lazy evaluation}.
Defini\c{c}\~{o}es de objetos podem aparecer em qualquer lugar em um programa Scala;
incluindo o top-level. Como n\~{a}o h\'{a} ordem fixa de execu\c{c}\~{a}o de entidades
top-level em Scala, pode-se questionar quando exatamente o objeto definido 
pela defini\c{c}\~{a}o de objeto \'{e} criado e inicializado. A resposta \'{e} que o objeto 
\'{e} criado assim que seus membros s\~{a}o acessados. Esta estrat\'{e}gia \'{e} chamada 
{\em avalia\c{c}\~{a}o pregui\c{c}osa}.
%----------

%----------
%% \paragraph{Standard Classes}
\paragraph{Classes Padr\~{a}o}
%% \todo{include picture}

%% Scala is a pure object-oriented language. This means that every value
%% in Scala can be regarded as an object.  In fact, even primitive types
%% such as \code{int} or \code{boolean} are not treated specially. They
%% are defined as type aliases of Scala classes in module \code{Predef}:
Scala \'{e} uma linguagem orientada a objetos pura. Isso significa que cada valor 
em Scala pode ser visto como um objeto. De fato, mesmo tipos primitivos tais como 
\code{int} ou \code{boolean} n\~{a}o s\~{a}o tratados de modo especial. S\~{a}o definidos
como apelidos de tipos de classes Scala no m\'{o}dulo \code{Predef}.  
\begin{lstlisting}
type boolean = scala.Boolean
type int = scala.Int
type long = scala.Long
...
\end{lstlisting}
%----------

%----------
%% For efficiency, the compiler usually represents values of type
%% \code{scala.Int} by 32 bit integers, values of type
%% \code{scala.Boolean} by Java's booleans, etc.  But it converts these
%% specialized representations to objects when required, for instance
%% when a primitive \code{Int} value is passed to a function with a
%% parameter of type \code{AnyRef}.  Hence, the special representation of
%% primitive values is just an optimization, it does not change the
%% meaning of a program.
Por efici\^{e}ncia, o compilador geralmente representa valor de tipo
\code{scala.Int} por inteiros de 32 bits, valores de tipo \code{scala.Boolean}
por boleanos Java etc. Mas converte essas representa\c{c}\~{o}es especializadas para 
objetos quando requeridos, por exemplo, quando um valor primitivo \code{Int} \'{e} 
passada a uma fun\c{c}\~{a}o com um par\^{a}metro de tipo \code{AnyRef}. Consequentemente, a
representa\c{c}\~{a}o de valores primitivos \'{e} apenas uma otimiza\c{c}\~{a}o, n\~{a}o muda o significado
de um programa.
%----------

%----------
%% Here is a specification of class \code{Boolean}.
Aqui est\'{a} a especifica\c{c}\~{a}o da classe \code{Boolean}.
\begin{lstlisting}
package scala
abstract class Boolean {
  def && (x: => Boolean): Boolean
  def || (x: => Boolean): Boolean
  def !                 : Boolean

  def == (x: Boolean)   : Boolean
  def != (x: Boolean)   : Boolean
  def <  (x: Boolean)   : Boolean
  def >  (x: Boolean)   : Boolean
  def <= (x: Boolean)   : Boolean
  def >= (x: Boolean)   : Boolean
}
\end{lstlisting}
%----------

%----------
%% Booleans can be defined using only classes and objects, without
%% reference to a built-in type of booleans or numbers. A possible
%% implementation of class \code{Boolean} is given below.  This is not
%% the actual implementation in the standard Scala library. For
%% efficiency reasons the standard implementation uses built-in
%% booleans.
Boleanos podem ser definidos usando somente classes e objetos, sem
refer\^{e}ncia ao tipos b\'{a}sicos para boleanos ou n\'{u}meros. Uma poss\'{i}vel 
implementa\c{c}\~{a}o da claro \code{Boolean} \'{e} dada abaixo. Esta n\~{a}o \'{e} 
a implementa\c{c}\~{a}o atual na biblioteca padr\~{a}o Scala. Por raz\~{o}es de 
efici\^{e}ncia a implementa\c{c}\~{a}o padr\~{a}o usa boleanos primitivos.
\begin{lstlisting}
package scala
abstract class Boolean {
  def ifThenElse(thenpart: => Boolean, elsepart: => Boolean)

  def && (x: => Boolean): Boolean  =  ifThenElse(x, false)
  def || (x: => Boolean): Boolean  =  ifThenElse(true, x)
  def !                 : Boolean  =  ifThenElse(false, true)

  def == (x: Boolean)   : Boolean  =  ifThenElse(x, x.!)
  def != (x: Boolean)   : Boolean  =  ifThenElse(x.!, x)
  def <  (x: Boolean)   : Boolean  =  ifThenElse(false, x)
  def >  (x: Boolean)   : Boolean  =  ifThenElse(x.!, false)
  def <= (x: Boolean)   : Boolean  =  ifThenElse(x, true)
  def >= (x: Boolean)   : Boolean  =  ifThenElse(true, x.!)
}
case object True extends Boolean {
  def ifThenElse(t: => Boolean, e: => Boolean) = t
}
case object False extends Boolean {
  def ifThenElse(t: => Boolean, e: => Boolean) = e
}
\end{lstlisting}
%----------

%----------
%% Here is a partial specification of class \code{Int}.
Aqui est\'{a} uma especifica\c{c}\~{a}o parcial da classe \code{Int}.
\begin{lstlisting}
package scala
abstract class Int extends AnyVal {
  def toLong: Long
  def toFloat: Float
  def toDouble: Double

  def + (that: Double): Double
  def + (that: Float): Float
  def + (that: Long): Long
  def + (that: Int): Int         // an\'{a}logo para -, *, /, %

  def << (cnt: Int): Int         // an\'{a}logo para  >>, >>>

  def & (that: Long): Long
  def & (that: Int): Int         // an\'{a}logo para |, ^

  def == (that: Double): Boolean
  def == (that: Float): Boolean
  def == (that: Long): Boolean   // an\'{a}logo para !=, <, >, <=, >=
}
\end{lstlisting}
%----------

%----------
%% Class \code{Int} can in principle also be implemented using just
%% objects and classes, without reference to a built in type of
%% integers. To see how, we consider a slightly simpler problem, namely
%% how to implement a type \code{Nat} of natural (i.e. non-negative)
%% numbers. Here is the definition of an abstract class \code{Nat}:
A classe \code{Int} pode em princ\'{i}pio tamb\'{e}m ser implementada usando
apenas objetos e classes, sem refer\^{e}ncia a um tipo constru\'{i}do para 
inteiros. Para ver como, vamos considerar um problema um pouco mais 
simples, especificamente como implementar um tipo \code{Nat} de 
n\'{u}meros naturais, ou seja, inteiros n\~{a}o negativo. Aqui est\'{a} uma defini\c{c}\~{a}o 
para uma classe abstrata \code{Nat}:
\begin{lstlisting}
abstract class Nat {
  def isZero: Boolean
  def predecessor: Nat
  def successor: Nat
  def + (that: Nat): Nat
  def - (that: Nat): Nat
}
\end{lstlisting}
%----------

%----------
%% To implement the operations of class \code{Nat}, we define a sub-object
%% \code{Zero} and a subclass \code{Succ} (for successor). Each number
%% \code{N} is represented as \code{N} applications of the \code{Succ}
%% constructor to \code{Zero}:
Para implementar as opera\c{c}\~{o}es da classe \code{Nat}, n\'{o}s definimos um
sub-objeto \code{Zero} e uma subclasse \code{Succ} (para sucessor). Cada 
n\'{u}mero \code{N} \'{e} representado como \code{N} aplica\c{c}\~{o}es do construtor \code{Succ}
at\'{e} zero: 
 \[
 \underbrace{\mbox{\sl new Succ( ... new Succ}}_{\mbox{$N$ times}}\mbox{\sl (Zero) ... )}
 \]
%% The implementation of the \code{Zero} object is straightforward:
A implementa\c{c}\~{a}o do objeto \code{Zero} \'{e} direta:
\begin{lstlisting}
object Zero extends Nat {
  def isZero: Boolean = true
  def predecessor: Nat = error("negative number")
  def successor: Nat = new Succ(Zero)
  def + (that: Nat): Nat = that
  def - (that: Nat): Nat = if (that.isZero) Zero
                           else error("negative number")
}
\end{lstlisting}
%----------

%----------
%% The implementation of the predecessor and subtraction functions on
%% \code{Zero} throws an \code{Error} exception, which aborts the program
%% with the given error message.

%% Here is the implementation of the successor class:

A implementa\c{c}\~{a}o das fun\c{c}\~{o}es  predecessor e subtra\c{c}\~{a}o sobre \code{Zero} leva a 
um \code{Erro}, que aborta o programa com uma mensagem de erro.

Aqui est\'{a} uma implementa\c{c}\~{a}o da classe sucessor: 

\begin{lstlisting}
class Succ(x: Nat) extends Nat  {
  def isZero: Boolean = false
  def predecessor: Nat = x
  def successor: Nat = new Succ(this)
  def + (that: Nat): Nat = x + that.successor
  def - (that: Nat): Nat = if (that.isZero) this 
                           else x - that.predecessor
}
\end{lstlisting}
%----------

%----------
%% Note the implementation of method \code{successor}. To create the
%% successor of a number, we need to pass the object itself as an
%% argument to the \code{Succ} constructor.  The object itself is
%% referenced by the reserved name \code{this}.
Observe a implementa\c{c}\~{a}o do m\'{e}todo \code{successor}. Para criar o 
sucessor de um n\'{u}mero, precisamos passar o pr\'{o}prio objeto como um 
argumento para o construtor \code{Succ}. O pr\'{o}prio objeto \'{e} referenciado
por uma palavra reservada \code{this}.   
%----------

%----------
%% The implementations of \code{+} and \code{-} each contain a recursive
%% call with the constructor argument as receiver. The recursion will
%% terminate once the receiver is the \code{Zero} object (which is
%% guaranteed to happen eventually because of the way numbers are formed).
As implementa\c{c}\~{o}es de \code{+} e \code{-}, cada uma cont\'{e}m uma chamada 
recursiva com o argumento do costrutor como destinat\'{a}rio. A recurs\~{a}o 
terminar\'{a} assim que o destinat\'{a}rio for o objeto \code{Zero} (o que \'{e} 
garantido de acontecer eventualmente dado o modo com que os n\'{u}meros s\~{a}o formados).
%----------

%----------
%% \begin{exercise} Write an implementation \code{Integer} of integer numbers
%% The implementation should support all operations of class \code{Nat}
%% while adding two methods
\begin{exercise}
Escreva uma implementa\c{c}\~{a}o \code{Integer} dos n\'{u}meros inteiros. A implementa\c{c}\~{a}o deve
suportar todas as opera\c{c}\~{o}es da classe \code{Nat} e mais dois m\'{e}todos.

\begin{lstlisting}
def isPositive: Boolean
def negate: Integer
\end{lstlisting}
%% The first method should return \code{true} if the number is positive.
%% The second method should negate the number.
%% Do not use any of Scala's standard numeric classes in your
%% implementation. (Hint: There are two possible ways to implement
%% \code{Integer}. One can either make use the existing implementation of
%% \code{Nat}, representing an integer as a natural number and a sign.
%% Or one can generalize the given implementation of \code{Nat} to
%% \code{Integer}, using the three subclasses \code{Zero} for 0, 
%% \code{Succ} for positive numbers and \code{Pred} for negative numbers.)
%% \end{exercise}
O primeiro m\'{e}todo deve retornar \code{true} se o n\'{u}mero for positivo. O segundo 
m\'{e}todo deve negativar o n\'{u}mero. N\~{a}o utilize qualquer classe num\'{e}rica padr\~{a}o Scala
em sua implementa\c{c}\~{a}o. (Dica: H\'{a} duas formas para implementar \code{Integer}. Uma
pode ou fazer uso da implementa\c{c}\~{a}o existente de \code{Nat}, representando um inteiro 
como um n\'{u}mero natural e um sinal. Ou pode-se generalizar a implementa\c{c}\~{a}o dada de 
\code{Nat} para \code{Integer}, usando as tr\^{e}s subclasses \code{Zero} para 0, 
\code{Succ} para n\'{u}meros positivos e \code{Pred} para n\'{u}meros negativos. 
\end{exercise}
%----------

%----------
%% \subsection*{Language Elements Introduced In This Chapter}
\subsection*{Elementos da Linguagem Introduzidos Neste Cap\'{i}tulo}
 \textbf{Types:}
 \begin{lstlisting}
 Type         = ...  |  ident
 \end{lstlisting}

%% Types can now be arbitrary identifiers which represent classes.
Tipos podem agora ser identificadores arbitr\'{a}rios que representam classes.

%% \textbf{Expressions:}
\textbf{Express\~{o}es:}
 \begin{lstlisting}
 Expr         = ...  |  Expr '.' ident  |  'new' Expr  |  'this'
 \end{lstlisting}

%% An expression can now be an object creation, or
%% a selection \code{E.m} of a member \code{m}
%% from an object-valued expression \code{E}, or it can be the reserved name \code{this}.
Uma express\~{a}o pode agora ser uma cria\c{c}\~{a}o de objeto, ou uma sele\c{c}\~{a}o
\code{E.m} de um membro \code{m} a partir de uma express\~{a}o valorada objeto \code{E},
ou pode ser a palavra reservada \code{this}.
%----------

%----------
%% \textbf{Definitions and Declarations:}
 \textbf{Defini\c{c}\~{o}es e Declara\c{c}\~{o}es}
\begin{lstlisting}
Def          = FunDef  |  ValDef  |  ClassDef  |  TraitDef  |  ObjectDef
ClassDef     = ['abstract'] 'class' ident ['(' [Parameters] ')'] 
               ['extends' Expr] [`{' {TemplateDef} `}']
TraitDef     = 'trait' ident ['extends' Expr] ['{' {TemplateDef} '}']
ObjectDef    = 'object' ident ['extends' Expr] ['{' {ObjectDef} '}']
TemplateDef  = [Modifier] (Def | Dcl)
ObjectDef    = [Modifier] Def
Modifier     = 'private'  |  'override'
Dcl          = FunDcl  |  ValDcl
FunDcl       = 'def' ident {'(' [Parameters] ')'} ':' Type
ValDcl       = 'val' ident ':' Type
\end{lstlisting}

%%A definition can now be a class, trait or object definition such as
Uma defini\c{c}\~{a}o pode agora ser uma defini\c{c}\~{a}o de classe, trait ou objeto, tal como  
\begin{lstlisting}
class C(params) extends B { defs }
trait T extends B { defs }
object O extends B { defs }
\end{lstlisting}
%% The definitions \code{defs} in a class, trait or object may be
%% preceded by modifiers \code{private} or \code{override}.
As defini\c{c}\~{o}es \code{defs} na classe, trait ou objeto podem ser 
precedidas pelos modificadores \code{private} ou \code{override}.

%% Abstract classes and traits may also contain declarations. These
%% introduce {\em deferred} functions or values with their types, but do
%% not give an implementation. Deferred members have to be implemented in
%% subclasses before objects of an abstract class or trait can be created.
Classes abstratas e traits podem tamb\'{e}m conter declara\c{c}\~{o}es. Isso introduz
fun\c{c}\~{o}es {\em deferred} (postergadas) ou valores com seus tipos, mas n\~{a}o 
d\~{a}o uma implementa\c{c}\~{a}o. Membros deferred devem ser implementados nas subclasses 
antes que objetos de uma classe abstrata ou trait sejam criados. 
%----------


%----------
%% \chapter{Case Classes and Pattern Matching}
\chapter{Classes Case e Casamento de Padr\~{o}es}
%% Say, we want to write an interpreter for arithmetic expressions.  To
%% keep things simple initially, we restrict ourselves to just numbers
%% and \code{+} operations. Such expressions can be represented as a class hierarchy, with an abstract base class \code{Expr} as the root, and two subclasses \code{Number} and
%% \code{Sum}. Then, an expression \code{1 + (3 + 7)} would be represented as
Digamos, queremos escrever um interpretador para express\~{o}es aritm\'{e}ticas. Para 
deixar as coisas simples inicialmente, vamos nos restringir somente a n\'{u}meros e opera\c{c}\~{o}es \code{+}.
Tais express\~{o}es podem ser representadas como hierarquia de classes, 
com uma classe abstrata base \code{Expr} como raiz, e duas subclasses \code{Number} e \code{Sum}.
Ent\~{a}o, uma express\~{a}o \code{1 + (3 + 7)} \'{e} representada como 
 \begin{lstlisting}
 new Sum(new Number(1), new Sum(new Number(3), new Number(7)))
 \end{lstlisting}
%----------

%----------
%% Now, an evaluator of an expression like this needs to know of what
%% form it is (either \code{Sum} or \code{Number}) and also needs to
%% access the components of the expression.  The following
%% implementation provides all necessary methods.
Agora, um avaliador de uma express\~{a}o como esta precisa saber de 
qual forma ela \'{e} (ou \code{Sum} ou \code{Number}) e tamb\'{e}m precisa
acessar os componentes da express\~{a}o. A implementa\c{c}\~{a}o a seguir prov\^{e}
todos os m\'{e}todos necess\'{a}rios.
\begin{lstlisting}
abstract class Expr {
  def isNumber: Boolean
  def isSum: Boolean
  def numValue: Int
  def leftOp: Expr
  def rightOp: Expr
}
class Number(n: Int) extends Expr {
  def isNumber: Boolean = true
  def isSum: Boolean = false
  def numValue: Int = n
  def leftOp: Expr = error("Number.leftOp")
  def rightOp: Expr = error("Number.rightOp")
}
class Sum(e1: Expr, e2: Expr) extends Expr {
  def isNumber: Boolean = false
  def isSum: Boolean = true
  def numValue: Int = error("Sum.numValue")
  def leftOp: Expr = e1
  def rightOp: Expr = e2
}
\end{lstlisting}
%----------

%----------
%%With these classification and access methods, writing an evaluator function is simple:
Com esta classifica\c{c}\~{a}o e m\'{e}todos de acesso, escrever uma fun\c{c}\~{a}o avaliador \'{e} simples:
\begin{lstlisting}
def eval(e: Expr): Int = {
  if (e.isNumber) e.numValue
  else if (e.isSum) eval(e.leftOp) + eval(e.rightOp)
  else error("unrecognized expression kind")
}
\end{lstlisting}
%% However, defining all these methods in classes \code{Sum} and
%% \code{Number} is rather tedious. Furthermore, the problem becomes worse 
%% when we want to add new forms of expressions. For instance, consider
%% adding a new expression form
%% \code{Prod} for products. Not only do we have to implement a new class \code{Prod}, with all previous classification and access methods; we also have to introduce a
%% new abstract method \code{isProduct} in class \code{Expr} and
%% implement that method in subclasses \code{Number}, \code{Sum}, and
%% \code{Prod}. Having to modify existing code when a system grows is always problematic, since it introduces versioning and maintenance problems. 
Entretanto, definir todos esses m\'{e}todos dentro das classes \code{Sum} e \code{Number}
\'{e} um tanto quanto tedioso. Al\'{e}m do mais, o problema fica ainda pior se desejarmos 
adicionar novas formas de express\~{o}es. Por exemplo, considere adicionar uma nova 
forma de express\~{a}o \code{Prod} para produtos. N\~{a}o apenas teremos de implementar uma nova classe 
\code{Prod}, com todos os m\'{e}todos de acesso e classifica\c{c}\~{a}o pr\'{e}vios; tamb\'{e}m teremos de 
introduzir um novo m\'{e}todo abstrato \code{isProduct} dentro da classe \code{Expr} e 
implementar aquele m\'{e}todo na subclasse \code{Number}, \code{Sum}, e \code{Prod}.
Ter de  modificar c\'{o}digo existente quando um sistema cresce \'{e} sempre problem\'{a}tico, pois
introduz problemas de vers\~{a}o e manuten\c{c}\~{a}o.  
%----------

%----------
%% The promise of object-oriented programming is that such modifications
%% should be unnecessary, because they can be avoided by re-using
%% existing, unmodified code through inheritance. Indeed, a more
%% object-oriented decomposition of our problem solves the problem.  The
%% idea is to make the ``high-level'' operation \code{eval} a method of
%% each expression class, instead of implementing it as a function
%% outside the expression class hierarchy, as we have done
%% before. Because \code{eval} is now a member of all expression nodes,
%% all classification and access methods become superfluous, and the implementation is simplified considerably:
A promessa da programa\c{c}\~{a}o orientada a objetos \'{e} que tais modifica\c{c}\~{o}es 
s\~{a}o desnecess\'{a}rias, dado que podem ser evitadas pela reutiliza\c{c}\~{a}o de c\'{o}digo 
existente e n\~{a}o modificado, atrav\'{e}s da heran\c{c}a. De fato, uma decomposi\c{c}\~{a}o 
mais orientada a objetos para nosso problema resolve a quest\~{a}o. A id\'{e}ia \'{e} tornar
a opera\c{c}\~{a}o de alto n\'{i}vel \code{eval} um m\'{e}todo para cada classe express\~{a}o, ao 
inv\'{e}s de implement\'{a}-lo como uma fun\c{c}\~{a}o fora da hierarquia de classes express\~{o}es, como 
fizemos anteriormente. Como \code{eval} \'{e} agora um membro de todos os n\'{o}s de express\~{a}o, 
quaisquer m\'{e}todos de classifica\c{c}\~{a}o e acesso tornam-se sup\'{e}rfluos, e a implementa\c{c}\~{a}o 
\'{e} simplificada consideravelmente:  
\begin{lstlisting}
abstract class Expr {
  def eval: Int
}
class Number(n: Int) extends Expr {
  def eval: Int = n
}
class Sum(e1: Expr, e2: Expr) extends Expr {
  def eval: Int = e1.eval + e2.eval
}
\end{lstlisting}
%----------

%----------
%%Furthermore, adding a new \code{Prod} class does not entail any changes to existing code:
Al\'{e}m disso, adicionar uma nova classe \code{Prod} n\~{a}o leva a qualquer mudan\c{c}a ao c\'{o}digo existente:
\begin{lstlisting}
class Prod(e1: Expr, e2: Expr) extends Expr {
  def eval: Int = e1.eval * e2.eval
}
\end{lstlisting}

%% The conclusion we can draw from this example is that object-oriented
%% decomposition is the technique of choice for constructing systems that
%% should be extensible with new types of data. But there is also another
%% possible way we might want to extend the expression example. We might
%% want to add new {\em operations} on expressions.  For instance, we might
%% want to add an operation that pretty-prints an expression tree to standard output.
A conclus\~{a}o que tiramos deste exemplo \'{e} que a decomposi\c{c}\~{a}o orientada a objetos
\'{e} a t\'{e}cnica de escolha para a constru\c{c}\~{a}o de sistemas que devem ser estens\'{i}veis
com novos tipos de dados. Mas h\'{a} tamb\'{e}m um outro poss\'{i}vel modo para estender a 
express\~{a}o exemplo. Podemos querer adicionar novas {\em opera\c{c}\~{o}es} sobre express\~{o}es.
Por exemplo, podemos querer adicionar uma opera\c{c}\~{a}o que imprime uma \'{a}rvore-express\~{a}o
para a sa\'{i}da padr\~{a}o.  
%----------

%----------
%% If we have defined all classification and access methods, such an
%% operation can easily be written as an external function. Here is an
%% example:
Se definimos todos os m\'{e}todos de classifica\c{c}\~{a}o e acesso, tal opera\c{c}\~{a}o pode ser 
facilmente escrita como uma fun\c{c}\~{a}o externa. Aqui est\'{a} um exemplo: 
\begin{lstlisting}
def print(e: Expr) {
  if (e.isNumber) Console.print(e.numValue)
  else if (e.isSum) {
    Console.print("(")
    print(e.leftOp)
    Console.print("+")
    print(e.rightOp)
    Console.print(")")
  } else error("unrecognized expression kind")
}
\end{lstlisting}
%% However, if we had opted for an object-oriented decomposition of
%% expressions, we would need to add a new \code{print} procedure
%% to each class:
Entretanto, se optamos por uma decomposi\c{c}\~{a}o orientada a objetos das 
express\~{o}es, precisaremos adicionar um novo procedimento \code{print} 
para cada classe: 
\begin{lstlisting}
abstract class Expr {
  def eval: Int
  def print
}
class Number(n: Int) extends Expr {
  def eval: Int = n
  def print { Console.print(n) }
}
class Sum(e1: Expr, e2: Expr) extends Expr {
  def eval: Int = e1.eval + e2.eval
  def print {
    Console.print("(")
    print(e1)
    Console.print("+")
    print(e2)
    Console.print(")")
  }
}
\end{lstlisting}
%----------

%----------
%% Hence, classical object-oriented decomposition requires modification
%% of all existing classes when a system is extended with new operations.
Consequentemente, decomposi\c{c}\~{a}o orientada a objetos cl\'{a}ssica requer modifica\c{c}\~{a}o 
de todas as classes existentes quando um sistema for estendido com novas
opera\c{c}\~{o}es.

%% As yet another way we might want to extend the interpreter, consider
%% expression simplification. For instance, we might want to write a
%% function which rewrites expressions of the form
%% \code{a * b + a * c} to \code{a * (b + c)}. This operation requires inspection of 
%% more than a single node of the expression tree at the same
%% time. Hence, it cannot be implemented by a method in each expression
%% kind, unless that method can also inspect other nodes. So we are
%% forced to have classification and access methods in this case. This
%% seems to bring us back to square one, with all the problems of
%% verbosity and extensibility.

Ainda como uma outra forma, podemos querer estender o interpretador. 
Considere a simplifica\c{c}\~{a}o de express\~{o}es. Por exemplo, podemos querer criar 
uma fun\c{c}\~{a}o que reescreve express\~{o}es da forma \code{a * b + a * c} para 
\code{a * (b + c)}. Esta opera\c{c}\~{a}o requer inspe\c{c}\~{a}o de mais de um n\'{o} para a 
\'{a}rvore de express\~{o}es ao mesmo tempo. Consequentemente, n\~{a}o pode ser implementada
por um m\'{e}todo dentro de cada tipo de express\~{a}o, a n\~{a}o ser que tal m\'{e}todo tamb\'{e}m 
possa inspecionar outros n\'{o}s. Portanto somos for\c{c}ados a ter m\'{e}todos de acesso e 
classifica\c{c}\~{a}o neste caso. Isto parece nos levar para a casa inicial, com todos os 
problemas de estensibilidade e expressividade.
%----------

%----------
%% Taking a closer look, one observes that the only purpose of the
%% classification and access functions is to {\em reverse} the data
%% construction process.  They let us determine, first, which sub-class
%% of an abstract base class was used and, second, what were the
%% constructor arguments. Since this situation is quite common, Scala has
%% a way to automate it with case classes. 
Olhando mais de perto, observa-se que o \'{u}nico prop\'{o}sito das fun\c{c}\~{o}es de acesso
e classifica\c{c}\~{a}o  \'{e} {\em reverter} o processo de constru\c{c}\~{a}o de dados. Elas nos 
permitem determinar, primeiro, qual subclasse de uma classe base abstrata foi 
usada e, segundo, quais foram os argumentos construtores. Como essa situa\c{c}\~{a}o \'{e} 
bem comum, Scala tem um modo de automatiz\'{a}-lo para classes case.
%----------

%----------
%% \section{Case Classes and Case Objects}
\section{Classes Case e Objetos Case}

%% {\em Case classes} and {\em case objects} are defined like a normal
%% classes or objects, except that the definition is prefixed with the modifier
%% \code{case}.  For instance, the definitions
{\em Classes Case} e {\em objetos case} s\~{a}o definidos como classes e objetos 
normais, exceto que a defini\c{c}\~{a}o \'{e} prefixada com um modificador \code{case}. 
Por exemplo, as defini\c{c}\~{o}es:

\begin{lstlisting}
abstract class Expr
case class Number(n: Int) extends Expr
case class Sum(e1: Expr, e2: Expr) extends Expr
\end{lstlisting}
%% introduce \code{Number} and \code{Sum} as case classes.
%% The \code{case} modifier in front of a class or object 
%% definition has the following effects.
%% \begin{enumerate}
%% \item Case classes implicitly come with a constructor function, with the same name as the class. 
%%In our example, the two functions
introduzem \code{Number} e \code{Sum} como classes case.
O modificador \code{case} em frente a uma defini\c{c}\~{a}o de classe ou objeto tem 
os seguintes efeitos.
\begin{enumerate}
\item Classes case implicitamente vem com uma fun\c{c}\~{a}o construtora, com o mesmo nome da classe.
No nosso exemplo, as duas fun\c{c}\~{o}es
\begin{lstlisting}
def Number(n: Int) = new Number(n)
def Sum(e1: Expr, e2: Expr) = new Sum(e1, e2)
\end{lstlisting}
%----------

%----------
%%would be added. Hence, one can now construct expression trees a bit more concisely, as in
ser\~{a}o adicionadas. Consequentemente, pode-se agora construir \'{a}rvores-express\~{o}es de modo um 
pouco mais conciso, como em
\begin{lstlisting}
Sum(Sum(Number(1), Number(2)), Number(3))
\end{lstlisting} 
%% \item Case classes and case objects 
%% implicitly come with implementations of methods
%% \code{toString}, \code{equals} and \code{hashCode}, which override the
%% methods with the same name in class \code{AnyRef}. The implementation
%% of these methods takes in each case the structure of a member of a
%% case class into account. The \code{toString} method represents an
%% expression tree the way it was constructed. So,
\item Classes case e objetos case implicitamente vem com implementa\c{c}\~{o}es dos m\'{e}todos 
\code{toString}, \code{equals} e \code{hashCode}, que sobrescrevem os
m\'{e}todos com o mesmo nome na classe \code{AnyRef}. A implementa\c{c}\~{a}o desses 
m\'{e}todos leva em considera\c{c}\~{a}o em cada caso a estrutura de um membro de uma classe 
case. O m\'{e}todo \code{toString} representa uma \'{a}rvore express\~{a}o do modo como foi
constru\'{i}da. Ent\~{a}o,  
\begin{lstlisting}
Sum(Sum(Number(1), Number(2)), Number(3))
\end{lstlisting} 
%----------

%----------
%% would be converted to exactly that string, whereas the default
%% implementation in class \code{AnyRef} would return a string consisting
%% of the outermost constructor name \code{Sum} and a number.  The
%% \code{equals} methods treats two case members of a case class as equal
%% if they have been constructed with the same constructor and with
%% arguments which are themselves pairwise equal. This also affects the
%% implementation of \code{==} and \code{!=}, which are implemented in
%% terms of \code{equals} in Scala. So,
ser\'{a} convertida exatamente naquela cadeia de caracteres, onde a implementa\c{c}\~{a}o 
default dentro da classe \code{AnyRef} retornar\'{a} uma cadeia de caracteres 
consistindo construtor \code{Sum} mais externo e um n\'{u}mero. O m\'{e}todo 
\code{equals} trata dois membros case da classe case do mesmo modo, caso
eles tenham sido constru\'{i}dos com o mesmo construtor e com argumentos que 
s\~{a}o par a par iguais. Isso tamb\'{e}m afeta a implementa\c{c}\~{a}o de \code{==} e 
\code{!=}, que s\~{a}o implementados em termos de \code{equals} em Scala. Ent\~{a}o,  
 \begin{lstlisting}
 Sum(Number(1), Number(2)) == Sum(Number(1), Number(2))
 \end{lstlisting}
%----------

%----------
%% will yield \code{true}. If \code{Sum} or \code{Number} were not case
%% classes, the same expression would be \code{false}, since the standard
%% implementation of \code{equals} in class \code{AnyRef} always treats
%% objects created by different constructor calls as being different.
%% The \code{hashCode} method follows the same principle as other two
%% methods. It computes a hash code from the case class constructor name
%% and the hash codes of the constructor arguments, instead of from the object's
%% address, which is what the as the default implementation of \code{hashCode} does.
%% \item 
%% Case classes implicitly come with nullary accessor methods which
%% retrieve the constructor arguments.
%% In our example, \code{Number} would obtain an accessor method
dar\'{a} \code{true}. Se \code{Sum} ou \code{Number} n\~{a}o fossem classes case, a 
mesma express\~{a}o seria \code{false}, pois a implementa\c{c}\~{a}o padr\~{a}o de \code{equals} na 
classe \code{AnyRef} sempre trata objetos criados por diferentes chamadas de construtores 
como sendo diferentes. O m\'{e}todo \code{hashCode} segue a mesmo princ\'{i}pio dos 
outros dois m\'{e}todos. Computa um c\'{o}digo hash a partir do nome do construtor da classe case
e os c\'{o}digos hash dos argumentos do construtor, ao inv\'{e}s de o fazer a partir do endere\c{c}o 
do objeto, que \'{e} o que a implementa\c{c}\~{a}o default de \code{hashCode} faz.
\item
Classes case implicitamente vem com m\'{e}todos de acesso nulos que recuperam os argumentos 
do construtor. Em nosso exemplo, \code{Number} obteria um m\'{e}todo de acesso  
 \begin{lstlisting}
 def n: Int
 \end{lstlisting}
%----------

%----------
%% which returns the constructor parameter \code{n}, whereas \code{Sum} would obtain two accessor methods
que retorna o par\^{a}metro \code{n} do construtor, onde \code{Sum} obter\'{a} dois m\'{e}todos de acesso
 \begin{lstlisting}
 def e1: Expr, e2: Expr
 \end{lstlisting}
%% Hence, if for a value \code{s} of type \code{Sum}, say, one can now
%% write \code{s.e1}, to access the left operand. However, for a value
%% \code{e} of type \code{Expr}, the term \code{e.e1} would be illegal
%% since \code{e1} is defined in \code{Sum}; it is not a member of the
%% base class \code{Expr}. 
%% So, how do we determine the constructor and access constructor
%% arguments for values whose static type is the base class \code{Expr}?
%% This is solved by the fourth and final particularity of case classes.
%% \item 
%% Case classes allow the constructions of {\em patterns} which refer to
%% the case class constructor.

Consequentemente, para um valor \code{s} de tipo \code{Sum}, digamos, 
podemos escrever \code{s.e1} para acessar o operando esquerdo. Entretanto, 
para um valor \code{e} de tipo \code{Expr}, o termo \code{e.e1} ser\'{a} ilegal,
pois \code{e1} \'{e} definido em \code{Sum}; n\~{a}o \'{e} um membro da classe base
\code{Expr}.
Ent\~{a}o, como determinar o construtor e os argumentos do construtor de acesso
para valores cujo tipo est\'{a}tico \'{e} a classe base \code{Expr}? Isso \'{e} resolvido
pela quarta e \'{u}ltima particularidade das classes case.
\item
Classes case permitem constru\c{c}\~{o}es de {\em padr\~{o}es} que se referem ao construtor 
da classe case.
 \end{enumerate}
%----------

%----------
%% \section{Pattern Matching}
\section{Casamento de Padr\~{o}es}

%% Pattern matching is a generalization of C or Java's \code{switch}
%% statement to class hierarchies. Instead of a \code{switch} statement,
%% there is a standard method \code{match}, which is defined in Scala's
%% root class \code{Any}, and therefore is available for all objects.
%% The \code{match} method takes as argument a number of cases. 
%% For instance, here is an implementation of \code{eval} using 
%% pattern matching.
O casamento de padr\~{o}es \'{e} uma generaliza\c{c}\~{a}o do comando \code{switch} do C ou
Java para hierarquias de classes. Ao inv\'{e}s de um comando \code{switch}, h\'{a} um 
m\'{e}todo padr\~{a}o \code{match}, que \'{e} definido na classe ra\'{i}z Scala \code{Any}, e 
portanto est\'{a} dispon\'{i}vel para todos os objetos. O m\'{e}todo \code{match} recebe como 
argumento um n\'{u}mero de cases. Por exemplo, aqui est\'{a} uma implementa\c{c}\~{a}o de \code{eval}
usando casamento de padr\~{o}es.

\begin{lstlisting}
def eval(e: Expr): Int = e match {
  case Number(n) => n 
  case Sum(l, r) => eval(l) + eval(r) 
}
\end{lstlisting}
%----------

%----------
%% In this example, there are two cases. Each case associates a pattern
%% with an expression. Patterns are matched against the selector
%% values \code{e}.  The first pattern in our example,
%% \code{Number(n)}, matches all values of the form \code{Number(v)}, 
%% where \code{v} is an arbitrary value.  In that case, the {\em pattern
%% variable} \code{n} is bound to the value \code{v}. Similarly, the
%% pattern \code{Sum(l, r)} matches all selector values of form
%% \code{Sum(v}$_1$\code{, v}$_2$\code{)} and binds the pattern variables
%% \code{l} and \code{r} 
%% to \code{v}$_1$ and \code{v}$_2$, respectively. 
Neste exemplo, h\'{a} dois cases. Cada case associa um padr\~{a}o a uma express\~{a}o. 
Padr\~{o}es s\~{a}o casados contra o valor do seletor \code{e}. O primeiro padr\~{a}o do
nosso exemplo, \code{Number(n)}, casa todos os valores da forma \code{Number(v)},
onde \code{v} \'{e} um valor arbitr\'{a}rio. Naquele caso, a {\em vari\'{a}vel padr\~{a}o} \code{n}
\'{e} ligada ao valor \code{v}. Similarmente, o padr\~{a}o \code{Sum(l, r)} casa com todos 
os valores do seletor da forma \code{Sum(v}$_1$\code{, v}$_2$\code{)} e liga as 
vari\'{a}veis padr\~{a}o \code{l} e \code{r} a \code{v}$_1$ e \code{v}$_2$, respectivamente. 
%----------

%----------
%% In general, patterns are built from
%% \begin{itemize}
%% \item Case class constructors, e.g. \code{Number}, \code{Sum}, whose arguments
%%       are again patterns,
%% \item pattern variables, e.g. \code{n}, \code{e1}, \code{e2},
%% \item the ``wildcard'' pattern \code{_},
%% \item literals, e.g. \code{1}, \code{true}, "abc", 
%% \item constant identifiers, e.g. \code{MAXINT}, \code{EmptySet}.
%% \end{itemize}

Em geral, padr\~{o}es s\~{a}o constru\'{i}dos a partir

\begin{itemize}
\item Construtores de classes case, por exemplo \code{Number}, \code{Sum}, cujos
argumentos s\~{a}o, novamente, padr\~{o}es, 
\item vari\'{a}veis padr\~{a}o, por exemplo \code{n}, \code{e1}, \code{e2}, 
\item o padr\~{a}o ``coringa'' \code{_},
\item literais, tal como \code{1}, \code{true},  "abc", 
\item identificadores constantes, tais como \code{MAXINT}, \code{EmptySet}.  
\end{itemize}
%% Pattern variables always start with a lower-case letter, so that they
%% can be distinguished from constant identifiers, which start with an
%% upper case letter.  Each variable name may occur only once in a
%% pattern. For instance, \code{Sum(x, x)} would be illegal as a pattern,
%% since the pattern variable \code{x} occurs twice in it.

Vari\'{a}veis padr\~{a}o sempre iniciam com uma letra min\'{u}scula, para que possamos
distingu\'{i}-las de identificadores constantes, que iniciam com uma letra 
mai\'{u}scula. Cada nome de vari\'{a}vel pode ocorrer somente uma vez em um padr\~{a}o. 
Por exemplo, \code{Sum(x, x)} seria ilegal como padr\~{a}o, pois a vari\'{a}vel padr\~{a}o 
\code{x} ocorre duas vezes dentro dele.  

%----------

%----------
%% \paragraph{Meaning of Pattern Matching}
%% A pattern matching expression 
\paragraph{Significado do Casamento de Padr\~{o}es}
Uma express\~{a}o de casamento de padr\~{o}es

\begin{lstlisting}
e match { case p$_1$ => e$_1$ ... case p$_n$ => e$_n$ }
\end{lstlisting}
%% matches the patterns $p_1 \commadots p_n$ in the order they
%% are written against the selector value \code{e}.
casa os padr\~{o}es $p_1 \commadots p_n$ na ordem em que eles s\~{a}o 
escritos contra o valor seletor \code{e}.
%----------


\begin{itemize}
\item
Um construtor padrão $C(p_1 \commadots p_n)$ casa com todos os valores que são 
do tipo \code{C} (ou um subtipo dele) e que foram construídos com argumentos \code{C}
casando com padrões $p_1 \commadots p_n$.

\item 
Uma variável padrão \code{x} casa com qualquer valor e liga o nome da variável àquele valor.

\item 
O caracter padrão `\code{_}' casa com qualquer valor, mas não liga um nome àquele valor.

\item 
Um padrão constante \code{C} casa um valor que é igual (em termos de \code{==}) para \code{C}.

\end{itemize}



A expressão de casamento de padrões reescreve no lado direito do primeiro case cujo
padrão casa com o valor seletor. Referências as variáveis padrão são substituídas pelos 
correspondentes argumentos construtores. Se nenhum dos padrões casar, a expressão 
de casamento de padrões é abortada com um erro \code{MatchError}.  


\example Nosso modelo de substituição de avaliação de programa estende de modo natural o casamento de padrões. Por exemplo, aqui temos como \code{eval} aplicado a uma única expressão é reescrito:


\begin{lstlisting}
     eval(Sum(Number(1), Number(2)))

->   $\mbox{\tab\tab\rm(através da reescrita da aplicação)}$

     Sum(Number(1), Number(2)) match {
         case Number(n) => n
         case Sum(e1, e2) => eval(e1) + eval(e2)
     }

->   $\mbox{\tab\tab\rm(através da reescrita do casamento de padrões)}$

     eval(Number(1)) + eval(Number(2))

->   $\mbox{\tab\tab\rm(através da reescrita da primeira aplicação)}$

     Number(1) match {
         case Number(n) => n
         case Sum(e1, e2) => eval(e1) + eval(e2)
     } + eval(Number(2))

->   $\mbox{\tab\tab\rm(através da reescrita do casamento de padrões)}$

     1 + eval(Number(2))

->$^*$ 1 + 2 -> 3
\end{lstlisting}


\paragraph{Casamento de Padrões e Métodos}
No exemplo anterior, usamos casamento de padrões numa função que era definida fora da 
hierarquia de classes da qual pertencia. De fato, é também possível definir uma função 
de casamento de padrões na sua própria hierarquia de classes. Por exemplo, podíamos 
ter definido \code{eval} como um método da classe base \code{Expr}, e ainda assim usar o 
casamento de padrões na sua implementação:

\begin{lstlisting}
abstract class Expr { 
  def eval: Int = this match {
    case Number(n) => n
    case Sum(e1, e2) => e1.eval + e2.eval 
  } 
}
\end{lstlisting}

\begin{exercise} Considere as seguintes definições representando árvores de inteiros. 
Estas definições podem ser vistas como uma representação alternativa para \code{IntSet}: 

\begin{lstlisting}
abstract class IntTree
case object EmptyTree extends IntTree
case class  Node(elem: Int, left: IntTree, right: IntTree) extends IntTree
\end{lstlisting}


Complete as implementações a seguir da função \code{contains} e \code{insert} para 
\code{IntTree}.

\begin{lstlisting}
def contains(t: IntTree, v: Int): Boolean = t match { ...
  ...
}
def insert(t: IntTree, v: Int): IntTree = t match { ...
  ...
}
\end{lstlisting}
\end{exercise}


\paragraph{Funções Anônimas e Casamento de Padrões}

Até aqui, expressões case sempre apareceram conjuntamente com uma operação 
\verb@match@. Mas é também possível usar expressões case por elas mesmas. Um
bloco de expressões case tal como  


\begin{lstlisting}
{ case $P_1$ => $E_1$ ... case $P_n$ => $E_n$ }
\end{lstlisting}

é visto como uma função que casa seus argumentos contra os padrões $P_1 \commadots P_n$,
e produz o resultado de um dos $E_1 \commadots E_n$. (Se nenhum padrão casar, a função 
produzirá uma  exceção \code{MatchError}. 
Em outras palavras, a expressão acima é vista como um atalho para a função anônima
\begin{lstlisting}
(x => x match { case $P_1$ => $E_1$ ... case $P_n$ => $E_n$ })
\end{lstlisting}
onde \code{x} é uma variável nova que não é usada a não ser dentro da expressão.

\chapter{Tipos Genéricos e Métodos}

Classes em Scala podem ter tipos como parâmetros. Demostraremos o uso 
de tipos parâmetros com pilhas funcionais como exemplo. Digamos, desejamos
escrever um tipo de dados para pilhas de inteiros, com métodos \code{push},
\code{top}, \code{pop}, e \code{isEmpty}. Isso é conseguido pela seguinte 
hierarquia de classes:

\begin{lstlisting}
abstract class IntStack {
  def push(x: Int): IntStack = new IntNonEmptyStack(x, this)
  def isEmpty: Boolean
  def top: Int
  def pop: IntStack
}
class IntEmptyStack extends IntStack {
  def isEmpty = true
  def top = error("EmptyStack.top")
  def pop = error("EmptyStack.pop")
}
class IntNonEmptyStack(elem: Int, rest: IntStack) extends IntStack {
  def isEmpty = false
  def top = elem
  def pop = rest
}
\end{lstlisting}

De fato, faz sentido definir uma abstração para uma pilha de Strings. Para
isso, pode-se tomar a abstração existente para \code{IntStack}, renomeá-la para 
\code{StringStack} e ao mesmo tempo renomear todas as ocorrências do tipo
\code{Int} para \code{String}.

Um modo melhor, que não leva a duplicação de código, é parametrizar as
definições da pilha com o tipo do elemento. Parametrizações nos levam
a generalizar a partir de uma instância específica de um problema para 
uma mais genérica. Até aqui, usamos parametrização somente para valores, mas 
também está disponível para tipos. Para obtermos uma versão {\em genérica} de
\code{Stack}, a equiparemos com um parâmetro tipo.

\begin{lstlisting}
abstract class Stack[A] {
  def push(x: A): Stack[A] = new NonEmptyStack[A](x, this)
  def isEmpty: Boolean
  def top: A
  def pop: Stack[A]
}
class EmptyStack[A] extends Stack[A] {
  def isEmpty = true
  def top = error("EmptyStack.top")
  def pop = error("EmptyStack.pop")
}
class NonEmptyStack[A](elem: A, rest: Stack[A]) extends Stack[A] {
  def isEmpty = false
  def top = elem
  def pop = rest
}
\end{lstlisting}

Nas definições acima, `\code{A}' é um {\em parâmetro tipo} da classe
\code{Stack} e suas subclasses. Parâmetros tipo são nomes arbitrários; eles
são envolvidos por chaves ao invés de parênteses, portanto podem facilmente 
distinguidos de parâmetros valor. Aqui está um exemplo de como classes genéricas
são usadas:

\begin{lstlisting}
val x = new EmptyStack[Int]
val y = x.push(1).push(2)
println(y.pop.top)
\end{lstlisting}
A primeira linha cria uma nova pilha vazia de \code{Int}. Observe o tipo argumento 
\code{[Int]} que substitui o tipo parâmetro formal \code{A}.

Também é possível parametrizar métodos com tipos. Como um exemplo, aqui está um
método genérico que determina se uma pilha é um prefixo de outra.
\begin{lstlisting}
def isPrefix[A](p: Stack[A], s: Stack[A]): Boolean = {
  p.isEmpty ||
  p.top == s.top && isPrefix[A](p.pop, s.pop)
}
\end{lstlisting}

Os parâmetros do método são chamados {\em polimórficos}. Métodos genéricos são
também chamados {\em polimórficos}. O termo tem origem no Grego, onde 
significa ``que tem muitas formas''. Para aplicar um método polimórfico tal como 
\code{isPrefix}, passamos parâmetros tipo, bem como parâmetros valor para ele. 
Por exemplo,  

\begin{lstlisting}
val s1 = new EmptyStack[String].push("abc")
val s2 = new EmptyStack[String].push("abx").push(s1.top)
println(isPrefix[String](s1, s2))
\end{lstlisting}


\paragraph{Inferência de Tipos Local}
Passar parâmetros de tipo tais como \code{[Int]} ou \code{[String]} o
tempo todo pode tornar-se enfadonho em aplicações onde funções 
genéricas são muito utilizadas. Frequentemente, a informação dentro
de um parâmetro de tipo é redundante, porque o parâmetro tipo correto
pode também ser determinado pela inspeção dos parâmetros valores da 
função ou do tipo esperado do resultado. Tomando a expressão 
\code{isPrefix[String](s1, s2)} como um exemplo, sabemos que seus
parâmetros valor são ambos do tipo \code{Stack[String]}, portanto 
podemos deduzir que o parâmetro tipo deve ser \code{String}. Scala 
tem um poderoso mecanismo de inferência que nos permite omitir 
parâmetros tipo para funções polimórficas e construtores em 
situações como esta. No exemplo acima, poderíamos ter escrito
\code{isPrefix(s1, s2)} e o tipo do argumento omitido \code{[String]}
seria inserido pelo mecanismo de inferência de tipos.

\section{Parâmetros Tipo Ligados}

Agora que sabemos como criar classes genéricas é natural generalizarmos 
algumas das classes escritas anteriormente. Por exemplo, a classe \code{IntSet}
poderia ser generalizada para conjuntos com tipos arbitrários de elementos.
Vamos tentar. A classe abstrata para conjuntos genéricos é facilmente escrita.

\begin{lstlisting}
abstract class Set[A] {
  def incl(x: A): Set[A]
  def contains(x: A): Boolean
}
\end{lstlisting}
Entretanto, se ainda quisermos implementar conjuntos como árvores binárias 
de busca, encontraremos um problema. Os métodos \code{contains} e \code{incl}, 
ambos comparam elementos usando métodos \code{<} e \code{>}. Para \code{IntSet}
isto está OK, pois o tipo \code{Int} tem estes dois métodos. Mas para um 
tipo arbitrário de parâmetro \code{a}, não podemos garantir isso. Logo, a 
implementação anterior de, digamos, \code{contains} levará a um erro de compilação.

\begin{lstlisting}
  def contains(x: Int): Boolean =
    if (x < elem) left contains x
          ^ < $\mbox{\sl not a member of type}$ A.
\end{lstlisting}

Um modo de resolver o problema é restringir os tipos legais que podem ser
substituídos pelo tipo \code{A} àqueles que contenham os métodos \code{<} e 
\code{>} do tipos corretos. Na biblioteca de classes padrão do Scala há 
o trait \code{Ordered[A]} que representa valores que podem ser comparados (via \code{<}
e \code{>}) a valores do tipo \code{A}. Esse trait é definido como segue:

\begin{lstlisting}
/** A class for totally ordered data. */
trait Ordered[A] {

  /** Result of comparing `this' with operand `that'.
   *  returns `x' where
   *  x < 0    iff    this < that
   *  x == 0   iff    this == that
   *  x > 0    iff    this > that
   */
  def compare(that: A): Int

  def <  (that: A): Boolean = (this compare that) <  0
  def >  (that: A): Boolean = (this compare that) >  0
  def <= (that: A): Boolean = (this compare that) <= 0
  def >= (that: A): Boolean = (this compare that) >= 0
  def compareTo(that: A): Int = compare(that)
}
\end{lstlisting}
Podemos forçar a compatibilidade de um tipo demandando que esse tipo seja
subtipo de \code{Ordered}. Isto é feito dando um limite superior ao 
parâmetro tipo de \code{Set}:

\begin{lstlisting}
trait Set[A <: Ordered[A]] {
  def incl(x: A): Set[A]
  def contains(x: A): Boolean
}
\end{lstlisting}
A declaração de parâmetro \code{A <: Ordered[A]} introduz \code{A} como um 
parâmetro tipo que deve ser um subtipo de \code{Ordered[A]}, ou seja, seus 
valores devem ser comparáveis a valores de mesmo tipo.

Com esta restrição, podemos agora implementar o restante da abstração genérica 
de conjunto como fizemos anteriormente no caso de \code{IntSet}. 

\begin{lstlisting}
class EmptySet[A <: Ordered[A]] extends Set[A] {
  def contains(x: A): Boolean = false
  def incl(x: A): Set[A] = new NonEmptySet(x, new EmptySet[A], new EmptySet[A])
}
\end{lstlisting}

\begin{lstlisting}
class NonEmptySet[A <: Ordered[A]]
        (elem: A, left: Set[A], right: Set[A]) extends Set[A] {
  def contains(x: A): Boolean =
    if (x < elem) left contains x
    else if (x > elem) right contains x
    else true
  def incl(x: A): Set[A] =
    if (x < elem) new NonEmptySet(elem, left incl x, right)
    else if (x > elem) new NonEmptySet(elem, left, right incl x)
    else this
}
\end{lstlisting}

Observe que deixamos de fora o tipo argumento na criações dos objetos 
\code{new NonEmptySet(...)}. Do mesmo modo que para métodos polimórficos, 
tipos de argumentos faltantes nas chamadas de contrutores são inferidos a 
partir do valor dos argumentos e/ou o tipo esperado do resultado. 

Aqui está um exemplo que usa a abstração genérica de conjunto. Vamos primeiro 
criar uma subclasse de \lstinline@Ordered@, como esta:

\begin{lstlisting}
case class Num(value: Double) extends Ordered[Num] {
  def compare(that: Num): Int =
    if (this.value < that.value) -1
    else if (this.value > that.value) 1
    else 0
}
\end{lstlisting}
Então:
\begin{lstlisting}
val s = new EmptySet[Num].incl(Num(1.0)).incl(Num(2.0))
s.contains(Num(1.5))
\end{lstlisting}
Isto está OK, pois o tipo \code{Num} implementa o trait \code{Ordered[Num]}.
Entretanto, o exemplo seguinte está errado. 
\begin{lstlisting}
val s = new EmptySet[java.io.File]
                    ^ java.io.File $\mbox{\sl does not conform to type}$
                      $\mbox{\sl parameter bound}$ Ordered[java.io.File].
\end{lstlisting}

Um problema com ligações para parâmetros tipo é que elas requerem antecipação:
se não declaramos \lstinline@Num@ uma subclasse de\lstinline@Ordered@, 
não estaremos aptos a usar elementos  \lstinline@Num@ dentro dos conjuntos.
A partir do mesmo token, tipos herdados do Java, tais como \lstinline@Int@, 
\lstinline@Double@, ou \lstinline@String@ não são subclasses de  \lstinline@Ordered@,
portanto valores destes tipos não podem ser usados como elementos de conjuntos.

Um desenho mais flexível, que admite elementos destes tipos, usam {\em ligações de visão} 
ao invés de ligações plenas a tipos como temos visto. A única mudança que isto
no leva no exemplo abaixo está nos parâmetros tipo:

\begin{lstlisting}
trait Set[A <% Ordered[A]] ...
class EmptySet[A <% Ordered[A]] ...
class NonEmptySet[A <% Ordered[A]] ...
\end{lstlisting}
Ligações visão \lstinline@<%@ são mais fracas que ligações plenas \verb@<:@:
Uma ligação visão da cláusula do tipo parâmetro \lstinline@[A <% T]@ somente 
especifica que o tipo ligado \lstinline@A@ deve ser {\em convertido} ao tipo
ligado \lstinline@T@, usando uma conversão implícita.

A biblioteca Scala predefine conversões implícitas para vários tipos, incluindo
os tipos primitivos e \lstinline@String@. Entretanto, o redesenho da abstração conjunto 
pode ser, do mesmo modo,  instanciada com estes tipos. Mais explicações sobre 
conversões implicitas e ligações visão são dadas na Seção~\ref{sec:implicits}.

\section{Anotações de Variância}\label{sec:first-arrays}

A combinação de tipos parâmetros e subtipos levantam algumas questões interessantes.
Por exemplo, \code{Stack[String]} deve ser um subtipo de \code{Stack[AnyRef]}? 
Intuitivamente, isto parece OK, pois uma pilha de \code{String}s é um caso 
especial de uma pilha de \code{AnyRef}s. Mais genericamente, se \code{T} é um
subtipo do tipo \code{S}, então, \code{Stack[T]} deve ser um subtipo de 
\code{Stack[S]}. Essa propriedade é chamada subtipificação {\em co-variante}.

Em Scala, tipos genéricos tem por padrão subtipificação não variante. Ou seja, 
com \code{Stack} definido conforme acima, pilhas com tipos de elementos diferentes
nunca estarão numa relação de subtipo. Entretanto, podemos forçar a subtipificação 
co-variante das pilhas mudando a primeira linha da definição da classe \code{Stack}
como segue.

\begin{lstlisting}
class Stack[+A] {
\end{lstlisting}
Prefixando um parâmetro tipo formal com um \code{+} indica que aquela 
subtipificação é covariante naquele parâmetro. Além do \code{+}, há também um
prefixo \code{-} que indica subtipificação contra-variante. Se \code{Stack}
foi definida \code{class Stack[-A] ...}, então \code{T}, um subtipo do tipo
\code{S}, poderia implicar que \code{Stack[S]} é um subtipo de \code{Stack[T]}
(o que no caso de pilhas seria um tanto quanto surpreendente!). 

Em um mundo puramente funcional, todos os tipos podem ser covariantes. Entretanto, 
a situação muda quando introduzimos dados mutantes. Considere o caso de vetores 
em Java ou .NET. Tais vetores são representados em Scala por uma classe genérica 
\code{Array}. Aqui está uma definição parcial desta classe.
\begin{lstlisting}
class Array[A] {
  def apply(index: Int): A
  def update(index: Int, elem: A)
}
\end{lstlisting}

A classe acima define o modo que vetores em Scala são vistos a partir de programas 
Scala do usuário. O compilador Scala mapeará esta abstração aos vetores subjacentes
do sistema hospedeiro sempre que possível.

Em Java, vetores são, de fato, covariantes; ou seja, para os tipos referenciados \code{T} e 
\code{S}, se \code{T} é um subtipo de \code{S}, então \code{Array[T]} é um subtipo de 
\code{Array[S]}. Isso pode parecer natural, mas leva a problemas de segurança que requerem
checagem especial em tempo de execução. Aqui está um exemplo: 

\begin{lstlisting}
val x = new Array[String](1)
val y: Array[Any] = x
y(0) = new Rational(1, 2)  // isto \'{e} syntactic sugar para
                           // y.update(0, new Rational(1, 2))
\end{lstlisting}
Na primeira linha, um novo vetor de strings é criado. Na segunda linha, 
este vetor é ligado a uma variável \code{y}, de tipo \code{Array[Any]}. 
Assumindo vetores como covariantes, isto está OK, pois \code{Array[String]}
é um subtipo de \code{Array[Any]}. Finalmente, na última linha, um número 
racional é guardado no vetor. Isso também está OK, pois o tipo \code{Rational} é 
um subtipo do tipo do elemento \code{Any} do vetor \code{y}. Acabamos por 
guardar um número racional em um vetor de strings, o que claramente viola
a integridade do tipo.

Java resolve este problema introduzindo checagem em tempo de execução na 
terceira linha que testa se o elemento guardado é compatível com o tipo
de elemento para o qual o vetor foi criado. Vimos no exemplo que este 
tipo de elemento não é necessariamente o tipo estático de elemento do 
vetor que está sendo atualizado. Se o teste falhar, é dado um 
\code{ArrayStoreException}.

Ao invés disto, Scala resolve este problema estáticamente, rejeitando a
segunda linha em tempo de compilação, porque vetores em Scala tem 
subtipificação não variante. Isso nos leva a questão de como o 
compilador Scala verifica que anotações de variância são corretas.
Se simplesmente declararmos vetores como covariantes, como detectar
este potencial problema?

Scala usa uma aproximação conservadora para verificar a integridade de
anotações de variância. Um parâmetro tipo covariante de uma classe pode 
somente aparecer em posições covariantes dentro da classe. Apesar de
posições covariantes serem tipos de valores na classe, o tipo resultante
dos métodos na classe, e tipos argumentos para outros tipos covariantes. 
Não covariantes são tipos de parâmetros formais de métodos. Logo, a seguinte 
definição de classe seria rejeitada
\begin{lstlisting}
class Array[+A] {
  def apply(index: Int): A
  def update(index: Int, elem: A)
                               ^ $\mbox{\sl covariant type parameter}$ A
                                 $\mbox{\sl appears in contravariant position.}$
}
\end{lstlisting}

Até aqui tudo bem. Intuitivamente, o compilador estava correto rejeitando o 
procedimento \code{update} na classe covariante, porque \code{update} potencialmente 
muda estado, e portanto mina a integridade da subtipificação covariante.

Entretanto, há também métodos que não mudam estado, mas onde um parâmetro tipo ainda
aparece contra-variantemente. Como exemplo temos o \code{push} no tipo \code{Stack}. 
Novamente o compilador Scala rejeitará a definição deste método para pilhas covariantes.


\begin{lstlisting}
class Stack[+A] {
  def push(x: A): Stack[A] =
              ^ $\mbox{\sl covariant type parameter}$ A
                $\mbox{\sl appears in contravariant position.}$
\end{lstlisting}

Isto é uma pena, porque diferente de vetores, pilhas são estruturas de dados 
puramente funcionais e portanto devem habilitar a subtipificação covariante. 
Entretanto,  há um modo de resolver o problema usando um método polimórfico
com uma baixa ligação para tipos de parâmetros. 

\section{Lower Bounds}

Nós temos visto ligações fortes para tipos de parâmetros. Em uma declaração 
de tipo parâmetro tal como \code{T <: U}, o tipo parâmetro \code{T} é restrito
ao intervalo somente sobre subtipos do tipo \code{U}. Simetrico a isso estão as 
ligações fracas em Scala. Em uma declaração de tipo parâmetro \code{T >: S}, o 
tipo parâmetro \code{T} está restrito ao intervalo somente sobre {\em supertipos} 
do tipo \code{S}. (Pode-se também combinar ligações fracas e fortes, como em \code{T >: S <: U}.) 

Usando ligações fracas, podemos generalizar o método \code{push} dentro de \code{Stack}
como segue.

\begin{lstlisting}
class Stack[+A] {
  def push[B >: A](x: B): Stack[B] = new NonEmptyStack(x, this)
\end{lstlisting}

Tecnicamente isso resolve nosso problema de variância, pois agora o tipo parâmetro 
\code{A} não mais aparece como um tipo parâmetro do método \code{push}. Ao invés, 
aparece como ligação fraca para um outro tipo parâmetro de um método, que é 
classificado como uma posição covariante. Logo, o compilador Scala aceita
a nova definição de \code{push}. 

De fato, não apenas resolvemos o problema técnico da variância, mas também 
generalizamos a definição de \code{push}. Antes, só podíamos efetuar push em
elementos com tipos que estivessem em conformidade com o tipo do elemento
declarado da pilha. Agora, também podemos efetuar push sobre elementos de um
supertipo deste tipo, mas o tipo da pilha retornada será alterado de acordo. 
Por exemplo, podemos agora efetuar push de \code{AnyRef} sobre uma pilha de 
\code{String}s, mas a pilha resultante será uma pilha de \code{AnyRef}s ao 
invés de uma pilha de \code{String}s! 

Em resumo, não devemos hesitar em adicionar anotações de variância às estruturas de dados, 
pois isso enriquece naturalmente relacionamentos de subtipificação. O compilador detectará
problemas de integridade potenciais. Mesmo se a aproximação do compilador for muito 
conservadora, frequentemente sugerirá uma generalização útil do método contestado.

\section{Tipos Minimais}

Scala não nos permite parametrizar objetos com tipos. Este é o motivo 
pelo qual originalmente definimos uma classe genérica \code{EmptyStack[A]}, 
ainda que um único valor denotando pilhas vazias de tipos arbitrários o 
fizesse. Para pilhas covariantes, entretanto, pode-se usar o seguinte idioma:

\begin{lstlisting}
object EmptyStack extends Stack[Nothing] { ... }
\end{lstlisting}

O tipo base \code{Nothing} não contém valor, portanto o tipo \code{Stack[Nothing]}
expressa o fato que uma \code{EmptyStack} não contém elementos. Além disso, 
\code{Nothing} é um subtipo de todos os outros tipos. Consequentemente, para 
pilhas covariantes, \code{Stack[Nothing]} é um subtipo de \code{Stack[T]}, para 
qualquer outro tipo \code{T}. Isso torna possível usar um único objeto pilha vazia
no código do usuário. Por exemplo:

\begin{lstlisting}
val s = EmptyStack.push("abc").push(new AnyRef())
\end{lstlisting}
Vamos analisar a atribuição de tipo para esta expressão em detalhes. 
O objeto \code{EmptyStack} é do tipo \code{Stack[Nothing]}, o qual tem um método 
\begin{lstlisting}
push[B >: Nothing](elem: B): Stack[B] .
\end{lstlisting}
A inferência local de tipos determinará que o tipo parâmetro \code{B} deve ser
instanciado para \code{String} na aplicação \code{EmptyStack.push("abc")}. O tipo resultado
desta aplicação é, consequentemente, \code{Stack[String]}, que por sua vez tem um método  
\begin{lstlisting}
push[B >: String](elem: B): Stack[B] .
\end{lstlisting}

A parte final da definição do valor acima é a aplicação deste método a \code{new AnyRef()}.
A inferência local de tipos determinará que o tipo parâmetro \code{b} deve desta vez
ser instanciado para \code{AnyRef}, com tipo resultado \code{Stack[AnyRef]}. 
Consequentemente, o tipo atribuído ao valor \code{s} é \code{Stack[AnyRef]}.

Além de \code{Nothing}, que é um subtipo para cada outro tipo, há também o tipo \code{Null},
que é um subtipo de \code{scala.AnyRef}, e de cada classe derivada dele. O literal \code{Null}
em Scala é o único valor deste tipo. Isto torna \code{null} compatível com cada tipo referência, 
mas não com um valor de tipo tal como \code{Int}.  

Concluímos esta seção com a definição completa melhorada de pilhas. Pilhas tem agora subtipificação
covariante, o método \code{push} foi generalizado, e a pilha vazia é denotada por um único objeto.
\begin{lstlisting}
abstract class Stack[+A] {
  def push[B >: A](x: B): Stack[B] = new NonEmptyStack(x, this)
  def isEmpty: Boolean
  def top: A
  def pop: Stack[A]
}
object EmptyStack extends Stack[Nothing] {
  def isEmpty = true
  def top = error("EmptyStack.top")
  def pop = error("EmptyStack.pop")
}
class NonEmptyStack[+A](elem: A, rest: Stack[A]) extends Stack[A] {
  def isEmpty = false
  def top = elem
  def pop = rest
}
\end{lstlisting}

Muitas classes na biblioteca Scala são genéricas. Agora apresentaremos duas
comumente usadas famílias de classes genéricas, tuplas e funções. A discussão 
de uma outra classe bem comum, listas, é postergada para o próximo capítulo.

\section{Tuplas}

Vez por outra, uma função precisa retornar mais de um resultado. Por exemplo, suponha a 
função \code{divmod} que retorna o quociente inteiro e o resto de dois argumentos inteiros dados.
De fato, pode-se definir uma classe para pegar os dois resultados de \code{divmod}, como em:
\begin{lstlisting}
case class TwoInts(first: Int, second: Int)
def divmod(x: Int, y: Int): TwoInts = new TwoInts(x / y, x % y)
\end{lstlisting}
Entretanto, ter que definir uma nova classe para cada possível par de tipos de resultados é 
bastante tedioso. Em Scala pode-se usar, ao invés, uma classe genérica \lstinline@Tuple$2$@,
que é definida como segue:   
\begin{lstlisting}
package scala
case class Tuple2[A, B](_1: A, _2: B)
\end{lstlisting}
Com \code{Tuple2}, o método \code{divmod} pode ser escrito como segue.
\begin{lstlisting}
def divmod(x: Int, y: Int) = new Tuple2[Int, Int](x / y, x % y)
\end{lstlisting}

Como sempre, parâmetros tipos para construtores podem ser omitidos se forem 
dedutíveis a partir dos valores dos argumentos. Há também classes tuplas para 
cada outro número de elementos (a implementação Scala atual limita isto a tuplas
de algum número razoável de elementos).  
\comment{
Também, Scala define um alias \code{Pair} para \code{Tuple2} (bem como com \code{Triple}
para \code{Tuple3}). Com tais convenções, \code{divmod} pode, equivalentemente ser escrita
como segue. 
\begin{lstlisting}
def divmod(x: Int, y: Int): Pair(Int, Int) = Pair(x / y, x % y)
\end{lstlisting}
}

Como os elementos de tuplas são acessados? Como tuplas são classes case, há duas possibilidades. 
Pode-se ou acessar os campos da tupla usando os nomes dos parâmetros dos construtores 
\lstinline@_$i$@, como no seguinte exemplo:
\begin{lstlisting}
val xy = divmod(x, y)
println("quotient: " + xy._1 + ", rest: " + xy._2)
\end{lstlisting}
Ou usa-se casamento de padrões sobre tuplas, como no seguinte exemplo: 
\begin{lstlisting}
divmod(x, y) match {
  case Tuple2(n, d) =>
    println("quotient: " + n + ", rest: " + d)
}
\end{lstlisting}
Observe que tipos parâmetros nunca são usados nos padrões; seria ilegal escrever 
case \code{Tuple2[Int, Int](n, d)}.

Tuplas são tão convenientes que Scala define uma sintaxe especial para elas. 
Para formar uma tupla com $n$ elementos $x_1 \commadots x_n$ pode-se escrever
$(x_1 \commadots x_n)$. Isto é equivalente a \lstinline@Tuple$n$($x_1 \commadots x_n$)@.
A sintaxe  $(...)$ funciona de modo equivalente para tipos e para padrões. Com esta
sintaxe para tuplas, o exemplo \lstinline@divmod@ é escrito como segue:
\begin{lstlisting}
def divmod(x: Int, y: Int): (Int, Int) = (x / y, x % y)
divmod(x, y) match {
  case (n, d) => println("quotient: " + n + ", rest: " + d)
}
\end{lstlisting}
\section{Funções}\label{sec:functions}

Scala é uma linguagem funcional na qual funções são valores de primeira classe. 
Scala é também uma linguagem orientada a objetos na qual cada valor é um objeto.  
Segue daí que funções são objetos em Scala. Por exemplo, uma função do tipo 
\code{String} para o tipo \code{Int} é representada como uma instância do trait
\code{Funciton1[String, Int]}. O trait \code{Function1} é definido como segue.

\begin{lstlisting}
package scala
trait Function1[-A, +B] {
  def apply(x: A): B
}
\end{lstlisting}

Ao lado de \code{Funciton1}, há também definições para funções de todas as outras 
aridades (a implementação corrente implementa isto somente até um limite razoável).
Ou seja, há uma definição para cada possível número de parâmetros de funções. Sintaxe para 
tipos de funções em Scala ~\lstinline@$(T_1 \commadots T_n)$ => $S$@~ é apenas uma abreviatura 
para o tipo parametrizado  ~\lstinline@Function$n$[$T_1 \commadots T_n, S$]@~.

Scala usa a mesma sintaxe $f(x)$ para aplicações de funções, não importa se 
$f$ é um método ou um objeto função. Isto é possível pela seguinte convenção:
Uma aplicação de função $f(x)$ onde $f$ é um objeto (em contraste com um método)
é tomado para ser um atalho para \lstinline@$f$.apply($x$)@. Consequentemente, 
o método \code{apply} de um tipo de função é inserido automaticamente onde isso 
é necessário.

Isso justifica o porquê definimos subscritos de vetores na Seção~\ref{sec:first-arrays} 
através de um método \code{apply}. Para cada vetor \code{a}, a operação subscritora \code{a(i)} 
é tomada como um atalho para \code{a.apply(i)}.

Funções são exemplos em que uma declaração de um parâmetro tipo 
contra-variante é útil. Por exemplo, considere o seguinte código:

\begin{lstlisting}
val f: (AnyRef => Int)  =  x => x.hashCode()
val g: (String => Int)  =  f
g("abc")
\end{lstlisting}

É correto ligar o valor \code{g} de tipo \code{String => Int} a \code{f}, que 
é do tipo \code{AnyRef => Int}. De fato, tudo o que se pode fazer com uma 
função do tipo \code{String => Int} é passar-lhe uma string para se obter um inteiro.
Isso demonstra que subtipificar funções é contra-variante nos tipos dos argumentos, enquanto 
é covariante no tipo do seu resultado. Em resumo, $S \Rightarrow T$ é um subtipo de $S' \Rightarrow T'$,
desde que  $S'$ seja um subtipo de $S$ e $T$ seja um subtipo de $T'$.

\example Considere o código Scala 
\begin{lstlisting}
val plus1: (Int => Int)  =  (x: Int) => x + 1
plus1(2)
\end{lstlisting}
Isso é expandido no seguinte código objeto.
\begin{lstlisting}
val plus1: Function1[Int, Int] = new Function1[Int, Int] {
  def apply(x: Int): Int = x + 1
}
plus1.apply(2)
\end{lstlisting}
Aqui, a criação do objeto \lstinline@new Function1[Int, Int]{ ... }@
representa uma instância de uma {\em classe anônima}. Combina a criação 
de um novo objeto \code{Function1} com uma implementação do método \code{apply}
(que é abstrato dentro de \code{Function1}). Equivalentemente, mas mais
prolixo, podería-se usar uma classe local:
\begin{lstlisting}
val plus1: Function1[Int, Int] = {
  class Local extends Function1[Int, Int] {
    def apply(x: Int): Int = x + 1
  }
  new Local: Function1[Int, Int]
}
plus1.apply(2)
\end{lstlisting}

\chapter{Listas}

Listas são uma importante estrutura de dados em muitos programas Scala. Uma 
lista contendo os elementos \code{x}$_1$, \ldots, \code{x}$_n$ é escrita
\code{List(x}$_1$\code{, ..., x}$_n$\code{)}. Alguns exemplos:

\begin{lstlisting}
val fruit = List("apples", "oranges", "pears")
val nums  = List(1, 2, 3, 4)
val diag3 = List(List(1, 0, 0), List(0, 1, 0), List(0, 0, 1))
val empty = List()
\end{lstlisting}

Listas são similares a vetores em linguagens tais como C ou Java, mas há 
também três importantes diferenças. Primeiro, listas são imutáveis. Ou seja, 
elementos de uma lista não podem ser mudados por meio de atribuição. Segundo, 
listas tem uma estrutura recursiva, enquanto vetores são triviais. Terceiro, 
em geral, listas suportam um conjunto muito mais rico de operações que vetores. 
 
\section{Usando Listas}

\paragraph{O tipo lista}

Do mesmo modo que com vetores, listas são {\em homogêneas}. Ou seja, os elementos 
de uma lista têm todos o mesmo tipo. O tipo de uma lista com elementos de tipo 
\code{T} é escrito \code{List[T]} (compare com \code{T[]} em Java).

\begin{lstlisting}
val fruit: List[String]    = List("apples", "oranges", "pears")
val nums : List[Int]       = List(1, 2, 3, 4)
val diag3: List[List[Int]] = List(List(1, 0, 0), List(0, 1, 0), List(0, 0, 1))
val empty: List[Int]       = List()
\end{lstlisting}

\paragraph{Construtores de listas}
Todas as listas são construídas a partir de dois construtores fundamentais, \code{Nil} e 
\code{::} (lê-se ``cons''). \code{Nil} representa uma lista vazia. O operador infixo 
\code{::} expressa a extensão da lista. Ou seja, \code{x :: xs} denota uma lista 
cujo primeiro elemento é \code{x}, e que é seguido pela (os elementos da) lista \code{xs}.
Consequentemente, os valores da lista acima podem também ter sido definidos como segue 
(de fato essa definição prévia é apenas um facilitador sintático para as definições abaixo).
\begin{lstlisting}
val fruit  = "apples" :: ("oranges" :: ("pears" :: Nil))
val nums   = 1 :: (2 :: (3 :: (4 :: Nil)))
val diag3  = (1 :: (0 :: (0 :: Nil))) ::
             (0 :: (1 :: (0 :: Nil))) ::
             (0 :: (0 :: (1 :: Nil))) :: Nil
val empty  = Nil
\end{lstlisting}
A operação `\code{::}' é associativa à direita: \code{A :: B :: C} é 
interpretada como \code{A :: (B :: C)}. Por essa razão, podemos retirar os 
parênteses das definições acima. Por exemplo, podemos escrever de modo resumido
\begin{lstlisting}
val nums  =  1 :: 2 :: 3 :: 4 :: Nil
\end{lstlisting}

\paragraph{Operações básicas sobre listas}
Todas as operações sobre listas podem ser expressas em termos das três a seguir:

\begin{tabular}{ll}
\code{head}  & retorna o primeiro elemento de uma lista,\\
\code{tail}  & retorna a lista que consiste de todos os elementos exceto o\\
& primeiro elemento,\\
\code{isEmpty} & returns \code{true} se e só se a lista for vazia.
\end{tabular}

Estas operações são definidas como métodos de objetos listas. Portanto as invocamos 
escolhendo da lista aqueles que sofrerão a operação. Exemplos: 

\begin{lstlisting}
empty.isEmpty   = true
fruit.isEmpty   = false
fruit.head      = "apples"
fruit.tail.head = "oranges"
diag3.head      = List(1, 0, 0)
\end{lstlisting}
Os métodos \code{head} e \code{tail} são definidos somente para listas não vazias.
Quando selecionados para uma lista vazia, eles lançam uma exceção.

Como um exemplo de como listas podem ser processadas, considere ordenar os elementos 
de uma lista de números em ordem crescente. Um modo simples de fazer isso é usar o 
{\em insertion sort}, que trabalha da seguinte maneira: Para ordenar uma lista não 
vazia com primeiro elemento \code{x} e resto \code{xs}, ordene o restante \code{xs} e 
insira o elemento \code{x} na posição correta do resultado. Ordenar uma lista vazia dará
uma lista vazia. Em Scala temos o código:
\begin{lstlisting}
def isort(xs: List[Int]): List[Int] =
  if (xs.isEmpty) Nil
  else insert(xs.head, isort(xs.tail))
\end{lstlisting}

\begin{exercise} Escreva a função faltante \code{insert}.
\end{exercise}

\paragraph{Listas e padrões} De fato, \code{::} é definido como uma 
classe case na biblioteca padrão Scala. Consequentemente, é possível 
decompor listas através de casamento de padrões, usando padrões compostos
a partir dos construtores  \code{Nil} e \code{::}. Por exemplo, \code{isort}
pode ser escrito aternativamente como segue.
\begin{lstlisting}
def isort(xs: List[Int]): List[Int] = xs match {
  case List() => List()
  case x :: xs1 => insert(x, isort(xs1))
}
\end{lstlisting}
onde
\begin{lstlisting}
def insert(x: Int, xs: List[Int]): List[Int] = xs match {
  case List() => List(x)
  case y :: ys => if (x <= y) x :: xs else y :: insert(x, ys)
}
\end{lstlisting}

\section{Definição da classe List I: Métodos de Primeira Ordem}
\label{sec:list-first-order}

Listas não são construídas em Scala; elas são definidas por uma classe abstrata
\code{List}, que vem com duas subclasses para \code{::} e \code{Nil}. A seguir
apresentaremos um tour através da classe \code{List}.

\begin{lstlisting}
package scala
abstract class List[+A] {
\end{lstlisting}

\code{List} é uma classe abstrata, logo não pode-se definir elementos 
chamando o construtor de \code{List} vazia (ou seja, através de \code{new List}).
A classe tem uma tipo parâmetro \code{a}. É covariante nesse parâmetro, o que 
significa que \code{List[S] <: List[T]} para todos os tipos \code{S} e \code{T} tal que 
\code{S <: T}. A classe está no pacote \code{scala}. Este pacote contém as mais 
importantes classes Scala. \code{List} define um número de métodos, que são explicados a seguir.

\paragraph{Decompondo listas}
Primeiro, há os três métodos básicos \code{isEmpty}, \code{head}, \code{tail}.
Suas implementações em termos de casamento de padrões são diretas:
\begin{lstlisting}
def isEmpty: Boolean = this match {
  case Nil => true
  case x :: xs => false
}
def head: A = this match {
  case Nil => error("Nil.head")
  case x :: xs => x
}
def tail: List[A] = this match {
  case Nil => error("Nil.tail")
  case x :: xs => xs
}
\end{lstlisting}

A próxima função computa o tamanho de uma lista.
\begin{lstlisting}
def length: Int = this match {
  case Nil => 0
  case x :: xs => 1 + xs.length
}
\end{lstlisting}
\begin{exercise} Escreva uma versão recursiva de cauda de \code{length}.
\end{exercise}

As próximas duas funções são o complemento para \code{head} e \code{tail}.
\begin{lstlisting}
def last: A
def init: List[A]
\end{lstlisting}

\code{xs.last} retorna o último elemento da lista \code{xs}, enquanto 
\code{xs.init} retorna todos os elementos de \code{xs} exceto o último.
Ambas as funções tem de atravessar toda a lista, e são, portanto, menos 
eficientes que seus análogos \code{head} e \code{tail}.
Aqui está a implementação de \code{last}.
\begin{lstlisting}
def last: A = this match {
  case Nil      => error("Nil.last")
  case x :: Nil => x
  case x :: xs  => xs.last
}
\end{lstlisting}
A implementação de \code{init} é análoga.

As próximas três funções retornam um prefixo da lista, ou um sufixo, ou ambos.
\begin{lstlisting}
def take(n: Int): List[A] =
  if (n == 0 || isEmpty) Nil else head :: tail.take(n-1)

def drop(n: Int): List[A] =
  if (n == 0 || isEmpty) this else tail.drop(n-1)

def split(n: Int): (List[A], List[A]) = (take(n), drop(n))
\end{lstlisting}
\code{(xs take n)} retorna os primeiros \code{n} elementos da lista 
\code{xs}, ou a lista inteira, caso seu tamanho seja menor que \code{n}.
\code{(xs drop n)} retorna todos os elementos de \code{xs} exceto os 
\code{n} primeiros. Finalmente, \code{(xs split n)} retorna um par
consistindo das listas resultantes de \code{xs take n} e \code{xs drop n}.

A próxima função retorna um elemento de uma dada posição na lista.
É, portanto, análoga ao subscrito de vetor. Índices começam em 0. 
\begin{lstlisting}
def apply(n: Int): A = drop(n).head
\end{lstlisting}
O método \code{apply} tem um significado especial em Scala. Um objeto com 
um método \code{apply} pode ser aplicado a argumentos como se fosse uma função.
Por exemplo, para pegar o terceiro elemento de uma lista \code{xs}, pode-se 
escrever ou \code{xs.apply(3)} ou \code{xs(3)}---a última expressão expande na primeira.

Com \code{take} e \code{drop}, podemos extrair sublistas consistindo de elementos 
consecutivos da lista original. Para extrair a sublista $xs_m \commadots xs_{n-1}$ da
lista \code{xs}, use:

\begin{lstlisting}
xs.drop(m).take(n - m)
\end{lstlisting}

\paragraph{Zipando listas} A próxima função combina duas listas em uma lista de pares.
Dadas duas listas
\begin{lstlisting}
xs = List(x$_1$, ..., x$_n$)   $\mbox{\rm, and}$
ys = List(y$_1$, ..., y$_n$)   ,
\end{lstlisting}

\code{xs zip ys} constrói a lista \lstinline@List((x$_1$, y$_1$), ..., (x$_n$, y$_n$))@.
Se as duas listas tiverem tamanhos diferentes, a maior das duas é truncada. Aqui está 
a definição de \code{zip}---observe que trata-se de um método polimórfico. 

\begin{lstlisting}
def zip[B](that: List[B]): List[(a,b)] =
  if (this.isEmpty || that.isEmpty) Nil
  else (this.head, that.head) :: (this.tail zip that.tail)
\end{lstlisting}

\paragraph{Consing listas.}

Como qualquer outro operador infixo, \code{::} também é implementado como um 
método de um objeto. Neste caso, o objeto é a lista que é estendida. Isto é 
possível porque operadores terminados com um caracter `\code{:}' são tratados
de modo especial em Scala. Todos esses operadores são tratados como métodos 
de seus operandos direitos. Ou seja, 
\begin{lstlisting}
    x :: y = y.::(x)       $\mbox{\rm whereas}$       x + y = x.+(y)                  
\end{lstlisting}
Observe, entretanto, que operandos de uma operação binária são em cada caso
avaliados da esquerda para a direita. Logo, se \code{D} e \code{E} são 
expressões com possíveis efeitos colaterais, \code{D :: E} é traduzido para 
\lstinline@{val x = D; E.::(x)}@ de modo a manter a ordem esquerda-para-direita
da avaliação dos operandos.

Outra diferença entre operadores terminando com um `\code{:}' e outros 
operadores é concernente à associatividade. Operadores terminados com 
`\code{:}' são associativos à direita, enquanto outros operadores são 
associativos à esquerda. Isto é,
\begin{lstlisting}
    x :: y :: z = x :: (y :: z)   $\mbox{\rm whereas}$    x + y + z = (x + y) + z
\end{lstlisting}


A definição de \code{::} como um método na classe \code{List} é a seguinte:
\begin{lstlisting}
def ::[B >: A](x: B): List[B] = new scala.::(x, this)
\end{lstlisting}
Observe que \code{::} é definido para todos os elementos \code{x} de tipo
\code{B} e listas do tipo \code{List[A]} tais como o tipo \code{B} de \code{x} é 
um supertipo dos elementos da lista de tipo \code{A}. O resultado neste caso é 
uma lista de \code{B}s. Isto é expresso pelo tipo parâmetro \code{B} com ligação 
fraca \code{A} na assinatura de \code{::}.


\paragraph{Concatenando listas}
Uma operação similar a \code{::} é a concatenação de listas, escrita `\code{:::}'.
O resultado de \code{(xs ::: ys)} é uma lista consistindo de todos os elementos 
de \code{xs}, seguidos para todos os elementos de \code{ys}. Como termina em dois pontos, 
\code{:::} é associativo à direita e é considerado método de seu operando direito. Por isso,
\begin{lstlisting}
xs ::: ys ::: zs  =   xs ::: (ys ::: zs)
                  =   zs.:::(ys).:::(xs)
\end{lstlisting}
Aqui está a implementação do método \code{:::}:
\begin{lstlisting}
  def :::[B >: A](prefix: List[B]): List[B] = prefix match {
    case Nil => this
    case p :: ps => this.:::(ps).::(p)
  }
\end{lstlisting}

\paragraph{Invertendo listas} 
Outra operação útil é a inversão de lista. Há um método \code{reverse} em \code{List}
que tem esse efeito. Vamos tentar dar a implementação:
\begin{lstlisting}
def reverse[A](xs: List[A]): List[A] = xs match {
  case Nil => Nil
  case x :: xs => reverse(xs) ::: List(x)
}
\end{lstlisting}
Esta implementação tem a vantagem de ser mais simples, mas não é muito eficiente. 
Na verdade, uma concatenação é feita para cada elemento da lista. Concatenação de listas
leva tempo proporcional ao tamanho do seu primeiro operando. Consequentemente, a complexidade
de \code{reverse(xs)} é 
\[
n + (n - 1) + ... + 1 = n(n+1)/2
\]
onde $n$ é o tamanho de \code{xs}. Pode-se implementar \code{reverse} mais eficientemente? 
Veremos mais tarde que há uma outra implementação que tem complexidade linear.

\section{Exemplo: Merge sort}

O insertion sort apresentado anteriormente neste capítulo é simples de formular, mas também não 
é muito eficiente. Sua complexidade média é proporcional ao quadrado do tamanho de sua lista 
de entrata. Agora escreveremos um programa para ordenar os elementos de uma lista que é mais 
eficiente que o insertion sort. Um bom algoritmo para isso é {\em merge sort}, que trabalha 
do seguinte modo.

Primeiro, se a lista tem zero ou um elementos, já está ordenada, logo retornamos a lista sem 
modificações. Listas mais longas são divididas em duas sublistas, cada uma contendo por volta
de metade dos elementos da lista original. Cada sublista é ordenada através de uma chamada 
recursiva para a função de ordenação, e as duas listas ordenadas resultantes são então 
combinadas em uma operação merge. 

Para uma implementação geral do merge sort, ainda temos que especificar o tipo dos elementos da lista 
a ser ordenada, bem como a função a ser usada na comparação dos elementos. Obtemos uma função de 
generalidade maximal passando estes dois itens como parâmetros. Isto leva a seguinte implementação.
\begin{lstlisting}
def msort[A](less: (A, A) => Boolean)(xs: List[A]): List[A] = {
  def merge(xs1: List[A], xs2: List[A]): List[A] =
    if (xs1.isEmpty) xs2
    else if (xs2.isEmpty) xs1
    else if (less(xs1.head, xs2.head)) xs1.head :: merge(xs1.tail, xs2)
    else xs2.head :: merge(xs1, xs2.tail)
  val n = xs.length/2
  if (n == 0) xs
  else merge(msort(less)(xs take n), msort(less)(xs drop n))
}
\end{lstlisting}

A complexidade do \code{msort} é $O(N;log(N))$, onde $N$ é o tamanho da lista de entrada.
Para ver porque, observe que dividir uma lista em duas e intercalar as duas listas 
ordenadas leva tempo proporcional ao tamanho das listas argumentos. Cada chamada recursiva 
de \code{msort} reduz a metade o número de elementos na sua entrada, logo há $O(log(N))$
chamadas recursivas consecutivas, até que o caso base das listas de tamanho 1 seja 
alcançado. Entretanto, para listas mais longas, cada chamada gera duas outras chamadas. 
Somando tudo acima obtemos que a cada nível $O(log(N))$ de chamada, cada elemento da lista 
original toma parte em uma operação de divisão e em uma operação merge. Consequentemente, cada 
nível de chamada tem um custo proporcional total de $O(N)$. Como há $O(log(N))$ níveis de
chamada, obtemos um custo total de $O(N;log(N))$. Este custo não depende da distribuição 
inicial dos elementos na lista, portanto o pior caso tem o mesmo custo que o caso médio.
Isto torna o merge sort um algoritmo atraente para ordenação de listas. 

Aqui está um exemplo de como \code{msort} é usado.
\begin{lstlisting}
msort((x: Int, y: Int) => x < y)(List(5, 7, 1, 3))
\end{lstlisting}
A definição de \code{msort} está currificada para tornar sua especialização com funções de  
comparação. Por exemplo,
\begin{lstlisting}
val intSort = msort((x: Int, y: Int) => x < y)
val reverseSort = msort((x: Int, y: Int) => x > y)
\end{lstlisting}

\section{Definição da classe List II: Métodos de Alta Ordem}
Os exemplos encontrados até aqui mostram que funções sobre listas frequentemente 
tem estruturas similares. Podemos identificar vários padrões de computação sobre
listas, tais como:

\begin{itemize}
        \item transformar cada elemento de uma lista de algum modo.
        \item extrair de uma lista todos os elementos que satisfaçam uma critério.
        \item combinar os elementos de uma lista usando algum operador.
\end{itemize}
Linguagens de programação funcional habilitam programadores a escrever funções genéricas
que implementam padrões como estes por meio de funções de alta ordem. Agora discutiremos
um conjunto comumente usado em funções de alta ordem, que são implementados como métodos 
dentro da classe \code{List}. 
\paragraph{Mapping sobre listas}
Um operação comum é transformar cada elemento de uma lista e então retornar a lista de
resultados. Por exemplo, para multiplicar cada elemento de uma lista por um dado fator.
\begin{lstlisting}
def scaleList(xs: List[Double], factor: Double): List[Double] = xs match {
  case Nil => xs
  case x :: xs1 => x * factor :: scaleList(xs1, factor)
}
\end{lstlisting}
Este padrão pode ser generalizado para o método \code{map} da classe \code{List}:
\begin{lstlisting}
abstract class List[A] { ...
  def map[B](f: A => B): List[B] = this match {
    case Nil => this
    case x :: xs => f(x) :: xs.map(f)
  }
\end{lstlisting}
Usando \code{map}, \code{scaleList} pode ser mais concisamente escrito como segue.
\begin{lstlisting}
def scaleList(xs: List[Double], factor: Double) =
  xs map (x => x * factor)
\end{lstlisting}

Como outro exemplo, considere o problema de retornar uma dada coluna de uma matriz 
que é representada como uma lista de linhas, onde cada linha é novamente uma lista. 
Isto é feito através da seguinte função \code{column}. 

\begin{lstlisting}
def column[A](xs: List[List[A]], index: Int): List[A] =
  xs map (row => row(index))
\end{lstlisting}

Um método similar a \code{map} é o método \code{foreach} que aplica uma dada função a todos 
os elementos de uma lista, mas não constrói uma lista de resultados. A função é assim aplicada
somente por seu efeito colateral. \code{foreach} é definido como segue. 
\begin{lstlisting}
  def foreach(f: A => Unit) {
    this match {
      case Nil => ()
      case x :: xs => f(x); xs.foreach(f)
    }
  }
\end{lstlisting}
Esta função pode ser usada para imprimir todos os elementos de uma lista, por exemplo:
\begin{lstlisting}
  xs foreach (x => println(x))
\end{lstlisting} 

\begin{exercise} 
Considere uma função que eleva ao quadrado todos os elementos de uma lista e retorna
uma lista com os resultados. Complete as duas definições a seguir de \code{squareList}.

\begin{lstlisting}
def squareList(xs: List[Int]): List[Int] = xs match {
  case List() => ??
  case y :: ys => ??
}
def squareList(xs: List[Int]): List[Int] =
  xs map ??
\end{lstlisting}
\end{exercise}

\paragraph{Filtrando Listas}

Outra operação comum seleciona de uma lista todos os elemento que satisfazem um dado 
critério. Por exemplo, para retornar uma lista de todos os elementos positivos de 
algumas listas dadas de inteiros:
\begin{lstlisting}
def posElems(xs: List[Int]): List[Int] = xs match {
  case Nil => xs
  case x :: xs1 => if (x > 0) x :: posElems(xs1) else posElems(xs1)
}
\end{lstlisting}
Este padrão é generalizado para o método \code{filter} da classe \code{List}:
\begin{lstlisting}
  def filter(p: A => Boolean): List[A] = this match {
    case Nil => this
    case x :: xs => if (p(x)) x :: xs.filter(p) else xs.filter(p)
  }
\end{lstlisting}
Usando \code{filter}, \code{posElems} pode ser mais concisamente escrito como segue.
\begin{lstlisting}
def posElems(xs: List[Int]): List[Int] =
  xs filter (x => x > 0)
\end{lstlisting}

Uma operação relacionada a filtering é testar se todos os elementos de uma lista satisfazem
uma dada condição. Dualmente, pode-se também estar interessado na questão se há um elemento 
em uma lista que satisfaz uma dada condição. Estas operações são incorporadas nas funções 
de alta ordem \code{forall} e \code{exists} da classe \code{List}.
\begin{lstlisting}
def forall(p: A => Boolean): Boolean =
  isEmpty || (p(head) && (tail forall p))
def exists(p: A => Boolean): Boolean =
  !isEmpty && (p(head) || (tail exists p))
\end{lstlisting}

Para ilustrar o uso de \code{forall}, considere a questão se um número é primo. Lembre que um
número $n$ é primo se puder ser dividido, sem resto, somente por um e por ele mesmo. A 
tradução mais direta desta definição testará se $n$ dividido por todos os números de $2$ até, mas 
excluindo, ele mesmo dá resto diferente de zero. Esta lista de números pode ser gerada usando uma 
função \code{List.range} que é definida no objeto \code{List} como segue. 
\begin{lstlisting}
package scala
object List { ...
  def range(from: Int, end: Int): List[Int] =
    if (from >= end) Nil else from :: range(from + 1, end)
\end{lstlisting}

Por exemplo, \code{List.range(2, n)} gera a lista de todos os inteiros de $2$ até, excluindo, $n$.
A função \code{isPrime} pode agora ser defida como segue. 
\begin{lstlisting}
def isPrime(n: Int) =
  List.range(2, n) forall (x => n % x != 0)
\end{lstlisting}
Vemos que a definição matemática de primalidade pode ser traduzida diretamente em código Scala.

Exercício: Defina \code{forall} e \code{exists} em termos de \code{filter}.

\paragraph{Desdobrando (folding) e Reduzindo Listas}
Uma outra operação comum é combinar os elementos de uma lista com algum operador. Por exemplo:
\begin{lstlisting}
sum(List(x$_1$, ..., x$_n$))       =  0 + x$_1$ + ... + x$_n$
product(List(x$_1$, ..., x$_n$))   =  1 * x$_1$ * ... * x$_n$
\end{lstlisting}

De fato, podemos implementar ambas as funções por meio de um esquema recursivo:
\begin{lstlisting}
def sum(xs: List[Int]): Int = xs match {
  case Nil => 0
  case y :: ys => y + sum(ys)
}
def product(xs: List[Int]): Int = xs match {
  case Nil => 1
  case y :: ys => y * product(ys)
}
\end{lstlisting}

Mas também podemos usar a generalização deste esquema de programa incorporado no método 
\code{reduceLeft} da classe \code{List}. Este método insere um dado operador binário entre
elementos adjacentes de uma dada lista. Ou seja, 
\begin{lstlisting}
List(x$_1$, ..., x$_n$).reduceLeft(op) = (...(x$_1$ op x$_2$) op ... ) op x$_n$
\end{lstlisting}
Usando \code{reduceLeft}, podemos tornar o padrão comum emas \code{sum} e \code{product}
aparente:
\begin{lstlisting}
def sum(xs: List[Int])      =  (0 :: xs) reduceLeft {(x, y) => x + y}
def product(xs: List[Int])  =  (1 :: xs) reduceLeft {(x, y) => x * y}
\end{lstlisting}
Aqui está a implementação de \code{reduceLeft}.
\begin{lstlisting}
  def reduceLeft(op: (A, A) => A): A = this match {
    case Nil     => error("Nil.reduceLeft")
    case x :: xs => (xs foldLeft x)(op)
  }
  def foldLeft[B](z: B)(op: (B, A) => B): B = this match {
    case Nil => z
    case x :: xs => (xs foldLeft op(z, x))(op)
  }
}
\end{lstlisting}

Vemos que o método \code{reduceLeft} é definido em termos de um outro método, geralmente útil, 
\code{foldLeft}. O último pega como parâmetro adicional um {\em acumulador} \code{z}, que é 
retornado quando \code{foldLeft} é aplicado sobre uma lista vazia. Ou seja, 
\begin{lstlisting}
(List(x$_1$, ..., x$_n$) foldLeft z)(op)   =  (...(z op x$_1$) op ... ) op x$_n$
\end{lstlisting}
Os métodos \code{sum} e \code{product} podem ser defidos alternativamente usando \code{foldLeft}:
\begin{lstlisting}
def sum(xs: List[Int])      =  (xs foldLeft 0) {(x, y) => x + y}
def product(xs: List[Int])  =  (xs foldLeft 1) {(x, y) => x * y}
\end{lstlisting}

\paragraph{FoldRight e ReduceRight}
Aplicações de \code{foldLeft} e \code{reduceLeft} expandem para árvores inclinadas à esquerda. 
\todo{insert pictures}. Eles têm duals \code{foldRight} e \code{reduceRight} que produzem 
árvores inclinadas à direita.
\begin{lstlisting}
List(x$_1$, ..., x$_n$).reduceRight(op)     =  x$_1$ op ( ... (x$_{n-1}$ op x$_n$)...)
(List(x$_1$, ..., x$_n$) foldRight acc)(op) =  x$_1$ op ( ... (x$_n$ op acc)...)
\end{lstlisting}
Estes são definidos como segue.
\begin{lstlisting}
  def reduceRight(op: (A, A) => A): A = this match {
    case Nil => error("Nil.reduceRight")
    case x :: Nil => x
    case x :: xs => op(x, xs.reduceRight(op))
  }
  def foldRight[B](z: B)(op: (A, B) => B): B = this match {
    case Nil => z
    case x :: xs => op(x, (xs foldRight z)(op))
  }
\end{lstlisting}
A classe  \code{List} define também duas abreviaturas simbólicas para \code{foldLeft}
e \code{foldRight}:
\begin{lstlisting}
  def /:[B](z: B)(f: (B, A) => B): B = foldLeft(z)(f)
  def :\[B](z: B)(f: (A, B) => B): B = foldRight(z)(f)
\end{lstlisting}
Os nomes dos métodos ilustram a inclinação à esquerda/direita das árvores das operações 
fold através de barra simples ou invertida. O \code{:} aponta em cada caso para a lista 
de argumentos enquanto o fim da barra aponta para o acumulador (ou: zero) argumento \code{z}.
Ou seja,  
\begin{lstlisting}
(z /: List(x$_1$, ..., x$_n$))(op) = (...(z op x$_1$) op ... ) op x$_n$ 
(List(x$_1$, ..., x$_n$) :\ z)(op) = x$_1$ op ( ... (x$_n$ op z)...)
\end{lstlisting}
Através de operadores associativos e comutativos, \code{/:} e \code{:\\} são equivalentes
(mesmo sabendo que podem ser diferentes em eficiência).

%But sometimes, only one of the two operators is
%appropriate or has the right type:

\begin{exercise} Considere o problema de escrever uma função \code{flatten}, que recebe 
uma lista de listas como argumentos. O resultado de \code{flatten} deve ser a concatenação 
de todos os elementos listas em uma única lista. Aqui está uma implementação deste método 
em termos de 
\code{:\\}.
\begin{lstlisting}
def flatten[A](xs: List[List[A]]): List[A] =
  (xs :\ (Nil: List[A])) {(x, xs) => x ::: xs}
\end{lstlisting} 
Considere substituir o corpo de  \lstinline@flatten@ por 
\begin{lstlisting}
  ((Nil: List[A]) /: xs) ((xs, x) => xs ::: x)
\end{lstlisting}
Qual a diferença na complexidade assintótica entre as duas versões de \lstinline@flatten@? 

De fato \code{flatten} é predefinido junto com um conjunto de outras funções úteis no objeto 
chamado \code{List} na biblioteca padrão Scala. Pode ser acessado de um programa usuário 
chamando \code{List.flatten}. Observe que \code{flatten} não é um método da classe
\code{List}---não faz sentido, pois aplica-se somente a listas de listas, não a todas as
listas em geral. 

\end{exercise}

\paragraph{Novamente Inversão de Lista} Vimos na Seção~\ref{sec:list-first-order} uma 
implementação do método \code{reverse} cujo tempo de execução era quadrático para o 
tamanho da lista a ser invertida. Agora desenvolveremos uma nova implementação de
\code{reverse}, cujo custo é linear. A idéia é usar uma operação \code{foldLeft} 
baseada no seguinte programa scheme.
\begin{lstlisting}
class List[+A] { ...
  def reverse: List[A] = (z? /: this)(op?)
\end{lstlisting}


Agora falta preencher \code{z?} e \code{op?}. Vamos tentar deduzir a partir dos exemplos.
\begin{lstlisting}
  Nil
= Nil.reverse                 // pela especifica\c{c}\~{a}o 
= (z /: Nil)(op)              // pelo template para reverse
= (Nil foldLeft z)(op)        // pela defini\c{c}\~{a}o de /:
= z                           // pela defini\c{c}\~{a}o de foldLeft
\end{lstlisting}
Consequentemente, \code{z?} deve ser \code{Nil}. Para deduzir o segundo operando, vamos estudar
o inverso de uma lista de tamanho um.
\begin{lstlisting}
  List(x)
= List(x).reverse             // pela especifica\c{c}\~{a}o 
= (Nil /: List(x))(op)        // pelo template para reverse, com  z = Nil
= (List(x) foldLeft Nil)(op)  // pela defini\c{c}\~{a}o de /:
= op(Nil, x)                  // pela defini\c{c}\~{a}o de foldLeft
\end{lstlisting}
Consequentemente, \code{op(Nil, x)} é igual a \code{List(x)}, o que é o mesmo que \code{x :: Nil}.
Isto sugere pegar como \code{op} o operador \code{::} com seus operandos trocados. Consequentemente,
chegamos a seguinte implementação para \code{reverse}, que tem complexidade linear.
\begin{lstlisting}
def reverse: List[A] =
  ((Nil: List[A]) /: this) {(xs, x) => x :: xs}
\end{lstlisting}
(Obs: O tipo de anotação para \code{Nil} é necessário para que a inferência de tipos funcione.)

\begin{exercise} Preencha as expressões faltantes para completar as seguintes definições de 
algumas operações básicas de manipulação de listas como operações fold. 
\begin{lstlisting}
def mapFun[A, B](xs: List[A], f: A => B): List[B] =
  (xs :\ List[B]()){ ?? }

def lengthFun[A](xs: List[A]): int =
  (0 /: xs){ ?? }
\end{lstlisting}
\end{exercise}


\paragraph{Mapeamentos Aninhados}

Podemos empregar funções de processamento de listas de alta ordem para expressar muita
computação que, normalmente é expressa através de aninhamento de laços nas linguagens imperativas.

Como exemplo, considere o seguinte problema: Dado um inteiro positivo $n$, encontre todos os pares
de inteiros positivos $i$ e $j$, onde $1 \leq j < i < n$ tal que $i + j$ seja primo. Por exemplo, 
se $n= 7$, os pares são 
\bda{c|lllllll}
i     & 2 & 3 & 4 & 4 & 5 & 6 & 6\\
j     & 1 & 2 & 1 & 3 & 2 & 1 & 5\\ \hline
i + j & 3 & 5 & 5 & 7 & 7 & 7 & 11
\eda

Um modo natural de resolver este problema consiste em dois passos. Num primeiro passo, gera-se
a sequência de todos os pares $(i, j)$ de inteiros tal que $1 \leq j < i < n$. Num segundo passo
filtra-se, a partir desta sequência, todos os pares $(i,j)$ tal que $i + j$ é primo.

Examinando o primeiro passo em detalhe, um modo natural de gerar a sequência de pares consiste
de três sub-passos. Primeiro, gera-se todos os inteiros entre $1$ e $n$ para $i$.

Segundo, para cada inteiro $i$ entre $1$ e $n$, gera-se a lista de pares $(i, 1)$ up to $(i, i-1)$. 
Isso pode ser conseguido através de uma combinação de \code{range} e \code{map}:
\begin{lstlisting}
  List.range(1, i) map (x => (i, x))
\end{lstlisting}

Finalmente, combina-se todas as sublistas usando \code{foldRight} com \code{:::}. Juntando tudo
dá a seguinte expressão:
\begin{lstlisting}
List.range(1, n)
  .map(i => List.range(1, i).map(x => (i, x)))
  .foldRight(List[(Int, Int)]()) {(xs, ys) => xs ::: ys}
  .filter(pair => isPrime(pair._1 + pair._2))
\end{lstlisting}

\paragraph{Flattening Maps}

A combinação entre mapeamento e a concatenação das sublistas resultantes do mapeamento é tão comum 
que há um método especial para isto na classe \code{List}:
\begin{lstlisting}
abstract class List[+A] { ...
  def flatMap[B](f: A => List[B]): List[B] = this match {
    case Nil => Nil
    case x :: xs => f(x) ::: (xs flatMap f)
  }
}
\end{lstlisting}
Com \code{flatMap}, os expressão dos ``pares cuja soma dá um primo'' pode ser escrita de modo mais
sucinto como segue.
\begin{lstlisting}
List.range(1, n)
  .flatMap(i => List.range(1, i).map(x => (i, x)))
  .filter(pair => isPrime(pair._1 + pair._2))
\end{lstlisting}



\section{Sumário}

Este capítulo introduziu listas como uma estrutura de dados fundamental na programação. Como listas 
são imutáveis, elas são um tipo de dado comum na programação em linguagens funcionais. Elas têm 
importância comparável a vetores nas linguagens imperativas. Entretanto, o padrão de acesso é bem diferente 
entre os dois. Enquanto o acesso em vetores é sempre feito através de indexação, isto é muito incomum em 
listas. Nós vimos que \code{scala.List} define um método chamado \code{apply} para a indexação, entretanto, 
esta operação é muito mais custosa que no caso dos vetores (linear em comparação a tempo constante). Ao
invés da indexação, listas são geralmente percorridas recursivamente, onde passos recursivos são em geral
baseados em casamento de padrões sobre a lista percorrida. Há também um rico conjunto de combinadores de
alta ordem que permitem a instanciação de um conjunto de padrões pré-definidos de computações sobre listas.

\comment{
\bsh{Pensando sobre Listas}

Lembre da operação de concatenação para listas:

\begin{lstlisting}
class List[+A] {
  ...
  def ::: (that: List[A]): List[A] =
    if (isEmpty) that
    else head :: (tail ::: that)
}
\end{lstlisting}

We would like to verify that concatenation is associative, with the
empty list \code{List()} as left and right identity:

Poderíamos querer verificar que a concatenação é associativa, com a lista vazia \code{List()} como 
identidade esquerda e direita:
\bda{lcl}
   (xs ::: ys) ::: zs &=& xs ::: (ys ::: zs) \\
   xs ::: List()          &=& xs \gap =\ List() ::: xs
\eda
\emph{Q}: Como podemos provar declarações como a expressa acima?

\emph{R}: Através de \emph{indução estrutural} sobre listas.
\es
\bsh{Lembrete: Indução Natural}

Lembrando o princípio da prova por \emph{indução natural}:

Para mostrar uma propriedade \mathtext{P(n)} para todos os números \mathtext{n \geq b}:
\be
\item Mostre que \mathtext{P(b)} vale para o (\emph{caso base}).
\item Para \mathtext{n \geq b} arbitrários, mostre:
\begin{quote}
     se vale \mathtext{P(n)}, então \mathtext{P(n+1)} também vale
\end{quote}
(\emph{passo indutivo}).
\ee
%\es\bs
\emph{Examplo}: Dado
\begin{lstlisting}
def factorial(n: Int): Int =
  if (n == 0) 1
  else n * factorial(n-1)
\end{lstlisting}
mostre que, para todos \code{n >= 4},
\begin{lstlisting}
   factorial(n) >= 2$^n$
\end{lstlisting}
\es\bs
\Case{\code{4}}
é estabelecido pelo simples cálculo de \code{factorial(4) = 24} e \code{2$^4$ = 16}.
\Case{\code{n+1}} 
Temos para \code{n >= 4}:
\begin{lstlisting}
    \= factorial(n + 1)
 =     \> $\expl{pela segundo cláusula de factorial(*)}$
       \> (n + 1) * factorial(n)
 >=    \> $\expl{pelo cálculo}$
       \> 2 * factorial(n)
 >=    \> $\expl{pela hipótese de indução}$
       \> 2 * 2$^n$.
\end{lstlisting}
Observe que em nossa prova podemos aplicar livremente passos de redução tais como em (*) qualquer lugar do termo.

Isto funciona porque programas puramente funcionais não têm efeitos colaterais; logo um termo é equivalente 
ao termo a que se reduz.
O princípio é chamado  {\em\emph{transparência referencial}}.

\es
\bsh{Indução Estrutural}

O princípio da indução estrutural é análogo à indução natural:

No caso de listas, funciona como segue:

Para provar uma propriedade \mathtext{P(xs)} para todas as listas  \mathtext{xs},

\be
\item Mostre que \code{P(List())} vale no (\emph{caso base}).
\item Para listas arbitrárias \mathtext{xs} e elementos \mathtext{x}, mostre: 
\begin{quote}
     se \mathtext{P(xs)} vale, então \mathtext{P(x :: xs)} também vale.
\end{quote}
(\emph{passo indutivo}).
\ee

\es
\bsh{Exemplo}

Mostramos \code{(xs ::: ys) ::: zs  =  xs ::: (ys ::: zs)} através de indução estrutural sobre \code{xs}.

\Case{\code{List()}}
Para a parte esquerda, temos:
\begin{lstlisting}
    \= (List() ::: ys) ::: zs
 =     \> $\expl{pela primeira cláusula de \prog{:::}}$
       \> ys ::: zs
\end{lstlisting}
Para a parte direita, temos:
\begin{lstlisting}
    \= List() ::: (ys ::: zs)
 =     \> $\expl{pela primeira cláusula de \prog{:::}}$
       \> ys ::: zs
\end{lstlisting}
Então, o case é estabelecido.

\es
\bs
\Case{\code{x :: xs}} 

Para a parte esquerda, temos:
\begin{lstlisting}
    \= ((x :: xs) ::: ys) ::: zs
 =     \> $\expl{pela segunda cláusula de \prog{:::}}$
       \> (x :: (xs ::: ys)) ::: zs
 =     \> $\expl{pela segunda cláusula de \prog{:::}}$
       \> x :: ((xs ::: ys) ::: zs)
 =     \> $\expl{pela hipótese de indução}$
       \> x :: (xs ::: (ys ::: zs))
\end{lstlisting}

Para a parte direita, temos:
\begin{lstlisting}
    \= (x :: xs) ::: (ys ::: zs)
 =     \> $\expl{pela segunda cláusula de \prog{:::}}$
       \> x :: (xs ::: (ys ::: zs))
\end{lstlisting}
Então, o case (e com ele a propriedade) é estabelecido.
\begin{exercise}
%% Show by induction on \code{xs} that \code{xs ::: List()  =  xs}.
Mostre por indu\c{c}\~{a}o que dado \code{xs} temos \code{xs ::: List() = xs}. 
\es
\bsh{Example (2)}
\end{exercise}

Como um exemplo mais dif\'{i}cil, considere a fun\c{c}\~{a}o
\begin{lstlisting}
abstract class List[A] { ...
  def reverse: List[A] = this match {
    case List() => List()
    case x :: xs => xs.reverse ::: List(x)
  }
}
\end{lstlisting}
Gostaríamos de provar a proposição 
\begin{lstlisting}
   xs.reverse.reverse  =  xs  .
\end{lstlisting}
Procedemos por indução sobre \code{xs}. O caso base é fácil de se estabelecer:
\begin{lstlisting}
    \= List().reverse.reverse
 =     \> $\expl{pela primeira cláusula de \prog{reverse}}$
       \> List().reverse
 =     \> $\expl{pela primeira cláusula de \prog{reverse}}$
       \> List()
\end{lstlisting}
\es\bs
Para o passo indutivo, tentamos:
\begin{lstlisting}
    \= (x :: xs).reverse.reverse
 =     \> $\expl{pela segunda cláusula de \prog{reverse}}$
       \> (xs.reverse ::: List(x)).reverse
\end{lstlisting}
Não há nada mais o que se fazer com esta expressão, logo nos voltamos para a parte direita:
\begin{lstlisting}
    \= x :: xs
 =     \> $\expl{pela hipótese indutiva}$
       \> x :: xs.reverse.reverse
\end{lstlisting}
Os dois lados foram simplificados para expressões diferentes.
Portanto, ainda temos que mostrar que 
\begin{lstlisting}
  (xs.reverse ::: List(x)).reverse  =  x :: xs.reverse.reverse
\end{lstlisting}
Tentar provar isto diretamente através de indução não funciona.

Ao invés, temos que {\em generalizar} a equação para:
\begin{lstlisting}
  (ys ::: List(x)).reverse  =  x :: ys.reverse
\end{lstlisting}
\es\bs
Esta equação pode ser provada por um segundo argumento indutivo sobre \code{ys}.
(Veja o blackboard).

\begin{exercise}
No caso em que \code{(xs drop m) at n  =  xs at (m + n)} para todos os números naturais \code{m}, 
\code{n} e todas as listas \code{xs}?
\end{exercise}

\es
\bsh{Indução Estrutural sobre Árvores}

Indução estrutural não se restringe à listas; funciona para árvores arbitrárias.

O princípio geral de indução é como segue.

Para mostrar que a propriedade \code{P(t)} vale para todas as árvores de um certo tipo,
\begin{itemize}
\item Mostre \code{P(l)} para todas as folhas das árvores \code{$l$}.
\item Para cada nó interno \code{t} com subárvores \code{s$_1$, ..., s$_n$},
      mostre que  \code{P(s$_1$) $\wedge$ ... $\wedge$ P(s$_n$) => P(t)}. 
\end{itemize} 

\example Lembre de nossa definição de \code{IntSet} com operações \code{contains} e \code{incl}:

\begin{lstlisting}
abstract class IntSet {
  abstract def incl(x: Int): IntSet
  abstract def contains(x: Int): Boolean
}
\end{lstlisting}
\es\bs
\begin{lstlisting}
case class Empty extends IntSet {
  def contains(x: Int): Boolean = false
  def incl(x: Int): IntSet = NonEmpty(x, Empty, Empty)
}
case class NonEmpty(elem: Int, left: Set, right: Set) extends IntSet {
  def contains(x: Int): Boolean =
    if (x < elem) left contains x
    else if (x > elem) right contains x
    else true
  def incl(x: Int): IntSet =
    if (x < elem) NonEmpty(elem, left incl x, right)
    else if (x > elem) NonEmpty(elem, left, right incl x)
    else this
}
\end{lstlisting}
(Com \code{case} adicionado, podemos usar métodos de fábrica ao invés de \code{new}).

O que significa provar a correção desta implementação?
\es
\bsh{Leis do IntSet}

Um modo de declarar e provar a correção de uma implementação é provar leis que valem para ela.


No caso de \code{IntSet}, três dessas leis serão:


Para todos os conjuntos \code{s}, elementos \code{x}, \code{y}:
\begin{lstlisting}
Empty contains x          \= =  false
(s incl x) contains x     \> =  true
(s incl x) contains y     \> =  s contains y         if x $\neq$ y
\end{lstlisting}

(De fato, podemos mostrar que estas leis caracterizam o tipo de dado desejado completamente).
Como podemos estabelecer que essas leis valem?

\emph{Proposition 1}: \code{Empty contains x =  false}.

\emph{Proof}: Pela definição de \code{contains} in \code{Empty}.
\es\bs
\emph{Proposition 2}: \code{(xs incl x) contains x = true}

\emph{Proof:}

\Case{\code{Empty}}
\begin{lstlisting}
    \= (Empty incl x) contains x
 =     \> $\expl{by definition of \prog{incl} in \prog{Empty}}$
       \> NonEmpty(x, Empty, Empty) contains x
 =     \> $\expl{by definition of \prog{contains} in \prog{NonEmpty}}$
       \> true
\end{lstlisting}

\Case{\code{NonEmpty(x, l, r)}}
\begin{lstlisting}
    \= (NonEmpty(x, l, r) incl x) contains x
 =     \> $\expl{by definition of \prog{incl} in \prog{NonEmpty}}$
       \> NonEmpty(x, l, r) contains x
 =     \> $\expl{by definition of \prog{contains} in \prog{Empty}}$
       \> true
\end{lstlisting}
\es\bs
\Case{\code{NonEmpty(y, l, r)} where \code{y < x}}
\begin{lstlisting}
    \= (NonEmpty(y, l, r) incl x) contains x
 =     \> $\expl{by definition of \prog{incl} in \prog{NonEmpty}}$
       \> NonEmpty(y, l, r incl x) contains x
 =     \> $\expl{by definition of \prog{contains} in \prog{NonEmpty}}$
       \> (r incl x) contains x
 =     \> $\expl{by the induction hypothesis}$
       \> true
\end{lstlisting}

\Case{\code{NonEmpty(y, l, r)} where \code{y > x}} is analogous.

\bigskip

\emph{Proposition 3}: If \code{x $\neq$ y} then
\code{xs incl y contains x  =  xs contains x}.

\emph{Proof:} Veja o blackboard.
\es
\bsh{Exercise}

Digamos que adicionamos a função \code{union} à  \code{IntSet}:
\begin{lstlisting}
class IntSet { ...
  def union(other: IntSet): IntSet
}
class Expty extends IntSet { ...
  def union(other: IntSet) = other
}
class NonEmpty(x: Int, l: IntSet, r: IntSet) extends IntSet { ...
  def union(other: IntSet): IntSet = l union r union other incl x
}
\end{lstlisting}
A correção de \code{union} pode ser incluída com a seguinte lei:

\emph{Proposição 4}: 
\code{(xs union ys) contains x  =  xs contains x || ys contains x}.

Será verdadeiro? Que hipótese está faltando? Mostre um contra-exemplo.

Mostre a Proposição 4 usando indução estrutural sobre \code{xs}.
\es
\comment{

\emph{Prova:} Por indução sobre \code{xs}.

\Case{\code{Empty}}

\Case{\code{NonEmpty(x, l, r)}}

\Case{\code{NonEmpty(y, l, r)} onde \code{y < x}}

\begin{lstlisting}
    \= (Empty union ys) contains x 
 =      \> $\expl{by definition of \prog{union} in \prog{Empty}}$
        \> ys contains x
 =      \> $\expl{Boolean algebra}$
        \> false || ys contains x
 =      \> $\expl{by definition of \prog{contains} in \prog{Empty} (reverse)}$
        \> (Empty contains x) || (ys contains x)
\end{lstlisting}

\begin{lstlisting}
    \= (NonEmpty(x, l, r) union ys) contains x
 =      \> $\expl{by definition of \prog{union} in \prog{NonEmpty}}$
        \> (l union r union ys incl x) contains x
 =      \> $\expl{by Proposition 2}$
        \> true
 =      \> $\expl{Boolean algebra}$
        \> true || (ys contains x)
 =      \> $\expl{by definition of \prog{contains} in \prog{NonEmpty} (reverse)}$
        \> (NonEmpty(x, l, r) contains x) || (ys contains x)
\end{lstlisting}

\begin{lstlisting}
    \= (NonEmpty(y, l, r) union ys) contains x
 =      \> $\expl{by definition of \prog{union} in \prog{NonEmpty}}$
        \> (l union r union ys incl y) contains x
 =      \> $\expl{by Proposition 3}$
        \> (l union r union ys) contains x
 =      \> $\expl{by the induction hypothesis}$
        \> ((l union r) contains x) || (ys contains x)
 =      \> $\expl{by Proposition 3}$
        \> ((l union r incl y) contains x) || (ys contains x)
\end{lstlisting}

\Case{\code{NonEmpty(y, l, r)} where \code{y < x}}
 ... é análogo.

\es
}}
\chapter{\label{sec:for-notation}For-Comprehensions}

O último capítulo demonstrou que funções de alta ordem, tais como \verb@map@, \verb@flatMap@, \verb@filter@
provém poderosas construções para lidar com listas. Mas algumas vezes o nível de abstração requerido por 
estas funções tornam um programa difícil de entender.

Para ajudar a inteligibilidade, Scala tem uma notação especial que simplifica padrões comuns de aplicações 
de funções de alta ordem. Esta notação cria uma ponte entre abrangência de conjuntos (set-comprehensions) 
na matemática e laços for em linguagens imperativas tais como C ou Java. Também lembram de perto
a notação de pesquisa em bases de dados relacionais.  

Como um primeiro exemplo, digamos que nos é dada uma lista \code{persons} de pessoas com campos \code{name} 
e \code{age} (idade). Para imprimir os nomes de todas as pessoas na sequência para idades acima de $20$, 
pode-se escrever:
 
\begin{lstlisting}
for (p <- persons if p.age > 20) yield p.name
\end{lstlisting}
Isto é equivalente à seguinte expressão, que usa as funções de alta ordem \code{filter} e \code{map}: 
\begin{lstlisting}
persons filter (p => p.age > 20) map (p => p.name)
\end{lstlisting}
A abrangência for (for-comprehension) parece um pouco com um laço for nas linguagens imperativas, 
exceto que constrói uma lista de resultados de todas iterações.

Geralmente, um for-comprehension tem a forma
\begin{lstlisting}
for ( $s$ ) yield $e$
\end{lstlisting}
Here, $s$ is a sequence of {\em generators}, {\em definitions} and
{\em filters}.  A {\em generator} is of the form \code{val x <- e},
where \code{e} is a list-valued expression. It binds \code{x} to
successive values in the list.  A {\em definition} is of the form
\code{val x = e}. It introduces \code{x} as a name for the value of
\code{e} in the rest of the comprehension. A {\em filter} is an
expression \code{f} of type \code{Boolean}.  It omits from
consideration all bindings for which \code{f} is \code{false}.  The
sequence $s$ starts in each case with a generator.  If there are
several generators in a sequence, later generators vary more rapidly
than earlier ones.

Aqui, $s$ é uma sequência de {\em geradores}, {\em definições} e {\em filtros}. Um {\em gerador} tem a 
forma \code{val x <- e}, onde \code{e} é uma expressão avaliada como lista. Liga \code{x} a sucessivos
valores na lista. Uma {\em definição} tem a forma \code{val x = e}. Introduz \code{x} como um nome para 
o valor de \code{e} no restante da abrangência. Um {\em filtro} é uma expressão \code{f} do tipo 
\code{Boolean}. Omite da consideração todas as ligações para as quais \code{f} é \code{falso}. A
sequência $s$

A sequência $s$ pode também ser envolvida em chaves ao invés de parênteses, e os dois pontos 
entre geradores, definições e filtros podem ser omitidos. 

Aqui estão dois exemplos que mostram como for-comprehensions são usados. Primeiro, vamos refazer um 
exemplo do capítulo anterior: Dado um inteiro positivo $n$, encontre todos os pares de inteiros 
positivos $i$ e $j$, onde $1 \leq j < i < n$ such that $i + j$ é primo. Com um for-comprehension
este problema é resolvido como segue:
\begin{lstlisting}
for { i <- List.range(1, n)
      j <- List.range(1, i)
      if isPrime(i+j) } yield {i, j}
\end{lstlisting}

Isto é discutivelmente mais claro que a solução usando \code{map}, \code{flatMap} e \code{filter}
que desenvolvemos previamente.

Como segundo exemplo, considere calcular o produto escalar de dois vetores \code{xs} e \code{ys}. 
Usando um for-comprehension, isto pode ser escrito como segue.
\begin{lstlisting}
  sum(for ((x, y) <- xs zip ys) yield x * y)
\end{lstlisting}

\section{O Problema da N-Rainhas}

For-comprehensions são especialmente úteis para resolver puzzles combinatórios. Um exemplo é o problema 
das $8$-rainhas: Dado um tabuleiro de xadrez padrão, coloque $8$ rainhas, tal que nenhuma rainha
esteja atacada por nenhuma outra (uma rainha pode atacar qualquer outra peça se estiver na mesma coluna, 
linha ou diagonal que a mesma). Desenvolveremos agora uma solução para este problema, generalizando 
para tabuleiros de xadrez de tamanho arbitrário. Consequentemente, o problema é colocar $n$ rainhas 
em um tabuleiro de xadrez de tamanho $n \times n$.

Para resolver este problema, observe que precisamos colocar uma rainha em cada linha. 
Logo podemos colocar rainhas em linhas sucessivas, cada vez checando que uma rainha recentemente colocada
não esteja atacada por qualquer outra rainha que já se encontra no tabuleiro. No curso desta busca, pode 
acontecer que uma rainha a ser colocada na linha $k$ esteja atacada em todas as casas desta linha por rainhas
rainhas das linhas $1$ até $k-1$. Neste caso, precisamos interromper esta parte da busca e continuar com uma 
configuração diferente de rainhas nas colunas $1$ até $k-1$.

Isso sugere um algoritmo recursivo. Assuma que já geramos todas as soluções para colocar $k-1$ rainhas em
um tabuleiro de tamanho $n \times n$. Podemos representar tal solução por uma lista de tamanho $k-1$ de 
números das colunas (no intervalo de $1$ a $n$). Tratamos estas listas de soluções parciais como pilhas,
onde o número da coluna da rainha na linha $k-1$ vem primeiro dentro da lista, seguido pelo número da 
coluna da rainha na linha $k-2$ etc. O fundo da pilha é o número da coluna da rainha colocada na 
primeira linha do tabuleiro. Todas as soluções juntas são então representadas como uma lista de listas, 
com um elemento para cada solução.

Agora, para colocar a $k$-ésima rainha, geramos todas as possíveis extensões para cada solução prévia com uma 
rainha a mais. Isto leva a uma outra lista de listas soluções, desta vez de tamanho $k$. Continuamos o processo
até atingirmos soluções do tamanho $n$ do tabuleiro de xadrez. Esta idéia algorítmica é incorporada na 
função \code{placeQueens} abaixo: 

\begin{lstlisting}
def queens(n: Int): List[List[Int]] = {
  def placeQueens(k: Int): List[List[Int]] =
    if (k == 0) List(List())
    else for { queens <- placeQueens(k - 1)
               column <- List.range(1, n + 1)
               if isSafe(column, queens, 1) } yield column :: queens
  placeQueens(n)
}
\end{lstlisting}

\begin{exercise} Escreva a função 
\begin{lstlisting}
  def isSafe(col: Int, queens: List[Int], delta: Int): Boolean
\end{lstlisting}
que testa se uma rainha numa dada coluna \verb@col@ está segura com respeito às \verb@queens@ já colocadas.
Aqui, \verb@delta@ é a diferença entre a linha da rainha a ser colocada e a linha da primeira rainha da lista.
\end{exercise}

\section{Pesquisando com For-Comprehensions}

A notação for é essencialmente equivalente a operações comuns de linguagens de pesquisa de bases de dados.
Por exemplo, digamos que temos uma base de dados \code{books}, representada como uma lista de livros, onde
\code{Book} é definido como segue.
\begin{lstlisting}
case class Book(title: String, authors: List[String])
\end{lstlisting}
Aqui está um pequeno exemplo de base de dados:
\begin{lstlisting}
val books: List[Book] = List(
  Book("Structure and Interpretation of Computer Programs",
       List("Abelson, Harold", "Sussman, Gerald J.")),
  Book("Principles of Compiler Design",
       List("Aho, Alfred", "Ullman, Jeffrey")),
  Book("Programming in Modula-2",
       List("Wirth, Niklaus")),
  Book("Introduction to Functional Programming"),
       List("Bird, Richard")),
  Book("The Java Language Specification",
       List("Gosling, James", "Joy, Bill", "Steele, Guy", "Bracha, Gilad")))
\end{lstlisting}
Então, para encontrar os títulos de todos os livros cujos autores tenham sobrenome ``Ullman'':
\begin{lstlisting}
for (b <- books; a <- b.authors if a startsWith "Ullman")
yield b.title
\end{lstlisting}
(Aqui, \code{startsWith} é um método dentro em \code{java.lang.String}).  Ou, para encontrar os 
títulos de todos os livros que tenham a cadeia de caracteres ``Program'' em seu título: 
\begin{lstlisting}
for (b <- books if (b.title indexOf "Program") >= 0)
yield b.title
\end{lstlisting}
Ou, para encontrar os nomes de todos os autores que escreveram pelo menos dois livros, na base de dados.
\begin{lstlisting}
for (b1 <- books; b2 <- books if b1 != b2;
     a1 <- b1.authors; a2 <- b2.authors if a1 == a2)
yield a1
\end{lstlisting}
A última solução ainda não é perfeita, porque autores aparecerão diversas vezes na lista de resultados.
Ainda precisamos remover autores duplicados das listas resultantes. Isto pode ser obtido através da seguinte 
função.
\begin{lstlisting}
def removeDuplicates[A](xs: List[A]): List[A] =
  if (xs.isEmpty) xs
  else xs.head :: removeDuplicates(xs.tail filter (x => x != xs.head))
\end{lstlisting}
Observe que a última expressão no método \code{removeDuplicates} pode ser equivalentemente expresso usando 
um for-comprehension.
\begin{lstlisting}
xs.head :: removeDuplicates(for (x <- xs.tail if x != xs.head) yield x)
\end{lstlisting}

\section{Tradução de For-Comprehensions}

Cada for-comprehension pode ser expresso em termos de três funções de alta-ordem: \code{map}, 
\code{flatMap} e \code{filter}. Aqui está o esquema de tradução, que também é usado pelo compilador Scala.
\begin{itemize}
\item
Um for-comprehension simples
\begin{lstlisting}
for (x <- e) yield e'
\end{lstlisting}
é traduzido para
\begin{lstlisting}
e.map(x => e')
\end{lstlisting}
\item
Um for-comprehension 
\begin{lstlisting}
for (x <- e if f; s) yield e'
\end{lstlisting}
onde \code{f} é um filtro e \code{s} é uma (possivelmente vazia) sequência de geradores ou filtros, 
é traduzida para 
\begin{lstlisting}
for (x <- e.filter(x => f); s) yield e'
\end{lstlisting}
e então, a tradução continua com a última expressão.
\item
Um for-comprehension 
\begin{lstlisting}
for (x <- e; y <- e'; s) yield e''
\end{lstlisting}
onde \code{s} é uma (possivelmente vazia) sequência de geradores ou filtros é traduzida para 
\begin{lstlisting}
e.flatMap(x => for (y <- e'; s) yield e'')
\end{lstlisting}
e então, a tradução continua com a última expressão.
\end{itemize}
Por exemplo, tomando nosso exemplo  ``pares de inteiros cuja soma é um primo'':
\begin{lstlisting}
for { i <- range(1, n)
      j <- range(1, i)
      if isPrime(i+j)
} yield {i, j}
\end{lstlisting}
Aqui está o que obtemos quando traduzimos esta expressão:
\begin{lstlisting}
range(1, n)
  .flatMap(i =>
    range(1, i)
      .filter(j => isPrime(i+j))
      .map(j => (i, j)))
\end{lstlisting}
%---------------xpto
De modo inverso, também seria possível expressar as funções \code{map}, \code{flatMap} e \code{filter}
usando for-comprehensions. Aqui estão as três funções novamente, desta vez implementadas usando
for-comprehensions.

\begin{lstlisting}
object Demo {
  def map[A, B](xs: List[A], f: A => B): List[B] =
    for (x <- xs) yield f(x)

  def flatMap[A, B](xs: List[A], f: A => List[B]): List[B] =
    for (x <- xs; y <- f(x)) yield y

  def filter[A](xs: List[A], p: A => Boolean): List[A] =
    for (x <- xs if p(x)) yield x
}
\end{lstlisting}
Não surpreendentemente, a tradução do for-comprehension no corpo de \code{Demo.map} produzirá
uma chamada para \code{map} na classe \code{List}. Similarmente, \code{Demo.flatMap} e
\code{Demo.filter} são traduzidos para \code{flatMap} e \code{filter} na classe \code{List}.

\begin{exercise}
Defina a seguinte função em termos de \code{for}.
\begin{lstlisting}
def flatten[A](xss: List[List[A]]): List[A] =
  (xss :\ (Nil: List[A])) ((xs, ys) => xs ::: ys)
\end{lstlisting}
\end{exercise}

\begin{exercise}
Traduza 
\begin{lstlisting}
for (b <- books; a <- b.authors if a startsWith "Bird") yield b.title
for (b <- books if (b.title indexOf "Program") >= 0) yield b.title
\end{lstlisting}
to higher-order functions.
\end{exercise}

\section{For-Loops}\label{sec:for-loops}

For-comprehensions lembram for-loops das linguagens imperativas, exceto que eles produzem uma lista 
de resultados. Algumas vezes, uma lista de resultados não é necessária, mas ainda gostaríamos da
flexibilidade dos geradores e filtros nas iterações sobre listas. Isso é possível por uma variante
da sintaxe dos for-comprehensions, os quais expressam for-loops:  
\begin{lstlisting}
for ( $s$ ) $e$
\end{lstlisting}
Esta construção é a mesma da sintaxe padrão do for-comprehension, exceto que a palavra chave \code{yield}
está faltando. O for-loop é executado pela execução da expressão $e$ para cada elemento gerado da sequência 
de geradores e filtros $s$.

Como um exemplo, a seguinte expressão imprime todos os elementos de uma matriz representada como 
uma lista de listas:
 \begin{lstlisting}
for (xs <- xss) {
  for (x <- xs) print(x + "\t")
  println()
}
\end{lstlisting}
A tradução de for-loops para métodos de alta ordem da classe \code{List} é similar à tradução de
for-comprehensions, mas mais simples. Onde for-comprehensions são traduzidos para \code{map} e 
\code{flatMap}, for-loops traduzem em cada caso para \code{foreach}.

\section{Generalizing For}

We have seen that the translation of for-comprehensions only relies on
the presence of methods \code{map}, \code{flatMap}, and
\code{filter}. Therefore it is possible to apply the same notation to
generators that produce objects other than lists; these objects only
have to support the three key functions \code{map}, \code{flatMap},
and \code{filter}.

The standard Scala library has several other abstractions that support
these three methods and with them support for-comprehensions. We will
encounter some of them in the following chapters. As a programmer you
can also use this principle to enable for-comprehensions for types you
define -- these types just need to support methods \code{map},
\code{flatMap}, and \code{filter}.

There are many examples where this is useful: Examples are database
interfaces, XML trees, or optional values. 

One caveat: It is not assured automatically that the result
translating a for-comprehension is well-typed. To ensure this, the
types of \code{map}, \code{flatMap} and \code{filter} have to be
essentially similar to the types of these methods in class \code{List}.

To make this precise, assume you have a parameterized class
 \code{C[A]} for which you want to enable for-comprehensions. Then
 \code{C} should define \code{map}, \code{flatMap} and \code{filter}
 with the following types:
\begin{lstlisting}
def map[B](f: A => B): C[B]
def flatMap[B](f: A => C[B]): C[B]
def filter(p: A => Boolean): C[A]
\end{lstlisting}
It would be attractive to enforce these types statically in the Scala
compiler, for instance by requiring that any type supporting
for-comprehensions implements a standard trait with these methods
\footnote{In the programming language Haskell, which has similar
constructs, this abstraction is called a ``monad with zero''}.  The
problem is that such a standard trait would have to abstract over the
identity of the class \code{C}, for instance by taking \code{C} as a
type parameter.  Note that this parameter would be a type constructor,
which gets applied to {\em several different} types in the signatures of
methods \code{map} and \code{flatMap}. Unfortunately, the Scala type
system is too weak to express this construct, since it can handle only
type parameters which are fully applied types.

\chapter{Estados Mutáveis}

A maioria dos programas apresentados até o momento não possuem efeitos colaterais.
\footnote{Ignoramos o fato de que algums dos programas imprimem na tela, o que, 
tecnicamente, é um efeito colateral.}.  Portanto, a noção de {\em time} não
importou.  
For a program that terminates,
any sequence of actions would have led to the same result!  This is
also reflected by the substitution model of computation, where a
rewrite step can be applied anywhere in a term, and all rewritings
that terminate lead to the same solution.  In fact, this {\em
confluence} property is a deep result in $\lambda$-calculus, the
theory underlying functional programming. 

In this chapter, we introduce functions with side effects and study
their behavior. We will see that as a consequence we have to
fundamentally modify up the substitution model of computation which we
employed so far.

\section{Stateful Objects}

We normally view the world as a set of objects, some of which have
state that {\em changes} over time.  Normally, state is associated
with a set of variables that can be changed in the course of a
computation.  There is also a more abstract notion of state, which
does not refer to particular constructs of a programming language: An
object {\em has state} (or: {\em is stateful}) if its behavior is
influenced by its history.

For instance, a bank account object has state, because the question
``can I withdraw 100 CHF?''
might have different answers during the lifetime of the account.

In Scala, all mutable state is ultimately built from variables.  A
variable definition is written like a value definition, but starts
with \verb@var@ instead of \verb@val@. For instance, the following two
definitions introduce and initialize two variables \code{x} and
\code{count}.
\begin{lstlisting}
var x: String = "abc"
var count = 111
\end{lstlisting}
Like a value definition, a variable definition associates a name with
a value. But in the case of a variable definition, this association
may be changed later by an assignment.  Such assignments are written
as in C or Java. Examples:
\begin{lstlisting}
x = "hello"
count = count + 1
\end{lstlisting}
In Scala, every defined variable has to be initialized at the point of
its definition. For instance, the statement ~\code{var x: Int;}~ is
{\em not} regarded as a variable definition, because the initializer
is missing\footnote{If a statement like this appears in a class, it is
instead regarded as a variable declaration, which introduces
abstract access methods for the variable, but does not associate these
methods with a piece of state.}. If one does not know, or does not
care about, the appropriate initializer, one can use a wildcard
instead. I.e.
\begin{lstlisting}
val x: T = _
\end{lstlisting}
will initialize \code{x} to some default value (\code{null} for
reference types, \code{false} for booleans, and the appropriate
version of \code{0} for numeric value types).

Real-world objects with state are represented in Scala by objects that
have variables as members. For instance, here is a class that
represents bank accounts.
\begin{lstlisting}
class BankAccount {
  private var balance = 0
  def deposit(amount: Int) {
    if (amount > 0) balance += amount
  }

  def withdraw(amount: Int): Int =
    if (0 < amount && amount <= balance) {
      balance -= amount
      balance
    } else error("insufficient funds")
}
\end{lstlisting}
The class defines a variable \code{balance} which contains the current
balance of an account. Methods \code{deposit} and \code{withdraw}
change the value of this variable through assignments.  Note that
\code{balance} is \code{private} in class \code{BankAccount} -- hence
it can not be accessed directly outside the class.

To create bank-accounts, we use the usual object creation notation:
\begin{lstlisting}
val myAccount = new BankAccount
\end{lstlisting}

\example Here is a \code{scalaint} session that deals with bank
accounts.

\begin{lstlisting}
scala> :l bankaccount.scala
Loading bankaccount.scala...
defined class BankAccount
scala> val account = new BankAccount
account: BankAccount = BankAccount$\Dollar$class@1797795
scala> account deposit 50
unnamed0: Unit = ()
scala> account withdraw 20
unnamed1: Int = 30
scala> account withdraw 20
unnamed2: Int = 10
scala> account withdraw 15
java.lang.Error: insufficient funds
        at scala.Predef$\Dollar$error(Predef.scala:74)
        at BankAccount$\Dollar$class.withdraw(<console>:14)
        at <init>(<console>:5)
scala> 
\end{lstlisting}
The example shows that applying the same operation (\code{withdraw
20}) twice to an account yields different results. So, clearly,
accounts are stateful objects.  

\paragraph{Sameness and Change}
Assignments pose new problems in deciding when two expressions are
``the same''.
If assignments are excluded, and one writes
\begin{lstlisting}
val x = E; val y = E
\end{lstlisting}
where \code{E} is some arbitrary expression,
then \code{x} and \code{y} can reasonably be assumed to be the same.
I.e. one could have equivalently written
\begin{lstlisting}
val x = E; val y = x
\end{lstlisting}
(This property is usually called {\em referential transparency}). But
once we admit assignments, the two definition sequences are different.
Consider:
\begin{lstlisting}
val x = new BankAccount; val y = new BankAccount
\end{lstlisting}
To answer the question whether \code{x} and \code{y} are the same, we
need to be more precise what ``sameness'' means. This meaning is
captured in the notion of {\em operational equivalence}, which,
somewhat informally, is stated as follows.

Suppose we have two definitions of \code{x} and \code{y}.
To test whether \code{x} and \code{y} define the same value, proceed
as follows.
\begin{itemize}
\item
Execute the definitions followed by an
arbitrary sequence \code{S} of operations that involve \code{x} and
\code{y}. Observe the results (if any).
\item
Then, execute the definitions with another sequence \code{S'} which
results from \code{S} by renaming all occurrences of \code{y} in
\code{S} to \code{x}.
\item
If the results of running \code{S'} are different, then surely
\code{x} and \code{y} are different.
\item
On the other hand, if all possible pairs of sequences \lstinline@{S, S'}@
yield the same results, then \code{x} and \code{y} are the same.
\end{itemize}
In other words, operational equivalence regards two definitions
\code{x} and \code{y} as defining the same value, if no possible
experiment can distinguish between \code{x} and \code{y}. An
experiment in this context are two version of an arbitrary program which use either
\code{x} or \code{y}.
 
Given this definition, let's test whether
\begin{lstlisting}
val x = new BankAccount; val y = new BankAccount
\end{lstlisting}
defines values \code{x} and \code{y} which are the same.
Here are the definitions again, followed by a test sequence:

\begin{lstlisting}
> val x = new BankAccount
> val y = new BankAccount
> x deposit 30
30
> y withdraw 20
java.lang.RuntimeException: insufficient funds
\end{lstlisting}

Now, rename all occurrences of \code{y} in that sequence to
\code{x}. We get:
\begin{lstlisting}
> val x = new BankAccount
> val y = new BankAccount
> x deposit 30
30
> x withdraw 20
10
\end{lstlisting}
Since the final results are different, we have established that
\code{x} and \code{y} are not the same.
On the other hand, if we define
\begin{lstlisting}
val x = new BankAccount; val y = x
\end{lstlisting}
then no sequence of operations can distinguish between \code{x} and
\code{y}, so \code{x} and \code{y} are the same in this case.

\paragraph{Assignment and the Substitution Model}
These examples show that our previous substitution model of
computation cannot be used anymore.  After all, under this
model we could always replace a value name by its
defining expression.
For instance in
\begin{lstlisting}
val x = new BankAccount; val y = x
\end{lstlisting}
the \code{x} in the definition of \code{y} could
be replaced by \code{new BankAccount}.
But we have seen that this change leads to a different program.
So the substitution model must be invalid, once we add assignments. 

\section{Imperative Control Structures}

Scala has the \code{while} and \code{do-while} loop constructs known
from the C and Java languages. There is also a single branch \code{if}
which leaves out the else-part as well as a \code{return} statement which
aborts a function prematurely. This makes it possible to program in a
conventional imperative style. For instance, the following function,
which computes the \code{n}'th power of a given parameter \code{x}, is
implemented using \code{while} and single-branch \code{if}.
\begin{lstlisting}
def power(x: Double, n: Int): Double = {
  var r = 1.0
  var i = n
  var j = 0
  while (j < 32) {
    r = r * r
    if (i < 0)
      r *= x
    i = i << 1
    j += 1
  }
  r
}
\end{lstlisting}
These imperative control constructs are in the language for
convenience. They could have been left out, as the same constructs can
be implemented using just functions. As an example, let's develop a
functional implementation of the while loop. \code{whileLoop} should
be a function that takes two parameters: a condition, of type
\code{Boolean}, and a command, of type \code{Unit}. Both condition and
command need to be passed by-name, so that they are evaluated
repeatedly for each loop iteration.  This leads to the following
definition of \code{whileLoop}.
\begin{lstlisting}
def whileLoop(condition: => Boolean)(command: => Unit) {
  if (condition) {
    command; whileLoop(condition)(command)
  } else ()
}
\end{lstlisting}
Note that \code{whileLoop} is tail recursive, so it operates in
constant stack space.

\begin{exercise} Write a function \code{repeatLoop}, which should be 
applied as follows:
\begin{lstlisting}
repeatLoop { command } ( condition )
\end{lstlisting}
Is there also a way to obtain a loop syntax like the following?
\begin{lstlisting}
repeatLoop { command } until ( condition )
\end{lstlisting}
\end{exercise}

Some other control constructs known from C and Java are missing in
Scala: There are no \code{break} and \code{continue} jumps for loops.
There are also no for-loops in the Java sense -- these have been
replaced by the more general for-loop construct discussed in
Section~\ref{sec:for-loops}.

\section{Extended Example: Discrete Event Simulation}

We now discuss an example that demonstrates how assignments and
higher-order functions can be combined in interesting ways.  
We will build a simulator for digital circuits.

The example is taken from Abelson and Sussman's book
\cite{abelson-sussman:structure}. We augment their basic (Scheme-)
code by an object-oriented structure which allows code-reuse through
inheritance. The example also shows how discrete event simulation programs
in general are structured and built.

We start with a little language to describe digital circuits.
A digital circuit is built from {\em wires} and {\em function boxes}.
Wires carry signals which are transformed by function boxes.
We will represent signals by the booleans \code{true} and
\code{false}.

Basic function boxes (or: {\em gates}) are:
\begin{itemize}
\item An \emph{inverter}, which negates its signal
\item An \emph{and-gate}, which sets its output to the conjunction of its input.
\item An \emph{or-gate}, which sets its output to the disjunction of its
input.
\end{itemize}
Other function boxes can be built by combining basic ones.

Gates have {\em delays}, so an output of a gate will change only some
time after its inputs change.

\paragraph{A Language for Digital Circuits}

We describe the elements of a digital circuit by the following set of
Scala classes and functions.

First, there is a class \code{Wire} for wires.
We can construct wires as follows.
\begin{lstlisting}
val a = new Wire
val b = new Wire
val c = new Wire
\end{lstlisting}
Second, there are procedures
\begin{lstlisting}
def inverter(input: Wire, output: Wire)
def andGate(a1: Wire, a2: Wire, output: Wire)
def orGate(o1: Wire, o2: Wire, output: Wire)
\end{lstlisting}
which ``make'' the basic gates we need (as side-effects).
More complicated function boxes can now be built from these.
For instance, to construct a half-adder, we can define:
\begin{lstlisting}
  def halfAdder(a: Wire, b: Wire, s: Wire, c: Wire) {
    val d = new Wire
    val e = new Wire
    orGate(a, b, d)
    andGate(a, b, c)
    inverter(c, e)
    andGate(d, e, s)
  }
\end{lstlisting}
This abstraction can itself be used, for instance in defining a full
adder:
\begin{lstlisting}
  def fullAdder(a: Wire, b: Wire, cin: Wire, sum: Wire, cout: Wire) {
    val s = new Wire
    val c1 = new Wire
    val c2 = new Wire
    halfAdder(a, cin, s, c1)
    halfAdder(b, s, sum, c2)
    orGate(c1, c2, cout)
  }
\end{lstlisting}
Class \code{Wire} and functions \code{inverter}, \code{andGate}, and
\code{orGate} represent thus a little language in which users can
define digital circuits.  We now give implementations of this class
and these functions, which allow one to simulate circuits.
These implementations are based on a simple and general API for
discrete event simulation.

\paragraph{The Simulation API}

Discrete event simulation performs user-defined \emph{actions} at
specified \emph{times}.  
An {\em action} is represented as a function which takes no parameters and
returns a \code{Unit} result:
\begin{lstlisting}
type Action = () => Unit
\end{lstlisting}
The \emph{time} is simulated; it is not the actual ``wall-clock'' time.

A concrete simulation will be done inside an object which inherits
from the abstract \code{Simulation} class. This class has the following
signature:

\begin{lstlisting}
abstract class Simulation {
  def currentTime: Int
  def afterDelay(delay: Int, action: => Action)
  def run()
}
\end{lstlisting}
Here,
\code{currentTime} returns the current simulated time as an integer
number,
\code{afterDelay} schedules an action to be performed at a specified
delay after \code{currentTime}, and
\code{run} runs the simulation until there are no further actions to be 
performed.

\paragraph{The Wire Class}
A wire needs to support three basic actions.
\begin{itemize}
\item[]
\code{getSignal: Boolean}~~ returns the current signal on the wire.
\item[]
\code{setSignal(sig: Boolean)}~~ sets the wire's signal to \code{sig}.
\item[]
\code{addAction(p: Action)}~~ attaches the specified procedure
\code{p} to the {\em actions} of the wire. All attached action
procedures will be executed every time the signal of a wire changes.
\end{itemize}
Here is an implementation of the \code{Wire} class:
\begin{lstlisting}
class Wire {
  private var sigVal = false
  private var actions: List[Action] = List()
  def getSignal = sigVal
  def setSignal(s: Boolean) =
    if (s != sigVal) {
      sigVal = s
      actions.foreach(action => action())
    }
  def addAction(a: Action) {
    actions = a :: actions; a()
  }
}
\end{lstlisting}
Two private variables make up the state of a wire.  The variable
\code{sigVal} represents the current signal, and the variable
\code{actions} represents the action procedures currently attached to
the wire.

\paragraph{The Inverter Class}
We implement an inverter by installing an action on its input wire,
namely the action which puts the negated input signal onto the output
signal.  The action needs to take effect at \code{InverterDelay}
simulated time units after the input changes. This suggests the 
following implementation:
\begin{lstlisting}
def inverter(input: Wire, output: Wire) {
  def invertAction() {
    val inputSig = input.getSignal
    afterDelay(InverterDelay) { output setSignal !inputSig }
  }
  input addAction invertAction
}
\end{lstlisting}

\paragraph{The And-Gate Class}
And-gates are implemented analogously to inverters.  The action of an
\code{andGate} is to output the conjunction of its input signals.
This should happen at \code{AndGateDelay} simulated time units after
any one of its two inputs changes. Hence, the following implementation:
\begin{lstlisting}
def andGate(a1: Wire, a2: Wire, output: Wire) {
  def andAction() {
    val a1Sig = a1.getSignal
    val a2Sig = a2.getSignal
    afterDelay(AndGateDelay) { output setSignal (a1Sig & a2Sig) }
  }
  a1 addAction andAction
  a2 addAction andAction
}
\end{lstlisting}

\begin{exercise} Write the implementation of \code{orGate}.
\end{exercise}

\begin{exercise} Another way is to define an or-gate by a combination of
inverters and and gates. Define a function \code{orGate} in terms of
\code{andGate} and \code{inverter}. What is the delay time of this function?
\end{exercise}

\paragraph{The Simulation Class}

Now, we just need to implement class \code{Simulation}, and we are
done.  The idea is that we maintain inside a \code{Simulation} object
an \emph{agenda} of actions to perform.  The agenda is represented as
a list of pairs of actions and the times they need to be run.  The
agenda list is sorted, so that earlier actions come before later ones.
\begin{lstlisting} 
abstract class Simulation {
  case class WorkItem(time: Int, action: Action)
  private type Agenda = List[WorkItem]
  private var agenda: Agenda = List()
\end{lstlisting}
There is also a private variable \code{curtime} to keep track of the
current simulated time.
\begin{lstlisting}
  private var curtime = 0
\end{lstlisting}
An application of the method \code{afterDelay(delay, block)} 
inserts the element \lstinline@WorkItem(currentTime + delay, () => block)@
into the \code{agenda} list at the appropriate place.
\begin{lstlisting}
private def insert(ag: Agenda, item: WorkItem): Agenda =
  if (ag.isEmpty || item.time < ag.head.time) item :: ag
  else ag.head :: insert(ag.tail, item)

def afterDelay(delay: Int)(block: => Unit) {
  val item = WorkItem(currentTime + delay, () => block)
  agenda = insert(agenda, item)
}
\end{lstlisting}
An application of the \code{run} method removes successive elements
from the \code{agenda} and performs their actions.
It continues until the agenda is empty:
\begin{lstlisting}
private def next() {
  agenda match {
    case WorkItem(time, action) :: rest =>
      agenda = rest; curtime = time; action()
    case List() =>
  }
}

def run() {
  afterDelay(0) { println("*** simulation started ***") }
  while (!agenda.isEmpty) next()
}
\end{lstlisting}

\paragraph{Running the Simulator}
To run the simulator, we still need a way to inspect changes of
signals on wires. To this purpose, we write a function \code{probe}.
\begin{lstlisting}
def probe(name: String, wire: Wire) {
  wire addAction { () =>
    println(name + " " + currentTime + " new_value = " + wire.getSignal)
  }
}
\end{lstlisting}
Now, to see the simulator in action, let's define four wires, and place
probes on two of them: 
\begin{lstlisting}
scala> val input1, input2, sum, carry = new Wire

scala> probe("sum", sum)
sum 0 new_value = false

scala> probe("carry", carry)
carry 0 new_value = false
\end{lstlisting}
Now let's define a half-adder connecting the wires:
\begin{lstlisting}
scala> halfAdder(input1, input2, sum, carry)
\end{lstlisting}
Finally, set one after another the signals on the two input wires to
\code{true} and run the simulation.
\begin{lstlisting}
scala> input1 setSignal true; run
*** simulation started ***
sum 8 new_value = true

scala> input2 setSignal true; run
carry 11 new_value = true
sum 15 new_value = false
\end{lstlisting}

\section{Summary}

We have seen in this chapter the constructs that let us model state in
Scala -- these are variables, assignments, and imperative control
structures.  State and Assignment complicate our mental model of
computation.  In particular, referential transparency is lost.  On the
other hand, assignment gives us new ways to formulate programs
elegantly. As always, it depends on the situation whether purely
functional programming or programming with assignments works best.

\chapter{Computando com Streams}

Os capítulos anteriores apresentaram variáveis, atribuição e objetos com estado.
Vimos como objetos no mundo real mudam com o tempo e podem ser modelados através da
mudança de estado das suas variáveis durante a computação. Desta maneira, mudanças no 
tempo no mundo real  são modeladas por mudanças no tempo durante a execução do programa.
Obviamente, usa-se uma escala e estas mudanças no tempo são alargadas ou comprimidas, mas
sua ordem relativa permanece a mesma. Isto pode parecer natural, mas existe um preço a se
pagar: o modelo de substituição usado na computação funcional não pode ser aplicado ao se
introduzir variáveis e atribuições.

Será que não existe uma outra maneira? Não seria possível modelar mudanças de estado no mundo
real usando somente funções imutáveis? Tomando matemática como um guia, a resposta claramente é sim:
um quantidade que muda no tempo é modelada através da função \code{f(t)} que tem como parâmetro \code{t}
para representar o tempo. O mesmo pode ser feito na computação. Ao invés de sobre-escrever uma variável com
sucessivos valores, podemos representar estes valores como sucessivos elementos em uma lista.
Desta forma, a variável mutável \code{var x: T} pode ser substituída por uma variável imutável \code{val x: List[T]}. 
De certa maneira, troca-se espaço por tempo -- os diferentes valores da variável agora existem concorrentemente como
diferentes elementos da lista. Uma das vantagens do modelo baseado em lista é a possibilidade de ``viajar no tempo'', ou seja,
de ver sucessivos valores da variável ao mesmo tempo. Uma outra vantagem é que podemos fazer uso da poderosa biblioteca de 
funções processamento de listas, que normalmente simplifica a computação. Por exemplo, considere a forma imperativa de computar
a soma de todos os primos em um intervalo:
\begin{lstlisting}
def sumPrimes(start: Int, end: Int): Int = {
  var i = start
  var acc = 0
  while (i < end) {
    if (isPrime(i)) acc += i
    i += 1
  }
  acc
}
\end{lstlisting}
Note que a variável \code{i} ``passa por'' todos os valores do intervalo
\code{[start .. end-1]}.

Uma forma mais funcional, é representar a lista de valores da variável \code{i} diretamente como \code{range(start, end)}. 
Então a função pode ser re-escrita da seguinte maneira:
\begin{lstlisting}
def sumPrimes(start: Int, end: Int) =
  sum(range(start, end) filter isPrime)
\end{lstlisting}

Não dúvida que o programa é mais curto e mais claro! Porém, o 
programa funcional é também consideravelmente menos eficiente, uma
vez que ele constrói a lista de todos os número no intervalo e, posteriormente,
constrói uma outra lista com os números primos. Ainda pior sob o ponto de vista
da eficiência é o seguinte exemplo:

Para encontrar o segundo número primio entre \code{1000} e \code{10000}:
\begin{lstlisting}
  range(1000, 10000) filter isPrime at 1
\end{lstlisting}
Aqui, a lista de todos os números entre \code{1000} e \code{10000} é construída,
mas a maior parte da lista nunca é usada!

No entanto, pode-se obter uma execução eficiente para exemplos como este usando
um truque:
\begin{quote}
%\red
 Nunca compute o resto (tail) de uma sequência a não ser que o resto seja realmente
necessário para a computação.
\end{quote}
Para isso, definimos uma nova classe para sequências, que é chamada \code{Stream}.

Streams são criados usando a constante  \code{empty} e o construtor \code{cons},
ambos definidos no módulo \code{scala.Stream}. Por exemplo, a seguinte expressão constrói
um stream como os elementos \code{1} e \code{2}:
\begin{lstlisting}
Stream.cons(1, Stream.cons(2, Stream.empty))
\end{lstlisting}
Como um outro exemplo, este é o análogo de \code{List.range},
mas que retorna um stream ao invés de uma lista:
\begin{lstlisting}
def range(start: Int, end: Int): Stream[Int] =
  if (start >= end) Stream.empty
  else Stream.cons(start, range(start + 1, end))
\end{lstlisting}
(Esta função também foi definida como mostrado anteriormente no módulo 
\code{Stream}).  Embora \code{Stream.range} e \code{List.range} se pareçam,
seu comportamento em tempo de execução é completamente diferente: 

\code{Stream.range} retorna imediatamente um objeto do tipo \code{Stream} cujo primeiro
elemento é \code{start}.  Todos os outros elementos são computados somente quando eles são 
\emph{demandados} através da chamada do método \code{tail} (o que pode nunca acontecer).  

Streams são acessados exatamente como listas. Similarmente às listas, os métodos básicos de acesso são
 \code{isEmpty}, \code{head} e \code{tail}. Por exemplo, podemos
imprimir todos os elementos de um stream da seguinte maneira.
\begin{lstlisting}
def print(xs: Stream[A]) {
  if (!xs.isEmpty) { Console.println(xs.head); print(xs.tail) }
}
\end{lstlisting}
Streams também oferecem praticamente todos os outros métodos definidos nas listas (veja a seguir onde
os conjuntos de métodos são diferentes). Por exemplo, podemos encontrar o segundo número primo entre 
\code{1000} e \code{10000} através do uso dos métodos 
\code{filter} e \code{apply} no stream que fornece o intervalo:
\begin{lstlisting}
  Stream.range(1000, 10000) filter isPrime at 1
\end{lstlisting}
A diferença entre a implementação anterior que usada lista, é que agora não
construímos nem testamos se é primo nenhum número maior que 1013.

\paragraph{Retorno e concatenação de streams} Há dois métodos na classe \code{List}
que não estão presentes na classe \code{Stream}. São eles \code{::} e
\code{:::}.  O motivo é que estes métodos são chamados pelo argumento da direita, o
que significa que este argumento precisa ser computado antes que o método seja chamado.
Por exemplo, no caso de \code{x :: xs} nas listas, o resto \code{xs} precisa ser computado
antes de \code{::} ser chamado e a nova lista ser construída.
Isto não funciona para streams, onde queremos que o resto de um stream 
não seja computado até que seja demandado pela chamada ao método \code{tail}.
O argumento pelo qual a concatenação de listas \code{:::} não pode ser adaptado para streams
é análogo.

Ao inv\'{e}s de \code{x :: xs}, pode-se usar \code{Stream.cons(x, xs)} para
construir um stream com o primeiro elemento \code{x} e o resto (n\~{a}o computado).
Ao invés de \code{xs ::: ys}, pode-se usar \code{xs append ys}.  


\chapter{Iteradores}

Iteradores s\~{a}o uma vers\~{a}o imperativa dos streams. Assim como streams,
iteradores descrevem listas potencialmente infinitas. No entanto, não existe uma estrutura de dados
que contenha os elementos de um iterador. Ao invés disso, os iteradores permitem que se ande somente um passo
na sequ\^{e}ncia de cada vez, usando os métodos abstratos \code{next} e \code{hasNext}.
\begin{lstlisting}
trait Iterator[+A] {
  def hasNext: Boolean
  def next: A
\end{lstlisting}
O método \code{next} retorna sucessivos elementos.  O método \code{hasNext}
indica se existem mais elementos a serem retornados por
\code{next}. Iteradores também possuem outros métodos que serão explicados posteriormente.

Como exemplo, esta é uma aplicação que imprime os quadrados de todos os números de 1 à 100.
\begin{lstlisting}
val it: Iterator[Int] = Iterator.range(1, 100)
while (it.hasNext) {
  val x = it.next
  println(x * x)
}
\end{lstlisting}

\section{Métodos dos Iteradores}

Os iteradores possuem um conjunto de métodos além de \code{next} e
\code{hasNext}, que são descritos a seguir. Muitos destes métodos
oferecem uma funcionalidade correspondente à do método equivalente em uma lista.

\paragraph{Append}
O método \code{append} constrói uma iterador que começa com o código dado de iteração ~\code{it}~ depois 
que o iterador atual tem terminado.
\begin{lstlisting}
  def append[B >: A](that: Iterator[B]): Iterator[B] = new Iterator[B] {
    def hasNext = Iterator.this.hasNext || that.hasNext
    def next = if (Iterator.this.hasNext) Iterator.this.next else that.next
  }    
\end{lstlisting}
Os termos \code{Iterator.this.next} e \code{Iterator.this.hasNext}
na definição de \code{append} chamam os métodos correspondentes definidos na classe \code{Iterator} 
que contém o método \code{append}. Se o prefixo
\code{Iterator} não fosse adicionado ao \code{this},
\code{hasNext} e \code{next} chamariam recursivamente os métodos definidos no resultado de \code{append},
o que não era o efeito desejado.

\paragraph{Map, FlatMap, Foreach} O método \code{map} 
constrói um iterador que retorna todos os elementos do iterador original transformados por uma dada função \code{f}.
\begin{lstlisting}
  def map[B](f: A => B): Iterator[B] = new Iterator[B] {
    def hasNext = Iterator.this.hasNext
    def next = f(Iterator.this.next)
  }
\end{lstlisting}
O método \code{flatMap} é similar ao método \code{map}, exceto que a função de transformação \code{f} retorna um iterador 
ao invés de um elemento. O resultado de \code{flatMap} é um iterador resultante da anexação (\code{append}) de todos os iteradores resultantes
das sucessivas chamadas de \code{f}.
\begin{lstlisting}
  def flatMap[B](f: A => Iterator[B]): Iterator[B] = new Iterator[B] {
    private var cur: Iterator[B] = Iterator.empty
    def hasNext: Boolean =
      if (cur.hasNext) true
      else if (Iterator.this.hasNext) { cur = f(Iterator.this.next); hasNext }
      else false
    def next: B =
      if (cur.hasNext) cur.next
      else if (Iterator.this.hasNext) { cur = f(Iterator.this.next); next }
      else error("next on empty iterator")
  }
\end{lstlisting}
Também relacionado à \code{map}, temos o método \code{foreach} que aplica uma
dada função a todos elementos de um iterador, mas não constrói uma lista de resultados
\begin{lstlisting}
  def foreach(f: A => Unit): Unit =
    while (hasNext) { f(next) }
\end{lstlisting}

\paragraph{Filter} O método \code{filter} constrói um iterador que retorna
todos os elementos do iterador original que satisfazem um dado critério \code{p}.
\begin{lstlisting}
  def filter(p: A => Boolean) = new BufferedIterator[A] {
    private val source =
      Iterator.this.buffered
    private def skip =
      { while (source.hasNext && !p(source.head)) { source.next } }
    def hasNext: Boolean =
      { skip; source.hasNext }
    def next: A =
      { skip; source.next }
    def head: A =
      { skip; source.head }
  }
\end{lstlisting}
Na prática, \code{filter} retorna uma instância de uma sub-classe dos iteradores que trabalha com um
 ``buffer''.  Um objeto do tipo \code{BufferedIterator} é um iterador que tem adicionalmente um método
 \code{head}. Este método retorna um elemento que seria retornado pelo método \code{next}, porém
não avança além daquele elemento. Com isso, o elemento retornado por \code{head} é retornado novamente
pela próxima chamada de \code{head} ou \code{next}. Esta é a definição do trait 
\code{BufferedIterator}:
\begin{lstlisting}
trait BufferedIterator[+A] extends Iterator[A] {
  def head: A
}
\end{lstlisting}
Como \code{map}, \code{flatMap}, \code{filter} e \code{foreach}
existem para iteradores, como consequência for-comprehensions e loops de for também podem ser usados em iteradores.
Por exemplo, a aplicação que imprime os quadrados dos números entre 1 e 100 poderia ter sido expressada da seguinte forma:
\begin{lstlisting}
for (i <- Iterator.range(1, 100))
  println(i * i)
\end{lstlisting}

\paragraph{Zip} O método \code{zip} recebe um outro iterador e retorna um iterador que consiste
de pares dos respectivos elementos retornados pelos dois iteradores.
\begin{lstlisting}
  def zip[B](that: Iterator[B]) = new Iterator[(A, B)] {
    def hasNext = Iterator.this.hasNext && that.hasNext
    def next = (Iterator.this.next, that.next)
  }
}
\end{lstlisting}

\section{Construindo Iteradores}

As classes concretas de iteradores precisam implementar os dois métodos abstratos
 \code{next} e \code{hasNext} definidos na classe
\code{Iterator}. O iterador mais simples é \code{Iterator.empty} que sempre retorna uma
sequência vazia:
\begin{lstlisting}
object Iterator {
  object empty extends Iterator[Nothing] {
    def hasNext = false
    def next = error("next on empty iterator")
  }
\end{lstlisting}
Um iterador um pouco mais interessante enumera todos os elementos de um vetor. Este iterador
é construído a partir do método \code{fromArray}, que também foi definido no objeto \code{Iterator}
\begin{lstlisting}
  def fromArray[A](xs: Array[A]) = new Iterator[A] {
    private var i = 0
    def hasNext: Boolean =
      i < xs.length
    def next: A =
      if (i < xs.length) { val x = xs(i); i += 1; x }
      else error("next on empty iterator")
  }
\end{lstlisting}
Um outro iterador enumera um intervalo de inteiros. A função
\code{Iterator.range} retorna o iterador que caminha em um intervalo dado de valores inteiros.
Sua definição é a seguinte:
\begin{lstlisting}
object Iterator {
  def range(start: Int, end: Int) = new Iterator[Int] {
    private var current = start
    def hasNext = current < end
    def next = {
      val r = current
      if (current < end) current += 1
      else error("end of iterator")
      r
    }
  }
}
\end{lstlisting}
Todos os iteradores mostrados até agora tem um fim. Também é possível
definir iteradores que nunca terminam. Por exemplo, o iterador a seguir
retorna inteiros sucessivos a partir de um valor inicial. 
\footnote{Como a representação do tipo \prog{int} é finita, os números acabaram em $2^{31}$.}.
\begin{lstlisting}
def from(start: Int) = new Iterator[Int] {
  private var last = start - 1
  def hasNext = true
  def next = { last += 1; last }
}
\end{lstlisting}

\section{Usando Iteradores}

Existem mais 2 exemplos de como os iteradores são usados. Primeiro, para imprimir todos
os elementos de um vetor \code{xs: Array[Int]}, uma pessoa pode escrever:
\begin{lstlisting}
  Iterator.fromArray(xs) foreach (x => println(x))
\end{lstlisting}
Ou, usando for-comprehension:
\begin{lstlisting}
  for (x <- Iterator.fromArray(xs))
    println(x)
\end{lstlisting}
Como um segundo exemplo, considere o problema de encontrar os índices de todos os elementos de um vetor de \code{double}s maiores que um dado \code{limit}. Os índices devem ser retornado na forma de um iterador.
Isto pode ser obtido pela expressão:
\begin{lstlisting}
import Iterator._
fromArray(xs)
.zip(from(0))
.filter(case (x, i) => x > limit)
.map(case (x, i) => i)
\end{lstlisting}
Ou usando for-comprehension:
\begin{lstlisting}
import Iterator._
for ((x, i) <- fromArray(xs) zip from(0); x > limit)
yield i
\end{lstlisting}

\chapter{Valores Preguiçosos (Lazy)}

Valores Preguiçosos oferecem uma maneira de postergar a inicialização de um valor até o primeiro 
momento em que seja acessado. Isto pode ser útil quando estiver lidando com valores que podem não ser
necessários durante a execução e cujo custo computacional seja significativo. Como primeiro exemplo,
vamos considerar um banco de dados de empregados contendo cada empregado e seu gestor e sua equipe.
\begin{lstlisting}
case class Employee(id: Int, 
                    name: String, 
                    managerId: Int) {
  val manager: Employee = Db.get(managerId)
  val team: List[Employee] = Db.team(id)
}
\end{lstlisting}

A classe \lstinline@Employee@ dada anteriormente irá tentar inicializar todos os seus campos, carregando todoa a tabela
de empregados na memória. Isto certamente não é o ideal e pode ser melhorado como facilidade tornando os campos
preguiçosos. Desta forma, atrasamos o acesso ao banco de dados até o momento em que ele seja realmente necessário, se isto ocorrer.
\begin{lstlisting}
case class Employee(id: Int, 
                    name: String, 
                    managerId: Int) {
  lazy val manager: Employee = Db.get(managerId)
  lazy val team: List[Employee] = Db.team(id)
}
\end{lstlisting}
Para ver o que realmente está acontecendo, podemos usar este banco de dados mock
que mostra quando os registros são acessados:
\begin{lstlisting}
object Db {
  val table = Map(1 -> (1, "Haruki Murakami", -1),
                  2 -> (2, "Milan Kundera", 1),
                  3 -> (3, "Jeffrey Eugenides", 1),
                  4 -> (4, "Mario Vargas Llosa", 1),
                  5 -> (5, "Julian Barnes", 2))

  def team(id: Int) = {
    for (rec <- table.values.toList; if rec._3 == id)
      yield recToEmployee(rec)
  }

  def get(id: Int) = recToEmployee(table(id))

  private def recToEmployee(rec: (Int, String, Int)) = {
    println("[db] fetching " + rec._1)
    Employee(rec._1, rec._2, rec._3)
  }
}
\end{lstlisting}
Ao rodar o programa, a saída confirma que ele retorna um empregado e que
o banco somente é acessado quando é feita uma referência ao valor preguiçoso.

Um outro uso dos valores preguiçosos é para resolver a ordem de inicialização
de aplicações compostas de muitos módulos. Antes dos valores preguiçosos serem
criados, o mesmo efeito era conquistado usando definições do tipo \lstinline@object@. 
Como um segundo exemplo considere um compilador composto de diversos módulos. Olhamos
primeiro para uma tabela de símbolos que definie uma classe para símbolos e duas funções pré-definidas.
\begin{lstlisting}
class Symbols(val compiler: Compiler) {
  import compiler.types._

  val Add = new Symbol("+", FunType(List(IntType, IntType), IntType))
  val Sub = new Symbol("-", FunType(List(IntType, IntType), IntType))

  class Symbol(name: String, tpe: Type) {
    override def toString = name + ": " + tpe
  }
}
\end{lstlisting}
O módulo  \lstinline@Symbols@ é parametrizado com uma instância de  \lstinline@Compiler@
que permite o acesso a outros serviços, tais como o módulo de tipos. Em nosso exemplo, há somente
duas funções pré-definidas, adição e subtração e suas definições dependem do módulo \lstinline@types@.
\begin{lstlisting}
class Types(val compiler: Compiler) {
  import compiler.symtab._

  abstract class Type
  case class FunType(args: List[Type], res: Type) extends Type
  case class NamedType(sym: Symbol) extends Type
  case object IntType extends Type
}
\end{lstlisting}
Para conectar os dois componentes, um objeto do tipo compilador é criado e passado com parâmetro para os
dois componentes.
\begin{lstlisting}
class Compiler {
  val symtab = new Symbols(this)
  val types  = new Types(this)
}
\end{lstlisting}
Infelizmente, esta abordagem falha em tempo de execução, pois o módulo 
\lstinline@symtab@ depende do módulo  \lstinline@types@. De maneira geral,
a dependência entre os módulos pode ficar complicada e conseguir a ordem correta
de inicialização é difícil ou, até mesmo, impossível, quando existem dependências cíclicas.
A maneira mais simples de corrigir este erro é tornar estes campos 
\lstinline@lazy@ e deixar o compilador descobrir qual é a ordem correta de inicialização.
\begin{lstlisting}
class Compiler {
  lazy val symtab = new Symbols(this)
  lazy val types  = new Types(this)
}
\end{lstlisting}
Aogra os dois módulos são inicializados no primeiro acesso e o compilador pode executar da forma
esperada.

\subsection*{Sintaxe}
O modificador \lstinline@lazy@ é permitido apenas na definição de valores concretos.
Todas as regras válidas para definição de valores se aplicam também para valores do tipo 
\lstinline@lazy@, com uma restrição a menos: valores locais recursivos são permitidos.

\chapter{Parâmetros Implícitos e Conversões}\label{sec:implicits}

Parâmetros implícitos e conversões são ferramentas poderosas para personalizar bibliotecas
existentes e para criar abstrações de alto-nível.
Como exemplo, vamos começar com uma classe abstrata \lstinline@SemiGroup@ que contém uma operação não especificada chamada \lstinline@add@.
\begin{lstlisting}
abstract class SemiGroup[A] {
  def add(x: A, y: A): A
}
\end{lstlisting}
Aqui está a sub-classe abstrata \lstinline@Monoid@ que herda de  \lstinline@SemiGroup@ e inclui um novo elemento
\lstinline@unit@.
\begin{lstlisting}
abstract class Monoid[A] extends SemiGroup[A] {
  def unit: A
}
\end{lstlisting}
Aqui estão duas implementações de \lstinline@Monoid@:
\begin{lstlisting}
object stringMonoid extends Monoid[String] {
  def add(x: String, y: String): String = x.concat(y)
  def unit: String = ""
}

object intMonoid extends Monoid[Int] {
  def add(x: Int, y: Int): Int = x + y
  def unit: Int = 0
}
\end{lstlisting}
O método \lstinline@sum@, que funciona com monoids arbitrários pode ser escrito em Scala da seguinte forma:
\begin{lstlisting}
def sum[A](xs: List[A])(m: Monoid[A]): A =
  if (xs.isEmpty) m.unit
  else m.add(xs.head, sum(m)(xs.tail)
\end{lstlisting}
O método \lstinline@sum@ pode ser chamado da seguinte forma:
\begin{lstlisting}
sum(List("a", "bc", "def"))(stringMonoid)
sum(List(1, 2, 3))(intMonoid)
\end{lstlisting}
Embora tudo isso funcione, o código não fica muito limpo. O problema
é que as implementações de monoid tem que ser passada para todo o código que as usa.
Nós gostaríamos que o sistema conseguisse descobrir os argumentos de forma correta e automática, semelhante
ao que é feito quando o tipo de parâmetros é inferido. Isto é o que os parâmetros implícitos permite.

\subsection*{Noções Básicas sobre Parâmetros Implícitos}

Na versão 2 de Scala, há uma nova palavra-chave (\lstinline@implicit@) que pode ser usada no início de uma lista de parâmetros. Sintaxe:
\begin{lstlisting}
ParamClauses ::= {`(' [Param {`,' Param}] ')'} 
                 [`(' implicit Param {`,' Param} `)']
\end{lstlisting}
Se esta palavra chave estiver presente, todos os parâmetros da lista serão implícitos.
Por exemplo, a versão de \lstinline@sum@ a seguir tem 
\lstinline@m@ como um parâmetro implícito.
\begin{lstlisting}
def sum[A](xs: List[A])(implicit m: Monoid[A]): A =
  if (xs.isEmpty) m.unit
  else m.add(xs.head, sum(xs.tail))
\end{lstlisting}
Como pode ser visto no exemplo, é possível combinar parâmetros normais e implícitos. No entanto,
pode haver apenas uma lista de parâmetros implícitos e ela deve vir por último.

\lstinline@implicit@ também pode ser usado como um modificador de declarações e definições. Exemplos:

\begin{lstlisting}
implicit object stringMonoid extends Monoid[String] {
  def add(x: String, y: String): String = x.concat(y)
  def unit: String = ""
}
implicit object intMonoid extends Monoid[Int] {
  def add(x: Int, y: Int): Int = x + y
  def unit: Int = 0
}
\end{lstlisting}

A principal ideia por trás de parâmetros implícitos é que argumentos para eles
podem ser omitidos em uma chamada de método. Se os argumentos estiverem ausentes,
eles serão inferidos pelo compilador de Scala.

Os argumento atuais que são elegíveis a serem passados implicitamente por parâmetro são
todos os identificadores X que puderem ser acessado no ponto em que o método é chamado sem
o uso de prefixo e que denotem uma definição implícita ou parâmetro.

Se existem mais do que um argumento elegíveis que casam com o tipo do parâmetro, o compilador Scala vai
escolher o mais específico usando as regras padrâo para resolução de sobrecarga.
Por exemplo, dada a chamada
\begin{lstlisting}
  sum(List(1, 2, 3))
\end{lstlisting}
está em um contexto onde \lstinline@stringMonoid@ e \lstinline@intMonoid@
estão visíveis. Nós sabemos que o tipo genérico \lstinline@A@ do método
\lstinline@sum@ precisa ser instanciado usando \lstinline@int@. O único valor elegível que casa com
o parâmetro implícito \lstinline@Monoid[Int]@ é o \lstinline@intMonoid@ e por isso este objeto será passado
como parâmetro implícito.

A discussão mostra também que parâmetros implícitos são inferidos depois que o tipo dos outros parâmetros
são inferidos.

\subsection*{Conversões Implícitas}

Digamos que você tenha uma expressão $E$ do tipo $T$ onde é esperado um tipo
$S$. $T$ não é um sub-tipo de $S$ e nem é conversível para $S$ por alguma conversão pré-definida. 
Nesse caso, o compilador Scala irá tentar como um último recurso uma conversão implícita  $I(E)$. 
Onde, $I$ é um identificador que denota a definição implícita ou parâmetro que seja acessível sem prefixo
no ponto da conversão e que contenha uma função ao qual podem ser usados como argumentos valores do tipo  $T$ 
e cujo resultado seja do tipo $S$ ou sub-tipo do mesmo.

Conversões Implícitas podem também ser usadas na seleção de membros.
Dada a chamada $E.x$ onde $x$ não é um membro do tipo $E$, o compilador
Scala irá tentar inserir uma conversão implícita $I(E).x$, de maneira que $x$ seja um membro de $I(E)$.

Aqui está um exemplo de uma função de conversão implícita que converte 
inteiros em instâncias da classe \lstinline@scala.Ordered@:
\begin{lstlisting}
implicit def int2ordered(x: Int): Ordered[Int] = new Ordered[Int] {
  def compare(y: Int): Int =
    if (x < y) -1
    else if (x > y) 1
    else 0
}
\end{lstlisting}

\subsection*{Parâmetros de Tipos Delimitados}

Parâmetros de Tipos Delimitados\footnote{View bounds} são uma sintaxe simplificada\footnote{Syntactic sugar}
 e conveniente para parâmetros implícitos. 
Considere por exemplo, um método de ordenação genérico:
\begin{lstlisting}
def sort[A <$\mbox{\%}$ Ordered[A]](xs: List[A]): List[A] =
  if (xs.isEmpty || xs.tail.isEmpty) xs
  else {
    val {ys, zs} = xs.splitAt(xs.length / 2)
    merge(ys, zs)
  }
\end{lstlisting}
O parâmetros de tipo delimitado \lstinline@[A <$\mbox{\%}$ Ordered[A]]@
expressa que  \lstinline@sort@ pode ser usado com listas do tipo 
\lstinline@A@ onde exista uma conversão implícita de 
\lstinline@A@ para \lstinline@Ordered[A]@. A definição é tratada como um atalho para a seguinte
assinatura de método com parâmetro implícito:
\begin{lstlisting}
def sort[A](xs: List[A])(implicit $c$: A => Ordered[A]): List[A] = ...
\end{lstlisting}
(Aqui o nome do parâmetro $c$ foi escolhido arbitrariamente, garantindo-se que 
não era um nome já usado no programa.)

Como um exemplo mais detalhado, considere o método \lstinline@merge@ que vêm com
o método \lstinline@sort@ citado anteriormente:
\begin{lstlisting}
def merge[A <$\mbox{\%}$ Ordered[A]](xs: List[A], ys: List[A]): List[A] =
  if (xs.isEmpty) ys
  else if (ys.isEmpty) xs
  else if (xs.head < ys.head) xs.head :: merge(xs.tail, ys)
  else if ys.head :: merge(xs, ys.tail)
\end{lstlisting}
Depois de expandir os parâmetros de tipo delimitado e inserir as conversões implícitas
a implementação deste método ficaria assim:
\begin{lstlisting}
def merge[A](xs: List[A], ys: List[A])
            (implicit $c$: A => Ordered[A]): List[A] =
  if (xs.isEmpty) ys
  else if (ys.isEmpty) xs
  else if (c(xs.head) < ys.head) xs.head :: merge(xs.tail, ys)
  else if ys.head :: merge(xs, ys.tail)(c)
\end{lstlisting}

As duas últimas linhas da definição do método ilustram dois diferentes usos
do parâmetro implícito $c$. Ele é usado na conversão da condição na penúltima linha e passado
como parãmetro implícito na chamada recursiva de \lstinline@merge@ na última linha.

\comment{
\chapter{Combinator Parsing}\label{sec:combinator-parsing}

In this chapter we describe how to write combinator parsers in
Scala. Such parsers are constructed from predefined higher-order
functions, so called {\em parser combinators}, that closely model the
constructions of an EBNF grammar \cite{wirth:ebnf}.

As running example, we consider parsers for possibly nested
lists of identifiers and numbers, which
are described by the following context-free grammar.
\bda{p{3cm}cp{10cm}}
letter &::=& /* all letters */ \\
digit  &::=& /* all digits */ \\[0.5em]
ident  &::=& letter \{letter $|$ digit \}\\
number &::=& digit \{digit\}\\[0.5em]
list   &::=& `(' [listElems] `)' \\
listElems &::=& expr [`,' listElems] \\
expr   &::=& ident | number | list

\eda

\section{Simple Combinator Parsing}

In this section we will only be concerned with the task of recognizing
input strings, not with processing them. So we can describe parsers
by the sets of input strings they accept.  There are two
fundamental operators over parsers:
\code{&} expresses the sequential composition of a parser with
another, while \code{|} expresses an alternative. These operations
will both be defined as methods of a \code{Parser} class.  We will
also define constructors for the following primitive parsers:

\begin{tabular}{ll}
\code{empty}    & The parser that accepts the empty string
\\
\code{failure(msg: String)}  & The parser that accepts no string (\verb@msg@ 
                               stands for an error message)

\\
\code{chr(c: char)}
                & The parser that accepts the single-character string ``$c$''.
\\
\code{chrSuchThat(p: Char => Boolean)}
                & The parser that accepts single-character strings
                  ``$c$'' \\
                & for which $p(c)$ is true.
\end{tabular}

There are also the two higher-order parser combinators \code{opt},
expressing optionality and \code{rep}, expressing repetition.
For any parser $p$, \code{opt(}$p$\code{)} yields a parser that
accepts the strings accepted by $p$ or else the empty string, while
\code{rep(}$p$\code{)} accepts arbitrary sequences of the strings accepted by
$p$. In EBNF, \code{opt(}$p$\code{)} corresponds to $[p]$ and
\code{rep(}$p$\code{)} corresponds to $\{p\}$.

The central idea of parser combinators is that parsers can be produced
by a straightforward rewrite of the grammar, replacing \code{::=} with
\code{=}, sequencing with
\code{&}, repetition \code{\{...\}} with
\code{rep(...)} and optional occurrence \code{[...]} with \code{opt(...)}.
Applying this process to the grammar of lists
yields the following trait.
\begin{lstlisting}
trait ListParsers extends Parsers {
  def chrSuchThat(p: Char => Boolean): Parser
  def chr(c: Char): Parser = chrSuchThat(d ==)

  def letter    : Parser = chr(Character.isLetter)
  def digit     : Parser = chr(Character.isDigit)

  def ident     : Parser = letter &&& rep(letter ||| digit)
  def number    : Parser = digit &&& rep(digit)
  def list      : Parser = chr('(') &&& opt(listElems) &&& chr(')')
  def listElems : Parser = expr &&& (chr(',') &&& listElems ||| empty)
  def expr      : Parser = ident ||| number ||| list
}
\end{lstlisting}
This class isolates the grammar from other aspects of parsing. It
abstracts over the type of input 
and over the method used to parse a single character
(represented by the abstract method \code{chr(p: char =>
boolean))}. The missing bits of information need to be supplied by code
applying the parser class.

It remains to explain how to implement a library with the combinators
described above. We will pack combinators and their underlying
implementation in a base class \code{Parsers}, which is inherited by
\code{ListParsers}.  The first question to decide is which underlying
representation type to use for a parser. We treat parsers here
essentially as functions that take a datum of the input type
\code{InType} and that yield a parse result of type
\code{Option[InType]}.  The \code{Option} type is predefined as
follows.
\begin{lstlisting}
abstract class Option[+a]
case object None extends Option[Nothing]
case class Some[a](x: a) extends Option[a]
\end{lstlisting}
A parser applied to some input either succeeds or fails. If it fails,
it returns the constant \code{None}. If it succeeds, it returns a
value of the form \code{Some(in1)} where \code{in1} represents the
input that remains to be parsed.
\begin{lstlisting}
trait Parsers {
  type InType
  abstract class Parser {
    type Result = Option[InType]
    def apply(in: InType): Result
\end{lstlisting}
A parser also implements the combinators
for sequence and alternative:
\begin{lstlisting}
  /*** p &&& q applies first p, and if that succeeds, then q
   */
  def &&& (q: => Parser) = new Parser {
    def apply(in: InType): Result = Parser.this.apply(in) match {
      case None => None
      case Some(in1)  => q(in1)
    }
  }

  /*** p ||| q applies first p, and, if that fails, then q.
   */
  def ||| (q: => Parser) = new Parser {
    def apply(in: InType): Result = Parser.this.apply(in) match {
      case None => q(in)
      case s => s
    }
  }
\end{lstlisting}
The implementations of the primitive parsers \code{empty} and \code{fail}
are trivial:
\begin{lstlisting}
  val empty = new Parser { def apply(in: InType): Result = Some(in) }
  val fail  = new Parser { def apply(in: InType): Result = None }
\end{lstlisting}
The higher-order parser combinators \code{opt} and \code{rep} can be
defined in terms of the combinators for sequence and alternative:
\begin{lstlisting}
  def opt(p: Parser): Parser = p ||| empty;    // p? = (p | <empty>)
  def rep(p: Parser): Parser = opt(rep1(p));   // p* = [p+]
  def rep1(p: Parser): Parser = p &&& rep(p);  // p+ = p p*
} // end Parser
\end{lstlisting}
To run combinator parsers, we still need to decide on a way to handle
parser input. Several possibilities exist: The input could be
represented as a list, as an array, or as a random access file.  Note
that the presented combinator parsers use backtracking to change from
one alternative to another.  Therefore, it must be possible to reset
input to a point that was previously parsed. If one restricted the
focus to LL(1) grammars, a non-backtracking implementation of the
parser combinators in class \code{Parsers} would also be possible. In
that case sequential input methods based on (say) iterators or
sequential files would also be possible.

In our example, we represent the input by a pair of a string, which
contains the input phrase as a whole, and an index, which represents
the portion of the input which has not yet been parsed. Since the
input string does not change, just the index needs to be passed around
as a result of individual parse steps.  This leads to the following
class of parsers that read strings:
\begin{lstlisting}
class ParseString(s: String) extends Parsers {
  type InType = Int
  def chrSuchThat(p: Char => Boolean) = new Parser {
    def apply(in: Int): Parser#Result =
      if (in < s.length() && p(s charAt in)) Some(in + 1)
      else None
  }
  val input = 0
}
\end{lstlisting}
This class implements a method \code{chr(p: Char => Boolean)} and a
value \code{input}. The \code{chr} method builds a parser that either
reads a single character satisfying the given predicate \code{p} or
fails.  All other parsers over strings are ultimately implemented in
terms of that method. The \code{input} value represents the input as a
whole. In out case, it is simply value \code{0}, the start index of
the string to be read.

Note \code{apply}'s result type, \code{Parser#Result}. This syntax
selects the type element \code{Result} of the type \code{Parser}. It
thus corresponds roughly to selecting a static inner class from some
outer class in Java. Note that we could {\em not} have written
\code{Parser.Result}, as the latter would express selection of the
\code{Result} element from a {\em value} named \code{Parser}.

We have now extended the root class \code{Parsers} in two different
directions: Class \code{ListParsers} defines a grammar of phrases to
be parsed, whereas class \code{ParseString} defines a method by which
such phrases are input. To write a concrete parsing application, we
need to define both grammar and input method. We do this by combining
two extensions of \code{Parsers} using a {\em mixin composition}.
Here is the start of a sample application:
\begin{lstlisting}
object Test {
  def main(args: Array[String]) {
    val ps = new ParseString(args(0)) with ListParsers
  }
\end{lstlisting}
The last line above creates a new family of parsers by composing class
\code{ListParsers} with class \code{ParseString}. The two classes
share the common superclass \code{Parsers}. The abstract method
\code{chr} in \code{ListParsers} is implemented by class \code{ParseString}.

To run the parser, we apply the start symbol of the grammar
\code{expr} the argument code{input} and observe the result:
\begin{lstlisting}
    ps.expr(ps.input) match {
      case Some(n) =>
        println("parsed: " + args(0).substring(0, n))
      case None =>
        println("nothing parsed")
    }
  }
}// end Test
\end{lstlisting}
Note the syntax ~\code{ps.expr(input)}, which treats the \code{expr}
parser as if it was a function. In Scala, objects with \code{apply}
methods can be applied directly to arguments as if they were functions.

Here is an example run of the program above:
\begin{lstlisting}
> java examples.Test "(x,1,(y,z))"
parsed: (x,1,(y,z))
> java examples.Test "(x,,1,(y,z))"
nothing parsed
\end{lstlisting}

\section{\label{sec:parsers-results}Parsers that Produce Results}

The combinator library of the previous section does not support the
generation of output from parsing. But usually one does not just want
to check whether a given string belongs to the defined language, one
also wants to convert the input string into some internal
representation such as an abstract syntax tree.

In this section, we modify our parser library to build parsers that
produce results. We will make use of the for-comprehensions introduced
in Chapter~\ref{sec:for-notation}.  The basic combinator of sequential
composition, formerly ~\code{p &&& q}, now becomes
\begin{lstlisting}
for (x <- p; y <- q) yield e .
\end{lstlisting}
Here, the names \code{x} and \code{y} are bound to the results of
executing the parsers \code{p} and \code{q}. \code{e} is an expression
that uses these results to build the tree returned by the composed
parser.

Before describing the implementation of the new parser combinators, we
explain how the new building blocks are used. Say we want to modify
our list parser so that it returns an abstract syntax tree of the
parsed expression. Syntax trees are given by the following class hierarchy:
\begin{lstlisting}
abstract class Tree
case class Id (s: String)         extends Tree
case class Num(n: Int)            extends Tree
case class Lst(elems: List[Tree]) extends Tree
\end{lstlisting}
That is, a syntax tree is an identifier, an integer number, or a
\code{Lst} node with a list of trees as descendants.

As a first step towards parsers that produce results we define three
little parsers that return a single read character as result.
\begin{lstlisting}
trait CharParsers extends Parsers {
  def any: Parser[Char]
  def chr(ch: Char): Parser[Char] =
    for (c <- any if c == ch) yield c
  def chrSuchThat(p: Char => Boolean): Parser[Char] =
    for (c <- any if p(c)) yield c
}
\end{lstlisting}
The \code{any} parser succeeds with the first character of remaining
input as long as input is nonempty. It is abstract in class
\code{ListParsers} since we want to abstract in this class from the
concrete input method used.  The two \code{chr} parsers return as before
the first input character if it equals a given character or matches a
given predicate. They are now implemented in terms of \code{any}.

The next level is represented by parsers reading identifiers, numbers
and lists. Here is a parser for identifiers.
\begin{lstlisting}
trait ListParsers extends CharParsers {
  def ident: Parser[Tree] = 
    for {
      c: Char <- chrSuchThat(Character.isLetter)
      cs: List[Char] <- rep(chrSuchThat(Character.isLetterOrDigit))
    } yield Id((c :: cs).mkString("", "", ""))
\end{lstlisting}
Remark: Because \code{chrSuchThat(...)} returns a single character, its
repetition \code{rep(chrSuchThat(...))} returns a list of characters. The
\code{yield} part of the for-comprehension converts all intermediate
results into an \code{Id} node with a string as element.  To convert
the read characters into a string, it conses them into a single list,
and invokes the \code{mkString} method on the result.

Here is a parser for numbers:
\begin{lstlisting}
  def number: Parser[Tree] =
    for {
      d: Char <- chrSuchThat(Character.isDigit)
      ds: List[Char] <- rep(chrSuchThat(Character.isDigit))
    } yield Num(((d - '0') /: ds) ((x, digit) => x * 10 + digit - '0'))
\end{lstlisting}
Intermediate results are in this case the leading digit of
the read number, followed by a list of remaining digits.  The
\code{yield} part of the for-comprehension reduces these to a number
by a fold-left operation.

Here is a parser for lists:
\begin{lstlisting}
  def list: Parser[Tree] = 
    for {
      _ <- chr('(')
      es <- listElems ||| succeed(List())
      _ <- chr(')')
    } yield Lst(es)

  def listElems: Parser[List[Tree]] = 
    for {
      x <- expr
      xs <- chr(',') &&& listElems ||| succeed(List())
    } yield x :: xs
\end{lstlisting}
The \code{list} parser returns a \code{Lst} node with a list of trees
as elements.  That list is either the result of \code{listElems}, or,
if that fails, the empty list (expressed here as: the result of a
parser which always succeeds with the empty list as result).

The highest level of our grammar is represented by function
\code{expr}:
\begin{lstlisting}
  def expr: Parser[Tree] = 
    ident ||| number ||| list
}// end ListParsers.
\end{lstlisting}
We now present the parser combinators that support the new
scheme. Parsers that succeed now return a parse result besides the
un-consumed input.
\begin{lstlisting}
trait Parsers {
  type InType
  abstract class Parser[A] {
    type Result = Option[(A, InType)]
    def apply(in: InType): Result
\end{lstlisting}
Parsers are parameterized with the type of their result. The class
\code{Parser[a]} now defines new methods \code{map}, \code{flatMap}
and \code{filter}. The \code{for} expressions are mapped by the
compiler to calls of these functions using the scheme described in
Chapter~\ref{sec:for-notation}. For parsers, these methods are
implemented as follows.
\begin{lstlisting}
    def filter(pred: A => Boolean) = new Parser[A] {
      def apply(in: InType): Result = Parser.this.apply(in) match {
        case None => None
        case Some(x, in1) => if (pred(x)) Some(x, in1) else None
      }
    }
    def map[B](f: A => B) = new Parser[B] {
      def apply(in: InType): Result = Parser.this.apply(in) match {
        case None => None
        case Some(x, in1) => Some(f(x), in1)
      }
    }
    def flatMap[b](f: A => Parser[B]) = new Parser[B] {
      def apply(in: InType): Result = Parser.this.apply(in) match {
        case None => None
        case Some(x, in1) => f(x).apply(in1)
      }
    }
\end{lstlisting}
The \code{filter} method takes as parameter a predicate $p$ which it
applies to the results of the current parser. If the predicate is
false, the parser fails by returning \code{None}; otherwise it returns
the result of the current parser.  The \code{map} method takes as
parameter a function $f$ which it applies to the results of the
current parser. The \code{flatMap} takes as parameter a function
\code{f} which returns a parser.  It applies \code{f} to the result of
the current parser and then continues with the resulting parser.  The
\code{|||} method is essentially defined as before.  The
\code{&&&} method can now be defined in terms of \code{for}.
\begin{lstlisting}
    def ||| (p: => Parser[A]) = new Parser[A] {
      def apply(in: InType): Result = Parser.this.apply(in) match {
        case None => p(in)
        case s => s
      }
    }

    def &&& [B](p: => Parser[B]): Parser[B] =
      for (_ <- this; x <- p) yield x
  }// end Parser
\end{lstlisting}

The primitive parser \code{succeed} replaces \code{empty}. It consumes
no input and returns its parameter as result.
\begin{lstlisting}
  def succeed[A](x: A) = new Parser[A] {
    def apply(in: InType) = Some(x, in)
  }
\end{lstlisting}

The parser combinators \code{rep} and \code{opt} now also return
results. \code{rep} returns a list which contains as elements the
results of each iteration of its sub-parser. \code{opt} returns a list
which is either empty or returns as single element the result of the
optional parser.
\begin{lstlisting}
  def rep[A](p: Parser[A]): Parser[List[A]] =
    rep1(p) ||| succeed(List())

  def rep1[A](p: Parser[A]): Parser[List[A]] =
    for (x <- p; xs <- rep(p)) yield x :: xs

  def opt[A](p: Parser[A]): Parser[List[A]] =
    (for (x <- p) yield List(x)) ||| succeed(List())
} // end Parsers
\end{lstlisting}
The root class \code{Parsers} abstracts over which kind of
input is parsed.  As before, we determine the input method by a separate class.
Here is \code{ParseString}, this time adapted to parsers that return results.
It defines now the method \code{any}, which returns the first input character.
\begin{lstlisting}
class ParseString(s: String) extends Parsers {
  type InType = Int
  val input = 0
  def any = new Parser[Char] {
    def apply(in: Int): Parser[Char]#Result =
      if (in < s.length()) Some(s charAt in, in + 1) else None
  }
}
\end{lstlisting}
The rest of the application is as before. Here is a test program which
constructs a list parser over strings and prints out the result of
applying it to the command line argument.
\begin{lstlisting}
object Test {
  def main(args: Array[String]) {
    val ps = new ParseString(args(0)) with ListParsers
    ps.expr(ps.input) match {
      case Some(list, _) => println("parsed: " + list)
      case None => println("nothing parsed")
    }
  }
}
\end{lstlisting}

\begin{exercise}\label{exercise:end-marker} The parsers we have defined so
far can succeed even if there is some input beyond the parsed text. To
prevent this, one needs a parser which recognizes the end of input.
Redesign the parser library so that such a parser can be introduced.
Which classes need to be modified?
\end{exercise}
}

\chapter{\label{sec:hm}Inferência de Tipos de Hindley/Milner}

Este capítulo demonstra os tipos de dados Scala e o casamento de padrôes através
do desenvolvimento de um sistema de inferência de tipos no estilo de Hindley/Milner
\cite{milner:polymorphism}. 
A linguagem fonte para a inferência de tipos é o cálculo lambda com uma construção
chamada Mini-ML. As árvoes de sintaxe abstrata para o Mini-ML 
são representadas através do tipo de dados \code{Terms}.
\begin{lstlisting}
abstract class Term {}
case class Var(x: String) extends Term {
  override def toString = x
}
case class Lam(x: String, e: Term) extends Term {
  override def toString = "(\\" + x + "." + e + ")"
}
case class App(f: Term, e: Term) extends Term {
  override def toString = "(" + f + " " + e + ")"
}
case class Let(x: String, e: Term, f: Term) extends Term {
  override def toString = "let " + x + " = " + e + " in " + f
}
\end{lstlisting}
Há quatro construtores de termos: \code{Var} para variáveis, \code{Lam}
para abstrações lambda, \code{App} para aplicação e
\code{Let} para expressões de atribuição. Cada uma destas classes sobrescreve o método
\code{toString} da classe \code{Any}, de forma que os termos podem ser impressos
de forma legível.

A seguir, definimos os tipos que serão computados pelo sistema de inferência.
\begin{lstlisting}
sealed abstract class Type {}
case class Tyvar(a: String) extends Type {
  override def toString = a
}
case class Arrow(t1: Type, t2: Type) extends Type {
  override def toString = "(" + t1 + "->" + t2 + ")"
}
case class Tycon(k: String, ts: List[Type]) extends Type {
  override def toString = 
    k + (if (ts.isEmpty) "" else ts.mkString("[", ",", "]"))
}
\end{lstlisting}
Há três construtores de tipos: \code{Tyvar} para o tipo variável,
\code{Arrow}  para o tipo função e  \code{Tycon}  para o tipo construtor como,
por exemplo, \code{Boolean} ou \code{List}. O tipo construtor tem como
componente uma lista de tipos que contem seus parâmetros. Esta lista é
vaiz para tipos constantes como \code{Boolean}. Assim como nos construtores
de termos, implementamos o método \code{toString} para mostrar os tipos de forma legível.

Note que \code{Type} foi declarada com o modificador \code{sealed}. Isto significa que
nenhuma sub-classe ou construtores de dados que extendam \code{Type} podem ser declarados fora
da sequência de definições em que \code{Type} foi definida.
Isto torna \code{Type} um tipo algébrico {\em fechado}  com exatas três alternativas. 
Em contraste, o tipo \code{Term} is um tipo algébrico {\em aberto} onde mais alternativas
poderâo ser definidas.

As principais partes da inferência de tipos estão contidas no objeto
\code{typeInfer}. Começamos com uma função utilitária que cria novos tipos variáveis:
\begin{lstlisting}
object typeInfer {
  private var n: Int = 0
  def newTyvar(): Type = { n += 1; Tyvar("a" + n) }
\end{lstlisting}
Em seguinda, definimos uma classe para substituições.
A substituição é uma função idempotente de tipos variáveis para tipos.
Ela mapeia um número finito de tipos variáveis para alguns tipos e não modifica todos 
os outros tipos.
O significado de uma substituição é extendido a partir de um mapeamento de tipos para tipos.
Também extendemos o significado da substituição para ambientes que serão definidos posteriormente.
\begin{lstlisting}
  abstract class Subst extends Function1[Type,Type] {

    def lookup(x: Tyvar): Type

    def apply(t: Type): Type = t match {
      case tv @ Tyvar(a) => val u = lookup(tv); if (t == u) t else apply(u)
      case Arrow(t1, t2) => Arrow(apply(t1), apply(t2))
      case Tycon(k, ts) => Tycon(k, ts map apply)
    }

    def apply(env: Env): Env = env.map({ case (x, TypeScheme(tyvars, tpe)) =>
      // assumes tyvars don't occur in this substitution
      (x, TypeScheme(tyvars, apply(tpe)))
    })

    def extend(x: Tyvar, t: Type) = new Subst {
      def lookup(y: Tyvar): Type = if (x == y) t else Subst.this.lookup(y)
    }
  }
  val emptySubst = new Subst { def lookup(t: Tyvar): Type = t }
\end{lstlisting}
Representamos substituições como funções do tipo \code{Type =>
Type}. Isto pode ser obtido fazendo com que a classe  \code{Subst} herde da tipo função unária  
\code{Function1[Type, Type]}\footnote{
A classe herda do tipo função como um mixin, ao invés de uma super-classe direta.
Isto ocorre porque na implementação atual de Scala, o tipo \code{Function1} é uma interface Java que
não pode ser uma super-classe de uma outra classe.}.
Para ser uma instância de \code{Subst}, uma substituição \code{s} tem que implementar o método \code{apply}
que recebe como argumento um \code{Type} e retorna um outro 
\code{Type} como resultado. A função aplicação \code{s(t)} é interpretada como \code{s.apply(t)}.

O método \code{lookup} é abstrato na classe \code{Subst}.  Existem duas formas concretas de substituição
que diferem em como elas implementam este método. Uma forma é definida pelo valor \code{emptySubst} e a outra
é definida pelo método \code{extend} na classe \code{Subst}.

O próximo tipo de dado descreve esquemas de tipos, que consistem de um tipo
e uma lista de nomes de tipos variáveis que aparecem universalmente quantificados
no esquema de tipos.
Por exemplo o esquema de tipos $\forall a\forall b.a \!\arrow\! b$ seria representado no checador de tipos como:
\begin{lstlisting}
TypeScheme(List(Tyvar("a"), Tyvar("b")), Arrow(Tyvar("a"), Tyvar("b"))) .
\end{lstlisting}
A definição da classe esquema de tipos não contém uma cláusula extends;
isso quer dizer que um esquema de tipos herda diretamente da classe
\code{AnyRef}.  Embora exista apenas uma única maneira de construir um
esquema de tipos, uma representação usando classe case foi escolhida, pois
oferece formas convenientes de acessar as partes de uma instância deste tipo.

\begin{lstlisting}
  case class TypeScheme(tyvars: List[Tyvar], tpe: Type) {
    def newInstance: Type = {
      (emptySubst /: tyvars) ((s, tv) => s.extend(tv, newTyvar())) (tpe)
    }
  }
\end{lstlisting}

Os objetos de esquemas de tipos vem com o método \code{newInstance}, que retorna o
tipo contido no esquema depois de todos os tipos variáveis tiverem sido renomeados
para novas variáveis. A implementação deste método reduz (com \code{/:}) 
os tipos variáveis do esquema de tipos  com uma função que extende uma dada substituição 
\code{s} renomeando um dado tipo variável \code{tv} em um novo tipo variável.
A substituição resultante renomeia todos os tipos variáveis do esquema em novos.
Esta substituição é então aplicada o tipo do esquema de tipos.

O último tipo que necessitamos no sistema de inferência de tipos é 
\code{Env}, um tipo para os ambientes, que associa nomes de variáveis à esquema de tipos. 
Eles são representados pelo tipo \code{Env} no módulo \code{typeInfer}:
\begin{lstlisting}
  type Env = List[(String, TypeScheme)]
\end{lstlisting}
Existem duas operações nos ambientes. A função  \code{lookup} 
retorna o esquema de tipos associado com um dado nome ou \code{null}
se o nome não foi registrado no ambiente.
\begin{lstlisting}
  def lookup(env: Env, x: String): TypeScheme = env match {
    case List() => null
    case (y, t) :: env1 => if (x == y) t else lookup(env1, x)
  }
\end{lstlisting}
A função \code{gen} retorna um esquema de tipos dado um tipo,
quantificando todos os tipos variáveis que estão livres no tipo, mas
não no ambiente.
\begin{lstlisting}
  def gen(env: Env, t: Type): TypeScheme = 
    TypeScheme(tyvars(t) diff tyvars(env), t)
\end{lstlisting}
o conjunto de tipos variáveis livres é simplesmente o conjunto de todos
os tipos variáveis que ocorrem no tipo. É representado por uma lista de tipos
variáveis construído da seguinte maneira.
\begin{lstlisting}
  def tyvars(t: Type): List[Tyvar] = t match {
    case tv @ Tyvar(a) => 
      List(tv)
    case Arrow(t1, t2) => 
      tyvars(t1) union tyvars(t2)
    case Tycon(k, ts) => 
      (List[Tyvar]() /: ts) ((tvs, t) => tvs union tyvars(t))
  }
\end{lstlisting}
Note que a sintaxe \code{tv @ ...} no primeiro padrão introduz a variável 
que está ligada ao padrão seguinte. 
Note também que o tipo parâmetro \code{[Tyvar]} explícito na expressão da terceita cláusula é necessário para
que a inferência de tipos locais funcione.

O conjunto de tipos variáveis livres de um esquema de tipos é o conjunto de tipos variáveis livre do seu tipo componente,
excluíndo-se quaisquer tipos variáveis quantificáveis.
\begin{lstlisting}
  def tyvars(ts: TypeScheme): List[Tyvar] = 
    tyvars(ts.tpe) diff ts.tyvars
\end{lstlisting}
Finalmente, o conjunto  tipos variáveis livres de um ambiente é a união
de todos os  tipos variáveis livres de todos os esquemas de tipos registrados neste ambiente.
\begin{lstlisting}
  def tyvars(env: Env): List[Tyvar] =
    (List[Tyvar]() /: env) ((tvs, nt) => tvs union tyvars(nt._2))
\end{lstlisting}
A principal operação da checagem de tipos de Hindley/Milner é a unificação,
que computa a substituição para fazer que dois tipos dados se tornem iguais
 (esta subsituição é chamada um {\em unificador}\footnote{unifier}).  A função \code{mgu} computa
o unificador mais geral de dois tipos dados $t$ e $u$ sob um substituição pre-existente $s$.  
Isto é, ele retorna a substituição mais geral $s'$ que herda de $s$, e que faz com que $s'(t)$ e
$s'(u)$ retornem tipos iguais. 
\begin{lstlisting}
  def mgu(t: Type, u: Type, s: Subst): Subst = (s(t), s(u)) match {
    case (Tyvar(a), Tyvar(b)) if (a == b) =>
      s
    case (st @ Tyvar(a), su) if !(tyvars(su) contains st) =>
      s.extend(st, su)
    case (_, Tyvar(a)) =>
      mgu(u, t, s)
    case (Arrow(t1, t2), Arrow(u1, u2)) =>
      mgu(t1, u1, mgu(t2, u2, s))
    case (Tycon(k1, ts), Tycon(k2, us)) if (k1 == k2) =>
      (s /: (ts zip us)) ((s, tu) => mgu(tu._1, tu._2, s))
    case _ => 
      throw new TypeError("cannot unify " + s(t) + " with " + s(u))
  }
\end{lstlisting}
A função \code{mgu} lança uma exceção do tipo \code{TypeError} se não existir uma
substituição unificadora. Isto pode ocorrer quando os dois tipos tem diferentes
tipos construtores em seus lugares correspondentes ou quando um tipo variável é 
unificado com um tipo que contém um tipo variável dele mesmo.
Estas exceções foram modeladas como instâncias de classe case que herdam um classe
 \code{Exception} pré-definida.
\begin{lstlisting}
  case class TypeError(s: String) extends Exception(s) {}
\end{lstlisting}
A principal tarefa do checador de tipos é implementada pela função
\code{tp}. Esta função recebe como parâmetro um ambiente $env$,  um termo $e$, um tipo $t$, e
uma substituição pre-existente $s$.  A função retorna uma substituição
$s'$ que herda de  $s$ e que torna $s'(env) \ts e: s'(t)$ num julgamento de tipos derivável de acordo
com as regras de derivação do sistema de tipos de Hindley/Milner\cite{milner:polymorphism}.  Uma exceção do tipo
\code{TypeError} é lançada se não existe uma substituição com estas características.
\begin{lstlisting}
  def tp(env: Env, e: Term, t: Type, s: Subst): Subst = {
    current = e
    e match {
      case Var(x) =>
        val u = lookup(env, x)
        if (u == null) throw new TypeError("undefined: " + x)
        else mgu(u.newInstance, t, s)

      case Lam(x, e1) =>
        val a, b = newTyvar()
        val s1 = mgu(t, Arrow(a, b), s)
        val env1 = {x, TypeScheme(List(), a)} :: env
        tp(env1, e1, b, s1)

      case App(e1, e2) =>
        val a = newTyvar()
        val s1 = tp(env, e1, Arrow(a, t), s)
        tp(env, e2, a, s1)

      case Let(x, e1, e2) =>
        val a = newTyvar()
        val s1 = tp(env, e1, a, s)
        tp({x, gen(s1(env), s1(a))} :: env, e2, t, s1)
    }
  } 
  var current: Term = null
\end{lstlisting}
Para auxiliar no diagnóstico de erros, a função \code{tp} guarda o sub-termo que
está sendo analisado na variável \code{current}. Com isso, se a checagem de tipos
for iterrompido por uma exceção do tipo \code{TypeError}, esta variável conterá o
sub-termo que causou o problema.

A última função do módulo de inferência de tipos , \code{typeOf}, é uma façade simplificada
para \code{tp}. Ela computa o tipo de um dado termo
$e$ em um dado ambiente $env$. Ela o faz através da criação de um novo tipo variável $a$, 
e da computação da substituição de tipos que faz $env \ts e: a$  se tornar um tipo derivado 
e retorna o resultado da aplicação da subsituição em $a$.
\begin{lstlisting}
  def typeOf(env: Env, e: Term): Type = {
    val a = newTyvar()
    tp(env, e, a, emptySubst)(a)
  }
}// end typeInfer
\end{lstlisting}
Para usar o sistema de inferência de tipos, é conveniente ter um ambiente
pré-definido que contém as definições das constantes mais comumente usadas.
O módulo \code{predefined} define um ambiente \code{env} que contém as definições dos tipos 
booleanos, números e listas assim como algumas operações primitivas sobre eles.
Também define um operador de ponto fixo \code{fix}, que pode ser usado para representar uma
recursão.
\begin{lstlisting}
object predefined {
  val booleanType = Tycon("Boolean", List())
  val intType = Tycon("Int", List())
  def listType(t: Type) = Tycon("List", List(t))

  private def gen(t: Type): typeInfer.TypeScheme = typeInfer.gen(List(), t)
  private val a = typeInfer.newTyvar()
  val env = List(
    {"true", gen(booleanType)},
    {"false", gen(booleanType)},
    {"if", gen(Arrow(booleanType, Arrow(a, Arrow(a, a))))},
    {"zero", gen(intType)},
    {"succ", gen(Arrow(intType, intType))},
    {"nil", gen(listType(a))},
    {"cons", gen(Arrow(a, Arrow(listType(a), listType(a))))},
    {"isEmpty", gen(Arrow(listType(a), booleanType))},
    {"head", gen(Arrow(listType(a), a))},
    {"tail", gen(Arrow(listType(a), listType(a)))},
    {"fix", gen(Arrow(Arrow(a, a), a))}
  )
}
\end{lstlisting}
Aqui está um exemplo de como o sistema de inferência de tipos pode ser
usado. Vamos definir a função \code{showType} que retorna os tipos de um dado
termo computado em um dado ambiente
\code{Predefined.env}:
\begin{lstlisting}
object testInfer {
  def showType(e: Term): String =
    try {
      typeInfer.typeOf(predefined.env, e).toString
    } catch {
      case typeInfer.TypeError(msg) => 
        "\n cannot type: " + typeInfer.current +
        "\n reason: " + msg
    }
\end{lstlisting}
Então a aplicação
\begin{lstlisting}
> testInfer.showType(Lam("x", App(App(Var("cons"), Var("x")), Var("nil"))))
\end{lstlisting}
retornará a resposta
\begin{lstlisting}
> (a6->List[a6])
\end{lstlisting}
\comment{
To make the type inferencer more useful, we complete it with a
parser. 
Function \code{main} of module \code{testInfer}
parses and typechecks a Mini-ML expression which is given as the first
command line argument.
\begin{lstlisting}
  def main(args: Array[String]) {
    val ps = new ParseString(args(0)) with MiniMLParsers
    ps.all(ps.input) match {
      case Some(term, _) =>
        println("" + term + ": " + showType(term))
      case None =>
        println("syntax error")
    }
  }
%}// testInfer
\end{lstlisting}
To do the parsing, method \code{main} uses the combinator parser
scheme of Chapter~\ref{sec:combinator-parsing}. It creates a parser
family \code{ps} as a mixin composition of parsers
that understand MiniML (but do not know where input comes from) and
parsers that read input from a given string.  The \code{MiniMLParsers}
object implements parsers for the following grammar.
\begin{lstlisting}
term  ::= "\" ident "." term
       |  term1 {term1}
       |  "let" ident "=" term "in" term
term1 ::= ident
       |  "(" term ")"
all   ::= term ";"
\end{lstlisting}
Input as a whole is described by the production \code{all}; it
consists of a term followed by a semicolon. We allow ``whitespace''
consisting of one or more space, tabulator or newline characters
between any two lexemes (this is not reflected in the grammar
above). Identifiers are defined as in
Chapter~\ref{sec:combinator-parsing} except that an identifier cannot
be one of the two reserved words "let" and "in".
\begin{lstlisting}
trait MiniMLParsers extends CharParsers {

  /** whitespace */
  def whitespace = rep{chr(' ') ||| chr('\t') ||| chr('\n')}

  /** A given character, possible preceded by whitespace */
  def wschr(ch: Char) = whitespace &&& chr(ch)

  /** identifiers or keywords */
  def id: Parser[String] = 
    for {
      c: Char <- whitespace &&& chrSuchThat(Character.isLetter)
      cs: List[Char] <- rep(chrSuchThat(Character.isLetterOrDigit))
    } yield (c :: cs).mkString("", "", "")

  /** Non-keyword identifiers */
  def ident: Parser[String] =
    for { s <- id if s != "let" && s != "in" } yield s

  /** term = '\' ident '.' term | term1 {term1} | let ident "=" term in term */
  def term: Parser[Term] = (
    ( for {
        _ <- wschr('\\')
        x <- ident
        _ <- wschr('.')
        t <- term
      } yield Lam(x, t): Term )
    |||
    ( for {
        letid <- id if letid == "let"
        x <- ident
        _ <- wschr('=')
        t <- term; 
        inid <- id; inid == "in"
        c <- term
      } yield Let(x, t, c) )
    |||
    ( for {
        t <- term1
        ts <- rep(term1)
      } yield (t /: ts)((f, arg) => App(f, arg)) )
  )     

  /** term1 = ident | '(' term ')' */
  def term1: Parser[Term] = (
    ( for { s <- ident }
      yield Var(s): Term )
    |||
    ( for {
        _ <- wschr('(')
        t <- term
        _ <- wschr(')')
      } yield t )
  )

  /** all = term ';' */
  def all: Parser[Term] = 
    for {
      t <- term
      _ <- wschr(';')
    } yield t
}
\end{lstlisting}
Aqui estão alguns exemplos de programas MiniML e a saída que o sistema de inferência de tipos retorna para cada um deles:
\begin{lstlisting}
> java testInfer
| "\x.\f.f(f x);"
(\x.(\f.(f (f x)))): (a8->((a8->a8)->a8))

> java testInfer 
| "let id = \x.x  
|  in if (id true) (id nil) (id (cons zero nil));"
let id = (\x.x) in (((if (id true)) (id nil)) (id ((cons zero) nil))): List[Int]

> java testInfer
| "let id = \x.x 
|  in if (id true) (id nil);"
let id = (\x.x) in ((if (id true)) (id nil)): (List[a13]->List[a13])

> java testInfer
| "let length = fix (\len.\xs.
|    if (isEmpty xs) 
|      zero 
|      (succ (len (tail xs))))
|  in (length nil);"
let length = (fix (\len.(\xs.(((if (isEmpty xs)) zero) 
(succ (len (tail xs))))))) in (length nil): Int

> java testInfer 
| "let id = \x.x 
|  in if (id true) (id nil) zero;"
let id = (\x.x) in (((if (id true)) (id nil)) zero): 
 cannot type: zero
 reason: cannot unify Int with List[a14]
\end{lstlisting}

\begin{exercise}\label{exercise:hm-parse} Usando a biblioteca de parser cria no
Exercise~\ref{exercise:end-marker}, modifique a biblioteca de parser MiniML de tal forma
que o marcador ``;'' não seja necessária para indicar o fim de uma entrada.
\end{exercise}
}

\begin{exercise}\label{execcise:hm-extend} Extenda o \comment{parser} Mini-ML e o sistema de inferência de tipos
com uma construção \code{letrec} que permita a definição recursiva de funções. 
Sintaxe:
\begin{lstlisting}
letrec ident "=" term in term .
\end{lstlisting}
Os tipos de \code{letrec} devem ser como os de \code{let}, 
exceto que os identificadores definidos são visíveis na expressão que está sendo definida. Usando \code{letrec}, a função \code{length} 
para listas seria definida da seguinte maneira.
\begin{lstlisting}
letrec length = \xs.
  if (isEmpty xs)
    zero
    (succ (length (tail xs)))
in ...
\end{lstlisting}
\end{exercise}

\chapter{Abstracões para Concorrência}\label{sec:ex-concurrency}

Esta seção revisa padrôes comuns de concorrência e mostra como eles
podem ser implementados em Scala.

\section{Sinais e Monitores}

\example
Um {\em monitor} provê mecanismos básicos para processos mutuamente exclusivos
em Scala. Toda instância de \code{AnyRef} pode ser usada como um monitor através
da chamada de um ou mais dos métodos apresentados a seguir.
\begin{lstlisting}
  def synchronized[A] (e: => A): A
  def wait()
  def wait(msec: Long)
  def notify()
  def notifyAll()
\end{lstlisting}
O método \code{synchronized} computa \code{e} em modo mutuamente exclusivo --
em um dado momento qualquer, somente uma thread pode executar um argumento
\code{synchronized} em um dado monitor.

Threads podem ser paradas dentro de um monitor e esperar por um sinal.  
Threads podem chamar o método \code{wait} e esperar até que o método \code{notify} do mesmo
objeto seja chamado por alguma outra thread. Chamadas ao método
\code{notify} quando não existam threads esperando por um sinal são ignoradas.

Existe também uma forma do método \code{wait} baseada em tempo em que a
execução é bloqueada enquanto nenhum sinal seja recebido ou um dado espaço de tempo (dado em
milisegundos) tenha passado. Além disso, há o método \code{notifyAll} que desbloqueia todas
as threads que estejam esperando por um sinal. Estes métodos, assim como a classe \code{Monitor} 
são primitivos em Scala, ou seja, eles são implementados usando os mecanismos internos do sistema de execução
dos programas.

Tipicamente, uma thread espera até que um certa condição ocorra. 
Se esta condição não ocorrer até o tempo definido na chamada do método \code{wait}, 
a thread fica com execução suspensa até que alguma outra thread estabeleça tal condição
ou que o tempo definido tenha passado. É responsabilidade desta outra thread reiniciar
os processos que estavam esperando através da chamada dos métodos \code{notify} ou \code{notifyAll}. 
Note que não existe garantia de que um processo em espera execute imediatamente após a chamada do método
\code{notify}. Pode ocorrer de outros processos que executem antes invalidem novamente esta condição,
deixando as threads suspensas.  Portanto, a forma correta de esperar uma condição $C$ usa um laço do tipo while:
\begin{lstlisting}
while (!$C$) wait()
\end{lstlisting}

Como um exemplo de como os monitores são usados, aqui está uma implementação de uma classe de buffer com limites.
\begin{lstlisting}
class BoundedBuffer[A](N: Int) {
  var in = 0, out = 0, n = 0
  val elems = new Array[A](N)

  def put(x: A) = synchronized {
    while (n >= N) wait()
    elems(in) = x ; in = (in + 1) % N ; n = n + 1
    if (n == 1) notifyAll()
  }

  def get: A = synchronized {
    while (n == 0) wait()
    val x = elems(out) ; out = (out + 1) % N ; n = n - 1
    if (n == N - 1) notifyAll()
    x
  }
}
\end{lstlisting}
E aqui está um programa usando esta classe para comunicar entre processos
consumidores e produtores.
\begin{lstlisting}
import scala.concurrent.ops._
...
val buf = new BoundedBuffer[String](10)
spawn { while (true) { val s = produceString ; buf.put(s) } }
spawn { while (true) { val s = buf.get ; consumeString(s) } }
}
\end{lstlisting}
O método \code{spawn} dispara uma nova thread que executa a expressão passada como
parâmetro. Foi definida no objeto \code{concurrent.ops} da seguinte maneira:
\begin{lstlisting}
def spawn(p: => Unit) {
  val t = new Thread() { override def run() = p }
  t.start()
}
\end{lstlisting}

\comment{
\section{Logic Variable}

A logic variable (or lvar for short) offers operations \code{:=}
and \code{value} to define the variable and to retrieve its value.
Variables can be \code{define}d only once. A call to \code{value}
blocks until the variable has been defined.

Logic variables can be implemented as follows.

\begin{lstlisting}
class LVar[A] {
  private val defined = new Signal
  private var isDefined: Boolean = false
  private var v: A
  def value = synchronized {
    if (!isDefined) defined.wait
    v
  }
  def :=(x: A) = synchronized {
    v = x; isDefined = true; defined.send
  }
}
\end{lstlisting}
}

\section{SyncVars}

Uma variável sincronizada (ou syncvar) oferece as operações \code{get} e 
\code{put} para ler e escrever na variável. As operações \code{get} bloqueiam
a execução até que o valor da variável tenha sido definido. Um operação \code{unset}
coloca o valor da variável em um valor indefinido.

Aqui segue uma implementação padrão de variáveis sincronizadas:
\begin{lstlisting}
package scala.concurrent
class SyncVar[A] {
  private var isDefined: Boolean = false
  private var value: A = _
  def get = synchronized {
    while (!isDefined) wait()
    value
  }
  def set(x: A) = synchronized {
    value = x; isDefined = true; notifyAll()
  }
  def isSet: Boolean = synchronized {
    isDefined
  }
  def unset = synchronized {
    isDefined = false
  }
}
\end{lstlisting}

\section{Futures}
\label{sec:futures}

A {\em future} is a value which is computed in parallel to some other
client thread, to be used by the client thread at some future time.
Futures are used in order to make good use of parallel processing
resources.  A typical usage is:

\begin{lstlisting}
import scala.concurrent.ops._
...
val x = future(someLengthyComputation)
anotherLengthyComputation
val y = f(x()) + g(x())
\end{lstlisting}

The \code{future} method is defined in object
\code{scala.concurrent.ops} as follows.
\begin{lstlisting}
def future[A](p: => A): Unit => A = {
  val result = new SyncVar[A]
  fork { result.set(p) }
  (() => result.get)
}
\end{lstlisting}

The \code{future} method gets as parameter a computation \code{p} to
be performed. The type of the computation is arbitrary; it is
represented by \code{future}'s type parameter \code{a}.  The
\code{future} method defines a guard \code{result}, which takes a
parameter representing the result of the computation. It then forks
off a new thread that computes the result and invokes the
\code{result} guard when it is finished. In parallel to this thread,
the function returns an anonymous function of type \code{a}.
When called, this functions waits on the result guard to be
invoked, and, once this happens returns the result argument.
At the same time, the function reinvokes the \code{result} guard with
the same argument, so that future invocations of the function can
return the result immediately.

\section{Parallel Computations}

The next example presents a function \code{par} which takes a pair of
computations as parameters and which returns the results of the computations
in another pair. The two computations are performed in parallel.

The function is defined in object
\code{scala.concurrent.ops} as follows.
\begin{lstlisting}
  def par[A, B](xp: => A, yp: => B): (A, B) = {
    val y = new SyncVar[B]
    spawn { y set yp }
    (xp, y.get)
  }
\end{lstlisting}
Defined in the same place is a function \code{replicate} which performs a
number of replicates of a computation in parallel. Each
replication instance is passed an integer number which identifies it.
\begin{lstlisting}
  def replicate(start: Int, end: Int)(p: Int => Unit) {
    if (start == end)
      ()
    else if (start + 1 == end)
      p(start)
    else {
      val mid = (start + end) / 2
      spawn { replicate(start, mid)(p) }
      replicate(mid, end)(p)
    }
  }
\end{lstlisting}

The next function uses \code{replicate} to perform parallel
computations on all elements of an array.

\begin{lstlisting}
def parMap[A,B](f: A => B, xs: Array[A]): Array[B] = {
  val results = new Array[B](xs.length)
  replicate(0, xs.length) { i => results(i) = f(xs(i)) }
  results
}
\end{lstlisting}

\section{Semaphores}

A common mechanism for process synchronization is a {\em lock} (or:
{\em semaphore}). A lock offers two atomic actions: \prog{acquire} and
\prog{release}. Here's the implementation of a lock in Scala:

\begin{lstlisting}
package scala.concurrent

class Lock {
  var available = true
  def acquire = synchronized {
    while (!available) wait()
    available = false
  }
  def release = synchronized {
    available = true
    notify()
  }
}
\end{lstlisting}

\section{Readers/Writers}

A more complex form of synchronization distinguishes between {\em
readers} which access a common resource without modifying it and {\em
writers} which can both access and modify it. To synchronize readers
and writers we need to implement operations \prog{startRead}, \prog{startWrite},
\prog{endRead}, \prog{endWrite}, such that:
\begin{itemize}
\item there can be multiple concurrent readers,
\item there can only be one writer at one time,
\item pending write requests have priority over pending read requests,
but don't preempt ongoing read operations.
\end{itemize}
The following implementation of a readers/writers lock is based on the
{\em mailbox} concept (see Section~\ref{sec:mailbox}).

\begin{lstlisting}
import scala.concurrent._

class ReadersWriters {
  val m = new MailBox
  private case class Writers(n: Int), Readers(n: Int) { m send this }
  Writers(0); Readers(0)
  def startRead = m receive {
    case Writers(n) if n == 0 => m receive {
      case Readers(n) => Writers(0); Readers(n+1)
    }
  }
  def startWrite = m receive {
    case Writers(n) =>
      Writers(n+1)
      m receive { case Readers(n) if n == 0 => }
  }
  def endRead = m receive {
    case Readers(n) => Readers(n-1)
  }
  def endWrite = m receive {
    case Writers(n) => Writers(n-1); if (n == 0) Readers(0)
  }
}
\end{lstlisting}

\section{Asynchronous Channels}

A fundamental way of interprocess communication is the asynchronous
channel. Its implementation makes use the following simple class for linked
lists:
\begin{lstlisting}
class LinkedList[A] {
  var elem: A = _
  var next: LinkedList[A] = null
}
\end{lstlisting}
To facilitate insertion and deletion of elements into linked lists,
every reference into a linked list points to the node which precedes
the node which conceptually forms the top of the list.
Empty linked lists start with a dummy node, whose successor is \code{null}.

The channel class uses a linked list to store data that has been sent
but not read yet. At the opposite end, threads that
wish to read from an empty channel, register their presence by
incrementing the \code{nreaders} field and waiting to be notified.
\begin{lstlisting}
package scala.concurrent

class Channel[A] {
  class LinkedList[A] {
    var elem: A = _
    var next: LinkedList[A] = null
  }
  private var written = new LinkedList[A]
  private var lastWritten = written
  private var nreaders = 0

  def write(x: A) = synchronized {
    lastWritten.elem = x
    lastWritten.next = new LinkedList[A]
    lastWritten = lastWritten.next
    if (nreaders > 0) notify()
  }

  def read: A = synchronized {
    if (written.next == null) {
      nreaders = nreaders + 1; wait(); nreaders = nreaders - 1
    }
    val x = written.elem
    written = written.next
    x
  }
}
\end{lstlisting}

\section{Synchronous Channels}

Here's an implementation of synchronous channels, where the sender of
a message blocks until that message has been received. Synchronous
channels only need a single variable to store messages in transit, but
three signals are used to coordinate reader and writer processes.
\begin{lstlisting}
package scala.concurrent

class SyncChannel[A] {
  private var data: A = _
  private var reading = false
  private var writing = false

  def write(x: A) = synchronized {
    while (writing) wait()
    data = x
    writing = true
    if (reading) notifyAll()
    else while (!reading) wait()
  }

  def read: A = synchronized {
    while (reading) wait()
    reading = true
    while (!writing) wait()
    val x = data
    writing = false
    reading = false
    notifyAll()
    x
  }
}
\end{lstlisting}

\section{Workers}

Here's an implementation of a {\em compute server} in Scala. The
server implements a \code{future} method which evaluates a given
expression in parallel with its caller. Unlike the implementation in
Section~\ref{sec:futures} the server computes futures only with a
predefined number of threads. A possible implementation of the server
could run each thread on a separate processor, and could hence avoid
the overhead inherent in context-switching several threads on a single
processor.

\begin{lstlisting}
import scala.concurrent._, scala.concurrent.ops._

class ComputeServer(n: Int) {

  private abstract class Job {
    type T
    def task: T
    def ret(x: T)
  }

  private val openJobs = new Channel[Job]()

  private def processor(i: Int) {
    while (true) {
      val job = openJobs.read
      job.ret(job.task)
    }
  }

  def future[A](p: => A): () => A = {
    val reply = new SyncVar[A]()
    openJobs.write{
      new Job {
        type T = A
        def task = p
        def ret(x: A) = reply.set(x)
      }
    }
    () => reply.get
  }

  spawn(replicate(0, n) { processor })
}
\end{lstlisting}
Expressions to be computed (i.e. arguments
to calls of \code{future}) are written to the \code{openJobs}
channel. A {\em job} is an object with
\begin{itemize}
\item
An abstract type \code{T} which describes the result of the compute
job.
\item
A parameterless \code{task} method of type \code{t} which denotes
the expression to be computed.
\item
A \code{ret} method which consumes the result once it is
computed.
\end{itemize}
The compute server creates $n$ \code{processor} processes as part of
its initialization.  Every such process repeatedly consumes an open
job, evaluates the job's \code{task} method and passes the result on
to the job's
\code{ret} method. The polymorphic \code{future} method creates
a new job where the \code{ret} method is implemented by a guard
named \code{reply} and inserts this job into the set of open jobs. 
It then waits until the corresponding
\code{reply} guard is called.

The example demonstrates the use of abstract types. The abstract type
\code{t} keeps track of the result type of a job, which can vary
between different jobs. Without abstract types it would be impossible
to implement the same class to the user in a statically type-safe
way, without relying on dynamic type tests and type casts.


Here is some code which uses the compute server to evaluate 
the expression \code{41 + 1}.
\begin{lstlisting}
object Test with Executable {
  val server = new ComputeServer(1)
  val f = server.future(41 + 1)
  println(f())
}
\end{lstlisting}

\section{Mailboxes}
\label{sec:mailbox}

Mailboxes are high-level, flexible constructs for process
synchronization and communication. They allow sending and receiving of
messages. A {\em message} in this context is an arbitrary object.
There is a special message \code{TIMEOUT} which is used to signal a
time-out.
\begin{lstlisting}
case object TIMEOUT
\end{lstlisting}
Mailboxes implement the following signature.
\begin{lstlisting}
class MailBox {
  def send(msg: Any)
  def receive[A](f: PartialFunction[Any, A]): A
  def receiveWithin[A](msec: Long)(f: PartialFunction[Any, A]): A
}
\end{lstlisting}
The state of a mailbox consists of a multi-set of messages.
Messages are added to the mailbox with the \code{send} method. Messages
are removed using the \code{receive} method, which is passed a message
processor \code{f} as argument, which is a partial function from
messages to some arbitrary result type. Typically, this function is
implemented as a pattern matching expression. The \code{receive}
method blocks until there is a message in the mailbox for which its
message processor is defined.  The matching message is then removed
from the mailbox and the blocked thread is restarted by applying the
message processor to the message. Both sent messages and receivers are
ordered in time. A receiver $r$ is applied to a matching message $m$
only if there is no other $\{$message, receiver$\}$ pair which precedes ${m,
r}$ in the partial ordering on pairs that orders each component in
time.

As a simple example of how mailboxes are used, consider a
one-place buffer:
\begin{lstlisting}
class OnePlaceBuffer {
  private val m = new MailBox             // An internal mailbox
  private case class Empty, Full(x: Int)  // Types of messages we deal with
  m send Empty                            // Initialization
  def write(x: Int)
    { m receive { case Empty => m send Full(x) } }
  def read: Int =
    m receive { case Full(x) => m send Empty; x }
}
\end{lstlisting}
Here's how the mailbox class can be implemented:
\begin{lstlisting}
class MailBox {
  private abstract class Receiver extends Signal {
    def isDefined(msg: Any): Boolean
    var msg = null
  }
\end{lstlisting}
We define an internal class for receivers with a test method
\code{isDefined}, which indicates whether the receiver is
defined for a given message.  The receiver inherits from class
\code{Signal} a \code{notify} method which is used to wake up a
receiver thread. When the receiver thread is woken up, the message it
needs to be applied to is stored in the \code{msg} variable of
\code{Receiver}.
\begin{lstlisting}
  private val sent = new LinkedList[Any]
  private var lastSent = sent
  private val receivers = new LinkedList[Receiver]
  private var lastReceiver = receivers
\end{lstlisting}
The mailbox class maintains two linked lists,
one for sent but unconsumed messages, the other for waiting receivers.
\begin{lstlisting}
  def send(msg: Any) = synchronized {
    var r = receivers, r1 = r.next
    while (r1 != null && !r1.elem.isDefined(msg)) {
      r = r1; r1 = r1.next
    }
    if (r1 != null) {
      r.next = r1.next; r1.elem.msg = msg; r1.elem.notify
    } else {
      lastSent = insert(lastSent, msg)
    }
  }
\end{lstlisting}
The \code{send} method first checks whether a waiting receiver is
applicable to the sent message. If yes, the receiver is notified.
Otherwise, the message is appended to the linked list of sent messages.
\begin{lstlisting}
  def receive[A](f: PartialFunction[Any, A]): A = {
    val msg: Any = synchronized {
      var s = sent, s1 = s.next
      while (s1 != null && !f.isDefinedAt(s1.elem)) {
        s = s1; s1 = s1.next
      }
      if (s1 != null) {
        s.next = s1.next; s1.elem
      } else {
        val r = insert(lastReceiver, new Receiver {
          def isDefined(msg: Any) = f.isDefinedAt(msg)
        })
        lastReceiver = r
        r.elem.wait()
        r.elem.msg
      }
    }
    f(msg)
  }
\end{lstlisting}
The \code{receive} method first checks whether the message processor function
\code{f} can be applied to a message that has already been sent but that
was not yet consumed. If yes, the thread continues immediately by
applying \code{f} to the message. Otherwise, a new receiver is created
and linked into the \code{receivers} list, and the thread waits for a
notification on this receiver. Once the thread is woken up again, it
continues by applying \code{f} to the message that was stored in the
receiver. The insert method on linked lists is defined as follows.
\begin{lstlisting}
  def insert(l: LinkedList[A], x: A): LinkedList[A] = {
    l.next = new LinkedList[A]
    l.next.elem = x
    l.next.next = l.next
    l
  }
\end{lstlisting}
The mailbox class also offers a method \code{receiveWithin}
which blocks for only a specified maximal amount of time.  If no
message is received within the specified time interval (given in
milliseconds), the message processor argument $f$ will be unblocked
with the special \code{TIMEOUT} message.  The implementation of
\code{receiveWithin} is quite similar to \code{receive}:
\begin{lstlisting}
  def receiveWithin[A](msec: Long)(f: PartialFunction[Any, A]): A = {
    val msg: Any = synchronized {
      var s = sent, s1 = s.next
      while (s1 != null && !f.isDefinedAt(s1.elem)) {
        s = s1; s1 = s1.next 
      }
      if (s1 != null) {
        s.next = s1.next; s1.elem
      } else {
        val r = insert(lastReceiver, new Receiver {
            def isDefined(msg: Any) = f.isDefinedAt(msg)
        })
        lastReceiver = r
        r.elem.wait(msec)
        if (r.elem.msg == null) r.elem.msg = TIMEOUT
        r.elem.msg
      }
    }
    f(msg)
  }
} // end MailBox
\end{lstlisting}
The only differences are the timed call to \code{wait}, and the
statement following it.

\section{Actors}
\label{sec:actors}

Chapter~\ref{chap:example-auction} apresentou um programa como exemplo de implementação
de um serviço de leilão eletrônico. Este serviço foi baseado em atores quue representam processos 
de alto nível e trabalham inspecionando as mensagens em sua caixa-postal usando casamento de padrões.
Uma implementação mais refinada e otimizada de atores pode ser encontrada no pacote \lstinline@scala.actors@.
Agora mostraremos um rascunho de uma versão simplificada da biblioteca de atores.

O código apresentado a seguir é diferente da implementação presente no pacote \lstinline@scala.actors@ e, 
portanto, deve ser vista como um exemplo de como uma versão simplificada dos atores poderia ser implementada.
Ela não descreve como os atores foram definidos e implementados na biblioteca padrão de Scala. Caso deseje
essa informação, por favor consulte a documentação da API de Scala.

Um ator simplificado é apenas uma thread cujas primitivas de comunicação são aquelas de uma caixa postal.
Tal ator pode ser definido como uma composição mixin da extensão da classe Java padrão 
\code{Thread} com a classe \code{MailBox}. Nós também sobre-escrevemos o método \code{run} da classe \code{Thread}, de 
tal forma que ele execute o comportamento de um ator que é definido pelo método \code{act}.
O método \code{!} simplesmente chama o método \code{send} da classe 
\code{MailBox}:
\begin{lstlisting}
abstract class Actor extends Thread with MailBox {
  def act(): Unit
  override def run(): Unit = act()
  def !(msg: Any) = send(msg)
}
\end{lstlisting}

%% A parte a ser traduzida termina aqui!!!


\comment{
As an extended example of an application that uses actors, we come
back to the auction server example of Section~\ref{sec:ex-auction}.
The following code implements:

\begin{figure}[thb]
\begin{lstlisting}
class AuctionMessage
case class
  Offer(bid: Int, client: Process),                  // make a bid
  Inquire(client: Process) extends AuctionMessage    // inquire status

class AuctionReply
case class
  Status(asked: Int, expiration: Date),           // asked sum, expiration date
  BestOffer,                                         // yours is the best offer
  BeatenOffer(maxBid: Int),                          // offer beaten by maxBid
  AuctionConcluded(seller: Process, client: Process),// auction concluded
  AuctionFailed                                      // failed with no bids
  AuctionOver extends AuctionReply                   // bidding is closed
\end{lstlisting}
\end{figure}

\begin{lstlisting}
class Auction(seller: Process, minBid: Int, closing: Date)
 extends Process {

  val timeToShutdown = 36000000 // msec
  val delta = 10                // bid increment
\end{lstlisting}
\begin{lstlisting}
  override def run = {
    var askedBid = minBid
    var maxBidder: Process = null
    while (true) {
      receiveWithin ((closing - Date.currentDate).msec) {
        case Offer(bid, client) => {
          if (bid >= askedBid) {
            if (maxBidder != null && maxBidder != client) {
              maxBidder send BeatenOffer(bid)
            }
            maxBidder = client
            askedBid = bid + delta
            client send BestOffer
          } else client send BeatenOffer(maxBid)
        }
\end{lstlisting}
\begin{lstlisting}
        case Inquire(client) => {
          client send Status(askedBid, closing)
        }
\end{lstlisting}
\begin{lstlisting}
        case TIMEOUT => {
          if (maxBidder != null) {
            val reply = AuctionConcluded(seller, maxBidder)
            maxBidder send reply
            seller send reply
          } else seller send AuctionFailed
          receiveWithin (timeToShutdown) {
            case Offer(_, client) => client send AuctionOver; discardAndContinue
            case _ => discardAndContinue
            case TIMEOUT => stop
          }
        }
\end{lstlisting}
\begin{lstlisting}
        case _ => discardAndContinue
      }
    }
  }
\end{lstlisting}
\begin{lstlisting}
  def houseKeeping: Int = {
    val Limit = 100
    var nWaiting: Int = 0
    receiveWithin(0) {
      case _ =>
        nWaiting = nWaiting + 1
        if (nWaiting > Limit) {
          receiveWithin(0) {
            case Offer(_, _) => continue
            case TIMEOUT =>
            case _ => discardAndContinue
          }
        } else continue
      case TIMEOUT =>
    }
  }
}
\end{lstlisting}
\begin{lstlisting}
class Bidder (auction: Process, minBid: Int, maxBid: Int)
 extends Process {
  val MaxTries = 3
  val Unknown = -1

  var nextBid = Unknown
\end{lstlisting}
\begin{lstlisting}
  def getAuctionStatus = {
    var nTries = 0
    while (nextBid == Unknown && nTries < MaxTries) {
      auction send Inquiry(this)
      nTries = nTries + 1
      receiveWithin(waitTime) {
        case Status(bid, _) => bid match {
          case None => nextBid = minBid
          case Some(curBid) => nextBid = curBid + Delta
        }
        case TIMEOUT =>
        case _ => continue
      }
    }
    status
  }
\end{lstlisting}
\begin{lstlisting}
  def bid {
    if (nextBid < maxBid) {
      auction send Offer(nextBid, this)
      receive {
        case BestOffer =>
          receive {
            case BeatenOffer(bestBid) =>
              nextBid = bestBid + Delta
              bid
            case AuctionConcluded(seller, client) =>
                   transferPayment(seller, nextBid)
            case _ => continue
          }

        case BeatenOffer(bestBid) =>
          nextBid = nextBid + Delta
          bid

        case AuctionOver =>

        case _ => continue
      }
    }
  }
\end{lstlisting}
\begin{lstlisting}
  override def run = {
    getAuctionStatus
    if (nextBid != Unknown) bid
  }

  def transferPayment(seller: Process, amount: Int)
}
\end{lstlisting}
}
